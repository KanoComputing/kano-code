<link rel="import" href="./sdk.html">
<script>
    (function (Kano) {

        Kano.MakeApps = Kano.MakeApps || {};

        let loadDebouncer = null,
            neverLoaded = true,
            Progress,
            progress = {},
            sharedStorage,
            storedProgress = localStorage.getItem('progress') || JSON.stringify({});
        // Just grab the cross-storage instance here so nothing changes.
        if (Kano.MakeApps.SharedStorage){
            sharedStorage = Kano.MakeApps.SharedStorage._client
        }
        if (!sharedStorage){
            throw new Error("Failed to initiate shared storage client.");
        }
        const LOAD_DEBOUNCE_DELAY = 3000;

        localStorage.setItem('progress', storedProgress);

        function formatProgressGroup(group) {
            group = group || {};
            group.storyNo = group.storyNo || 0;
            group.extensions = group.extensions || [];
            group.completedStories = group.completedStories || [];
            return group;
        }

        Progress = {

            reset () {
                progress = {};
                this.saveToStorage();
            },

            updateProgress (group, storyNo, extension, storyId=null) {
                let progressGroup;

                this.loadFromStorage();
                progressGroup = formatProgressGroup(progress[group]);
                if (extension && progressGroup.extensions.indexOf(extension) === -1) {
                    progressGroup.extensions.push(extension);
                }

                progressGroup.storyNo = storyNo;

                progress[group] = progressGroup;
                if (storyId) {
                    progress[group].completedStories = progress[group].completedStories || [];
                    if (progress[group].completedStories.indexOf(storyId) === -1) {
                        progress[group].completedStories.push(storyId);
                    }
                }

                this.saveToStorage();

                return this.saveToRemote();
            },

            saveToRemote () {
                let p = Promise.resolve(progress);
                // If the user is authenticated, we can proceed, otherwise the saved progress will be resolved
                if (Kano.MakeApps.sdk.auth.getToken()) {
                    p = new Promise((resolve, reject) => {
                        // Update the values
                        Kano.MakeApps.sdk.appStorage.set('make-apps', { progress }, (err, data) => {
                            if (err) {
                                return reject(err);
                            }
                            resolve(data.stats['make-apps'].progress);
                        });
                    }).catch(() => {
                        // Whatever happens, return the current value
                        return progress;
                    });
                }
                return p;
            },

            loadProgress () {
                let p;
                // Load values from local storage
                this.loadFromStorage();
                p = Promise.resolve(progress);

                // Sync if the user is logged
                if (Kano.MakeApps.sdk.auth.getUser()) {
                    return this.sync();
                }
                return p;
            },
            sync () {
                let p = Promise.resolve(progress),
                    loadFromRemote = new Promise((resolve, reject) => {
                        let needUpdate = false;
                        Kano.MakeApps.sdk.appStorage.get('make-apps', (err, data) => {
                            let keys;
                            // Silent error
                            if (err) {
                                return reject(err);
                            }
                            keys = Object.keys(progress);
                            data.progress = data.progress || {};

                            // Add missing groups from remote
                            Object.keys(data.progress).forEach((key) => {
                                if (keys.indexOf(key) === -1) {
                                    keys.push(key);
                                }
                            });
                            keys.forEach((group) => {
                                let prGroup = progress[group],
                                    remoteGroup = data.progress[group];

                                // The local data is more advanced than the remote one. We keep the local data and raise the `needUpdate` flag
                                // this might create problems if we have different users on the same device though
                                if (!prGroup && remoteGroup) {
                                    progress[group] = remoteGroup;
                                } else if (!remoteGroup ||
                                        (prGroup.storyNo > remoteGroup.storyNo || prGroup.extensions.length > remoteGroup.extensions.length)) {
                                    needUpdate = true;
                                } else {
                                    progress[group] = remoteGroup;
                                }
                            });
                            if (needUpdate) {
                                return this.saveToRemote();
                            } else {
                                this.saveToStorage();
                                return resolve(progress);
                            }
                        });
                    });
                // First time in this session that we need the remote data. fetch and return it
                if (neverLoaded) {
                    return loadFromRemote.then((progress) => {
                        neverLoaded = false;
                        return progress;
                    });
                } else {
                    // The data is probably fresh, return the saved progress and defer the local update
                    clearTimeout(loadDebouncer);
                    loadDebouncer = setTimeout(() => {
                        loadFromRemote.then(() => {});
                    }, LOAD_DEBOUNCE_DELAY);
                }
                return p;
            },
            recordOnboarding () {
                sharedStorage.onConnect().then(function () {
                    return sharedStorage.set('onboarding', true);
                });
            },
            saveToStorage () {
                let progressString = JSON.stringify(progress);
                localStorage.setItem('progress', progressString);
                sharedStorage.onConnect().then(function () {
                    return sharedStorage.set('progress', progressString);
                });
            },
            loadFromStorage () {
                try {
                    progress = JSON.parse(localStorage.getItem('progress')) || {};
                } catch (e) {
                    progress = {};
                }

                // Format each group
                Object.keys(progress).forEach((group) => {
                    progress[group] = formatProgressGroup(progress[group]);
                });
            }
        };

        Kano.MakeApps.Progress = Kano.MakeApps.Progress || Progress;

    })(window.Kano = window.Kano || {});
</script>
