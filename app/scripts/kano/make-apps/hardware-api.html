<script src="../../../bower_components/socket.io-client/dist/socket.io.js"></script>
<script>
    (function (Kano) {

        Kano.MakeApps = Kano.MakeApps || {};

        class Device {
            constructor (options) {
                this.id = options.id;
                this.product = options.product;
                this.vendor = options.vendor;
                this.serialNumber = options.serialNumber;
            }

            update (options) {}
            tearDown () {}
        }

        class PowerUpDevice extends Device {
            constructor (options, master) {
                super(options);

                this.master = master;
                if (!(master instanceof HardwareAPI)) {
                    this.id = `${master.id}-${this.id}`;
                }

                this.emitter = new EventEmitter();
            }

            _socketOn (name, cb) {
                if (this.master.socket) {
                    this.master.socket.on(name, cb);
                }
            }

            _socketRemoveListener (name, cb) {
                if (this.master.socket) {
                    this.master.socket.removeListener(name, cb);
                }
            }

            on () {
                this.emitter.on.apply(this.emitter, arguments);
            }

            removeListener () {
                this.emitter.removeListener.apply(this.emitter, arguments);
            }

            removeAllListeners () {
                this.emitter.removeAllListeners.apply(this.emitter, arguments);
            }
        }

        class MotionSensor extends PowerUpDevice {
            constructor (options, master) {
                super(options, master);

                let tokens = this.id.split('-');

                this.number = tokens[tokens.length - 1];

                this._socketOn(`motion-sensor:${this.number}:proximity-data`, (value) => {
                    this.emitter.emit('proximity-data', value);
                });
                this._socketOn(`motion-sensor:${this.number}:gesture`, (value) => {
                    this.emitter.emit('gesture', value);
                });
            }

            setMode (mode) {
                this.master.socket.emit(`motion-sensor:${this.number}:set-mode`, {mode});
            }

            setUpdateInterval (interval) {
                this.master.socket.emit(`motion-sensor:${this.number}:set-update-interval`, {interval});
            }
        }

        class TiltSensor extends PowerUpDevice {
            constructor (options, master) {
                super(options, master);

                let tokens = this.id.split('-');

                this.number = tokens[tokens.length - 1];

                this._socketOn(`gyro-accelerometer:${this.number}:gyro-data`, (value) => {
                    this.emitter.emit('gyro-data', value);
                });
                this._socketOn(`gyro-accelerometer:${this.number}:accelerometer-data`, (value) => {
                    this.emitter.emit('accelerometer-data', value);
                });
            }
        }

        class KitDevice extends Device {
            constructor (options, hwapi) {
                super(options);

                this.hwapi = hwapi;

                this.update(options);
            }

            /**
             * A change was detected in the configuration of the Kit.
             * Update the web socket connections and update all devices
             */
            update (options) {
                this.url = options.url || null;
                this.serial = options.serial || false;
                this.devices = [];

                if (this.url || this.serial) {
                    if (this.socket) {
                        this.socket.removeAllListeners('disconnect');
                    }
                    this.serialSocket = null;
                    this.networkSocket = null;
                    this.socket = null;
                    if (this.serial) {
                        this.serialSocket = HardwareAPI.connect(this.hwapi.url);
                    }
                    if (this.url) {
                        this.networkSocket = HardwareAPI.connect(this.url);
                    }
                    this.socket = this.serial ? this.serialSocket : this.networkSocket;

                    this.updateDevices().then(() => {
                        this.socket.on('device-added', (info) => {
                            const device = HardwareAPI.instanciateDevice(info, this);
                            this.hwapi.addDevice(device);
                        });

                        this.socket.on('device-removed', (info) => {
                            let device = this.getDeviceById(info.id);
                            this.hwapi.removeDevice(device);
                        });
                    });

                    this.socket.on('disconnect', () => {});

                    // Tells the Kano Code App to enable OTG control on the Kit
                    if (this.serialSocket) {
                        this.socket.emit('serial-init');
                    }
                }
            }

            /**
             * Update the list of devices connected to this Kit.
             * Ensures the web socket connection is opened, then queries the devices.
             */
            updateDevices () {
                const socket = this.socket;
                // No socket, can't query devices
                if (socket) {
                    let ensureConnected = () => {
                        if (!socket.connected) {
                            return new Promise((resolve, reject) => {
                                socket.on('connect', () => {
                                    resolve();
                                });
                            });
                        }
                        return Promise.resolve();
                    };
                    return ensureConnected().then(() => {
                        return HardwareAPI.getTopDevices(this.networkSocket);
                    }).then(devices => {
                        this.devices = devices.map(d => {
                            return HardwareAPI.instanciateDevice(d, this);
                        });
                    });
                }
            }

            emit (name, detail) {
                if (this.socket) {
                    this.socket.emit(name, detail);
                }
            }

            on (name, cb) {
                if (this.socket) {
                    this.socket.on(name, cb);
                }
            }

            removeListener (name, cb) {
                if (this.socket) {
                    this.socket.removeListener(name, cb);
                }
            }

            removeAllListeners (name) {
                if (this.socket) {
                    this.socket.removeAllListeners(name);
                }
            }
        }

        class Lightboard extends KitDevice {
            constructor (options, hwapi) {
                super(options, hwapi);

                this.emit('lightboard:init', {
                    name: 'Make Apps'
                });
            }

            drawBitmap (bitmap) {
                this.emit('lightboard:on', { pixels: bitmap });
            }
        }

        class Camera extends KitDevice {
            constructor (options, hwapi) {
                super(options, hwapi);
            }

            takePicture () {
                return new Promise((resolve, reject) => {
                    this.socket.once('camera:takepicture', data => resolve(data.filename));
                    this.emit('camera:takepicture');
                });
            }

            getPicture (filename) {
                // Just return path to the endpoint
                return `${this.url}/takenpics/${filename}`;
            }

            lastPicture () {
                // Just return path to the endpoint
                return `${this.url}/camera/imgs/last.jpg`;
            };

        }

        /*
         * This class comes from mircoevent.js
         * https://github.com/jeromeetienne/microevent.js
         */
        class EventEmitter {
            on (event, fct) {
                this._events = this._events || {};
                this._events[event] = this._events[event] || [];
                this._events[event].push(fct);
            }

            addListener (event, fct) {
                return this.on(event, fct);
            }

            removeListener (event, fct) {
                this._events = this._events || {};
                if (event in this._events === false) {
                    return;
                }
                this._events[event].splice(this._events[event].indexOf(fct), 1);
            }

            emit (event /* , args... */) {
                this._events = this._events || {};
                if (event in this._events === false) {
                    return;
                }

                for (let i = 0; i < this._events[event].length; i++) {
                    this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
                }
            }
        }

        const productToClassMap = {
            lightboard: Lightboard,
            camera: Camera,
            'gyro-accelerometer': TiltSensor,
            'motion-sensor': MotionSensor
        };

        /**
         *  -> Has a [] of parts's models
         *  -> Receives an event when a new part is added
         *  -> Receives an event when hw changes
         *  -> Matches added parts to free devices
         *  -> Sets matched status to models to update user interface
         *  ->
         */

        // ----
        class HardwareAPI extends EventEmitter {
            constructor (config) {
                super();

                this._debouncers = {};

                if (config) {
                    this.config(config);
                }
            }

            // Returns an already opened connection if exists, otherwise creates a new one and returns it
            static connect (url) {
                if (!HardwareAPI.sockets[url]) {
                    HardwareAPI.sockets[url] = io.connect(url);
                }
                return HardwareAPI.sockets[url];
            }

            /**
             * Returns an instance of a Device from a device information.
             */
            static instanciateDevice (info, api) {
                const deviceClass = productToClassMap[info.product] || PowerUpDevice;
                return new deviceClass(info, api);
            }

            /* DO NOT CALL THIS METHOD FROM OUTSIDE THE CLASS
             * This is here purely for backwards-compatibility with old
             * exported apps.
             */
            config (config) {
                let ensureConnectionIsOpened;
                this.devices = [];
                this.url = this._getAPIUrl(config);
                this.partsToDevicesMap = {};

                this.parts = null;

                // Connect to the Kano Code App
                this.socket = HardwareAPI.connect(this.url);

                ensureConnectionIsOpened = () => {
                    if (!this.socket.connected) {
                        return new Promise((resolve, reject) => {
                            this.socket.on('connect', resolve);
                        });
                    }
                    return Promise.resolve();
                }

                // Wait until the connection is opened
                ensureConnectionIsOpened().then(() => {
                    // Initialise the devices
                    return HardwareAPI.getTopDevices(this.socket);
                }).then(devices => {

                    // Instanciate all the devices found
                    this.devices = devices.map(d => {
                        return HardwareAPI.instanciateDevice(d, this);
                    });

                    // Assign the new devices to the existing parts
                    this.reassignDevices();

                    // Update the sockets when the serial status changed
                    this.socket.on('device-serial-connected', (d) => {
                        let device = this.getDeviceById(d.id);
                        device.update(d, this);
                    });

                    this.socket.on('device-serial-disconnected', (d) => {
                        let device = this.getDeviceById(d.id);
                        // The device can be removed as soon as it looses it serial connection
                        if (device) {
                            device.update(d, this);
                        }
                    });

                    // Create and match a device when added
                    this.socket.on('device-added', (info) => {
                        const device = HardwareAPI.instanciateDevice(info, this);
                        this.addDevice(device);
                    });

                    // Unbinds and delete a device when disconnected
                    this.socket.on('device-removed', (info) => {
                        let device = this.getDeviceById(info.id);
                        this.removeDevice(device);
                    });

                });
            }

            /**
             * Ask a socket the connected devices. Times out after 2 second
             */
            static getTopDevices (socket) {
                return new Promise((resolve, reject) => {
                    let deviceUpdateCallback, timeoutId;
                    deviceUpdateCallback = (devices) => {
                        socket.removeListener('device-update', deviceUpdateCallback);
                        clearTimeout(timeoutId);
                        resolve(devices);
                    };
                    socket.on('device-update', deviceUpdateCallback);
                    timeoutId = setTimeout(() => {
                        socket.removeListener('device-update', deviceUpdateCallback);
                        throw new Error('Could not get devices over web sockets after 4 seconds');
                    }, 2000);
                    socket.emit('request-device-update');
                });
            }

            getDeviceById (id) {
                for (let i = 0; i < this.devices.length; i++) {
                    if (this.devices[i].id === id) {
                        return this.devices[i];
                    }
                }
            }

            requestDeviceUpdate () {
                this.socket.emit('request-device-update');
            }

            setParts (parts) {
                this.parts = parts;
                this.reassignDevices();
            }

            getAllDevices () {
                return this._doGetAllDevices(this.devices);
            }

            _cleanupDeviceMap () {
                let existingPartsIds = this.parts.map(part => part.id),
                    existingDevicesIds = this.devices.map(dev => dev.id);

                Object.keys(this.partsToDevicesMap).forEach((partId) => {
                    let dev = this.partsToDevicesMap[partId];

                    if (existingPartsIds.indexOf(partId) < 0 ||
                        existingDevicesIds.indexOf(dev.id) < 0) {

                        this.emit(`${partId}-mapping-changed`, {
                            detail: {
                                oldDevice: this.partsToDevicesMap[partId],
                                newDevice: null
                            }
                        });
                        delete this.partsToDevicesMap[partId];

                        let part = this._getPartById(partId);
                    }
                });
            }

            _partSupportsDevice (part, dev) {
                return part.supportedHardware &&
                       part.supportedHardware.indexOf(dev.product) >= 0;
            }

            _partIsFreeAndMatchesDevice (part, device) {
                return !this.getDeviceForPart(part.id) && this._partSupportsDevice(part, device)
            }

            /**
             * Find an available match for a device
             */
            _findFreeMatchingPartForDevice (dev) {
                const preferredPart = HardwareAPI.bindingHistory[dev.serialNumber];
                if (preferredPart && this._partIsFreeAndMatchesDevice(preferredPart, dev)) {
                    if (this.parts.indexOf(preferredPart) > -1) {
                        return preferredPart;
                    } else {
                        delete HardwareAPI.bindingHistory[dev.serialNumber];
                    }
                }
                for (let i = 0; i < this.parts.length; i++) {
                    let part = this.parts[i];

                    if (this._partIsFreeAndMatchesDevice(part, dev)) {
                        return part;
                    }
                }

                return null;
            }

            /**
             * Add and try to find an existing match for the device
             */
            addDevice (device) {
                this.devices.push(device);
                this.findOrCreatePartForDevice(device);
            }

            /**
             * Unbinds and remove a device
             */
            removeDevice (device) {
                const index = this.devices.indexOf(device);
                this.unbindPartFromDevice(device);
                device.tearDown();
                if (index !== -1) {
                    this.devices.splice(index, 1);
                }
            }

            /**
             * Try to match a device to part. Notify of a new Device creation if
             * no match was found
             */
            findOrCreatePartForDevice (device) {
                // The device is already bound, abort
                if (this.getPartForDevice(device.id)) {
                    return;
                }
                // Find a part that could be bound to this device
                let part = this._findFreeMatchingPartForDevice(device);

                if (part) {
                    // Bind the part to the device
                    this.partsToDevicesMap[part.id] = device;
                    HardwareAPI.bindingHistory[device.serialNumber] = part;
                    // Notify the change
                    this.emit(`${part.id}-mapping-changed`, {
                        detail: {
                            oldDevice: null,
                            newDevice: this.partsToDevicesMap[part.id]
                        }
                    });
                } else {
                    // Request a new part to be added
                    setTimeout(() => {
                        this.emit('new-part-request', { detail: device });
                    }, 0);
                }
            }

            /**
             * Find a part matching the device and frees it
             */
            unbindPartFromDevice (device) {
                let part = this.getPartForDevice(device.id);
                // No part was boudn to this device, abort
                if (!part) {
                    return;
                }
                // Free up the bind to the part
                delete this.partsToDevicesMap[part.id];
                // Notify the change
                this.emit(`${part.id}-mapping-changed`, {
                    detail: {
                        oldDevice: this.partsToDevicesMap[part.id],
                        newDevice: null
                    }
                });
            }

            /**
             * Wipe all the bindings between parts and devices and rematch them all
             */
            reassignDevices () {
                if (!this.parts) {
                    return;
                }
                this.debounce('reassign-devices', () => {
                    this._cleanupDeviceMap();

                    this._doGetAllDevices(this.devices).forEach((dev) => {
                        this.findOrCreatePartForDevice(dev);
                    });
                }, 100);
            }

            debounce (id, cb, delay) {
                if (this._debouncers[id]) {
                    clearTimeout(this._debouncers[id]);
                }
                this._debouncers[id] = setTimeout(cb, delay);
            }

            getPartForDevice (deviceId) {
                let partIds = Object.keys(this.partsToDevicesMap);

                for (let i = 0; i < partIds.length; i++) {
                    let partId = partIds[i],
                        dev = this.partsToDevicesMap[partId];

                    if (dev.id === deviceId) {
                        return this._getPartById(partId);
                    }
                }

                return null;
            }

            getDeviceForPart (partId) {
                return this.partsToDevicesMap[partId];
            }

            _getPartById (partId) {
                for (let i = 0; i < this.parts.length; i++) {
                    if (this.parts[i].id === partId) {
                        return this.parts[i];
                    }
                }

                return null;
            }

            _doGetAllDevices (root) {
                let result = [];

                root.forEach((device) => {
                    result.push(device);

                    if (device instanceof KitDevice) {
                        this._doGetAllDevices(device.devices).forEach((slave) => {
                            result.push(slave);
                        });
                    }
                });

                return result;
            }

            _getAPIUrl (c) {
                if (c.HOST) {
                    let url = 'http://' + c.HOST;
                    if (c.PORT) {
                        url += ':' + c.PORT;
                    }
                    return url;
                } else {
                    return c.HARDWARE_API_URL;
                }
            }
        }

        // Static pool of connections
        HardwareAPI.sockets = {};
        // Keeps a history of bindings between device serial number and part
        HardwareAPI.bindingHistory = {};

        Kano.MakeApps.HardwareAPI = HardwareAPI;

    })(window.Kano = window.Kano || {});
</script>
