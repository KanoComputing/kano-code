<link rel="import" href="../../bower_components/web-components/kano-alert/kano-alert.html">
<link rel="import" href="../../scripts/kano/make-apps/mode/mode.html">
<link rel="import" href="../../scripts/kano/make-apps/hardware-api.html">
<link rel="import" href="../../scripts/kano/make-apps/utils.html">
<link rel="import" href="../../scripts/kano/make-apps/parts/parts.html">
<link rel="import" href="../../scripts/kano/util/router.html">
<link rel="import" href="../../scripts/kano/make-apps/blockly/blockly.html">
<link rel="import" href="../../scripts/kano/app-modules/index.html">
<link rel="import" href="../../scripts/kano/make-apps/stories.html">
<link rel="import" href="../../elements/behaviors/kano-editor-view-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-sharing-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-code-ga-tracking-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-i18n-behavior.html">
<link rel="import" href="../../elements/kano-app-editor/kano-app-editor.html">
<link rel="import" href="../../elements/kano-story-scene/kano-story-scene.html">
<link rel="import" href="../../elements/kano-challenge-completed-modal/kano-challenge-completed-modal.html">
<link rel="import" href="../../bower_components/web-components/kano-reward-modal/kano-reward-modal.html">
<link rel="import" href="../../elements/kano-share-modal/kano-share-modal.html">

<link rel="import" href="../../scripts/kano/make-apps/progress.html">

<dom-module id="kano-view-story">
    <style>
        :host {
            display: block;
            position: relative;
            @apply(--layout-vertical);
        }
        :host kano-story-scene {
            @apply(--layout-flex);
        }
        paper-dialog {
            border-radius: 5px;
            overflow: hidden;
            background: transparent;
        }
        paper-dialog#share-modal kano-share-modal {
            padding: 0px;
            margin: 0px;
        }
    </style>
    <template>
        <kano-story-scene id="story-scene"
                            user="[[user]]"
                            scene="{{scene}}"
                            on-scene-done="nextScene"
                            story="[[story]]"
                            extensions="[[story.extensions]]"
                            on-extend-story="extendStory"
                            on-next-story="goToNextStory"
                            on-exit="_exit"
                            on-share="share"
                            added-parts="{{addedParts}}">
                            </kano-story-scene>
        <paper-dialog id="share-modal" opened={{shareOpened}} modal>
            <kano-share-modal id="share-modal-content"
                              on-confirm="confirmShare"
                              on-dismiss="dismissShare"
                              opened="[[shareOpened]]"
                              on-next-story="goToNextStory"
                              share-info="{{shareInfo}}"
                              world-url="[[config.WORLD_URL]]"
                              is-authenticated="[[user]]"
                              in-challenge>
                              </kano-share-modal>
        </paper-dialog>
        <kano-challenge-completed-modal id="challenge-completed"></kano-challenge-completed-modal>
        <kano-reward-modal id="reward-modal"
                           on-request-signup="_openSignup"
                           sound="/assets/audio/samples/challenge_complete.wav"></kano-reward-modal>
        <kano-alert id="leave-alert"
                    heading="[[localize('NOT_FINISHED', 'Oh oh.. not finished yet!')]]"
                    text="[[localize('LEAVE_CHALLENGE', 'Are you sure you want to leave the challenge?')]]"
                    entry-animation="from-big-animation"
                    with-backdrop>
            <button class="kano-alert-primary" on-tap="_confirmExit" dialog-confirm slot="actions">[[localize('CONFIRM', 'Confirm')]]</button>
            <button class="kano-alert-secondary" dialog-dismiss slot="actions">[[localize('CANCEL', 'Cancel')]]</button>
        </kano-alert>
    </template>
</dom-module>

<script>
    /* globals Polymer, Kano, page */
    Polymer({
        is: 'kano-view-story',
        behaviors: [
            Kano.Behaviors.ViewBehavior,
            Kano.Behaviors.SharingBehavior,
            Kano.Behaviors.Tracking.GABehavior,
            Kano.Behaviors.I18nBehavior
        ],
        properties: {
            selected: {
                type: Number,
                value: 0,
                observer: 'selectedChanged'
            },
            story: {
                type: Object,
                observer: 'selectedChanged'
            },
            addedParts: {
                type: Array
            },
            customAlert: Boolean
        },
        listeners: {
            'parts-changed': '_partsChanged',
            'opened-changed': '_onModalChanged',
            'mode-ready': '_setupHardwareParts'
        },
        observers: [
            '_setupHardwareParts(addedParts.splices)'
        ],
        ready () {
            this.hardwareAPI = new Kano.MakeApps.HardwareAPI(Kano.MakeApps.config);
            this.hardwareAPI.on('new-part-request', (e) => {
                this.fire('iron-signal', { name: 'new-part-request', data: e.detail });
            });

            this.modal = this.$['share-modal'];

            Kano.AppModules.init(Object.assign({
                hardwareAPI: this.hardwareAPI,
                restartCodeHandler: () => {
                    this.$['story-scene'].resetAppState();
                }
            }, Kano.MakeApps.config));
            Kano.MakeApps.Blockly.init(Kano.MakeApps.config);
            Kano.MakeApps.Mode.init(Kano.MakeApps.config);
        },
        attached () {
            Kano.MakeApps.Stories.getById(this.context.params.id)
                .then((story) => {
                    if (typeof story.next === 'string') {
                        return Kano.MakeApps.Stories.getById(story.next)
                            .then((nextStory) => {
                                this.set('story.next', nextStory);
                                return story;
                            })
                            .catch(() => {
                                return story;
                            });
                    }
                    return story;
                })
                .then((story) => {
                    this.story = story;
                    let trackingData = {
                        id: story.id,
                        name: story.name
                    };
                    if (story.progress && story.progress.group) {
                        trackingData.group = story.progress.group;
                    }
                    this.fire('track-challenge-event', {
                        type: 'attempt',
                        data: trackingData
                    });
                    if (story.progress) {
                        return Kano.MakeApps.Progress.loadProgress(story.progress.group);
                    }
                })
                .then((progress) => this.updateExtensions(progress));
        },
        _setupHardwareParts () {
            if (this.hardwareAPI) {
                this.hardwareAPI.setParts(this.addedParts);
            }
        },
        _partsChanged () {
            if (this.hardwareAPI) {
                this.hardwareAPI.requestDeviceUpdate();
            }
        },
        updateExtensions (progress) {
            let story = this.story,
                extensions = story.extensions,
                progressGroup = story.progress && progress[story.progress.group] || {},
                progressExtensions = progressGroup.extensions;
            if (story.extensions && progressExtensions) {
                for (let i = 0, len = extensions.length; i < len; i++) {
                    if (progressExtensions.indexOf(extensions[i].id) !== -1) {
                        this.set(`story.extensions.${i}.completed`, true);
                    }
                }
            }
        },
        isSelected (index) {
            return index === this.selected;
        },
        nextScene (e) {
            let hints = e.detail && e.detail.hints;
            this.trackUserProgress(this.story.id);
            if (this.selected < this.story.scenes.length - 1) {
                this.selected++;
            } else {
                //story completed
                let progress = this.story.progress,
                    extension = this.story.extension ? this.story.id : null;
                Kano.MakeApps.Progress.updateProgress(progress.group, progress.storyNo, extension, this.story.id)
                    .then((progress) => this.updateExtensions(progress));
                this.customAlert = false;
                this._displayUserReward(hints);
            }
        },
        _displayUserReward (hints) {
            Kano.MakeApps.Utils.onLine().then((isOnline) => {
                /* Enable/disable gamification based on internet availability */
                this._doDisplayUserReward(hints, isOnline);
            });
        },
        _doDisplayUserReward (hints, gamificationEnabled) {
            let headers = new Headers(),
                flags = Kano.MakeApps.config.getFlags(),
                fakeGamificationData,
                payload = {
                    name: 'kano-code-challenge-completed',
                    detail: {
                        id: this.story.id
                    }
                },
                trackingData = {
                    id: this.story.id,
                    name: this.story.name
                };
            if (this.story.progress && this.story.progress.group) {
                trackingData.group = this.story.progress.group;
            }
            this.fire('track-challenge-event', {
                type: 'complete',
                data: trackingData
            });
            this._triggerGamificationEngine(payload)
                .then(res => {
                    if (gamificationEnabled) {
                        this._trackRewards(res.update);
                        this.$['reward-modal'].open(res, this.user);
                        this.fire('update-user-progress', res.update);
                    } else {
                        this.$['challenge-completed'].set('hints', hints);
                        this.$['challenge-completed'].open();
                    }
                })
                .catch(res => {
                    let fakeGamificationData = {
                        'update': {
                            'levels': {
                                'progress': {
                                    'level': 1
                                },
                                'changes': {
                                    'total-xp': {
                                        'oldValue': 0,
                                        'newValue': 100
                                    },
                                    'level': {
                                        'oldValue': 1,
                                        'newValue': 2
                                    },
                                    'xp-offset': {
                                        'oldValue': 0,
                                        'newValue': 100
                                    },
                                    'next-threshold': {
                                        'oldValue': 100,
                                        'newValue': 260
                                    }
                                }
                            }
                        }
                    }
                    if (gamificationEnabled) {
                        this.$['reward-modal'].open(fakeGamificationData);
                    } else {
                        this.$['challenge-completed'].set('hints', hints);
                        this.$['challenge-completed'].open();
                    }
                });

        },
        _trackRewards (update) {
            let levelChanges = update.levels && update.levels.changes,
                badgeChanges = update['badges-basic'] && update['badges-basic'].changes,
                xpChanges = levelChanges && levelChanges['total-xp'];
            if (xpChanges) {
                this.fire('tracking-event', {
                    name: 'xp_earned',
                    data: {
                        previous_level: xpChanges.oldValue,
                        new_level: xpChanges.newValue,
                        xp_earned: xpChanges.newValue - xpChanges.oldValue,
                        leveled_up: !!levelChanges.level
                    }
                });
            }
            if (badgeChanges) {
                badgeChanges.new.forEach(badge => {
                    this.fire('tracking-event', {
                        name: 'badge_unlocked',
                        data: {
                            badge_id: badge.id,
                            badge_name: badge.title
                        }
                    });
                });
            }
        },
        selectedChanged () {
            if (!this.story) {
                return;
            }
            this.$['share-modal-content'].set('nextButtonLabel', Boolean(this.story.next) ?
                    this.localize('NEXT_CHALLENGE', 'Next Challenge') : this.localize('BACK_TO_CHALLENGES', 'Back to Challenges'));

            Kano.MakeApps.Stories.getSceneByIndex(this.story, this.selected)
                .then((scene) => {
                    this.set('scene', scene);
                    this.customAlert = true;
                });
        },
        extendStory (e) {
            let extensionId = e.detail;
            page.redirect(`/story/${extensionId}`);
        },
        goToNextStory (e) {
            let storyId;
            if (!this.story.next) {
                this.fire('exit-confirmed');
                return;
            }

            if (this.story.next) {
                window.history.pushState(null, null, `/story/${this.story}`);
                page.redirect(`/story/${this.story.next}`);
            }
        },
        _openSignup () {
            this.fire('signup');
        },
        _setUserShared () {
            this.set('user.hasSharedInSession', true);
        },
        _confirmExit () {
            this.fire('exit-confirmed');
        },
        _exit () {
            if (this.customAlert) {
                this.$['leave-alert'].open();
            } else {
                this.fire('exit-confirmed');
            }
        },
        _onModalChanged (e) {
            if (!this.story) {
                return;
            }
            //TODO Refactor this when challenge modal is implemented similarly to share-modal i.e. as child of a paper dialog
            const pathIds = Polymer.dom(e).path.map(path => path.id);

            if (pathIds.indexOf('share-modal') > -1 || pathIds.indexOf('reward-modal') > -1) {
                this.set('story.paused', e.detail.value);
            }
        }
    });
</script>
