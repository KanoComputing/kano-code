<!-- External dependencies -->
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../bower_components/web-components/kano-reward-modal/kano-reward-modal.html">
<link rel="import" href="../../bower_components/web-components/kano-alert/kano-alert.html">
<!-- App components -->
<link rel="import" href="../../elements/kano-app-challenge/kano-app-challenge.html">
<link rel="import" href="../../elements/kano-app-editor/kano-app-editor.html">
<link rel="import" href="../../elements/kano-challenge-completed-modal/kano-challenge-completed-modal.html">
<link rel="import" href="../../elements/kano-share-modal/kano-share-modal.html">
<!-- App behaviors -->
<link rel="import" href="../../elements/behaviors/kano-editor-view-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-view-drop-file-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-sharing-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-code-ga-tracking-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-editor-view-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-i18n-behavior.html">
<!-- App scripts -->
<link rel="import" href="../../scripts/kano/make-apps/blockly/blockly.html">
<link rel="import" href="../../scripts/kano/make-apps/mode/mode.html">
<link rel="import" href="../../scripts/kano/make-apps/hardware-api.html">
<link rel="import" href="../../scripts/kano/make-apps/parts/parts.html">
<link rel="import" href="../../scripts/kano/util/router.html">
<link rel="import" href="../../scripts/kano/app-modules/index.html">
<link rel="import" href="../../scripts/kano/make-apps/stories.html">
<link rel="import" href="../../scripts/kano/make-apps/progress.html">
<link rel="import" href="../../scripts/kano/make-apps/store.html">
<link rel="import" href="../../scripts/kano/make-apps/actions/app.html">
<link rel="import" href="../../scripts/kano/make-apps/utils.html">

<dom-module id="kano-view-story">
    <style>
        :host {
            @apply --layout-vertical;
            position: relative;
        }
        :host kano-app-challenge {
            @apply --layout-flex;
        }
        :host kano-app-editor {
            @apply --layout-flex;
        }
        paper-dialog {
            border-radius: 5px;
            overflow: hidden;
            background: transparent;
        }
        paper-dialog#share-modal kano-share-modal {
            padding: 0px;
            margin: 0px;
        }
        .bolt {
            background: black;
            width: 11px;
            height: 11px;
            margin: 3px 4px;
            border-radius: 2px;
            padding: 3px;
        }
        .progress {
            position: relative;
            color: white;
            background: #32393F;
            height: 22px;
            border-top: 1px solid var(--kano-app-editor-workspace-border, #22272d);
        }
        .progress .bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: #e4e6e7;
            opacity: 0.4;
            transition: transform 200ms ease-out;
        }
        .progress .bar-content {
            @apply --layout-horizontal;
            position: absolute;
        }
        .progress .story-name {
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 2px;
        }
    </style>
    <template>
        <kano-app-challenge id="challenge"
                            story="[[story]]"
                            steps="[[scene.steps]]"
                            mode-ready="[[modeReady]]"
                            step="{{currentStepIndex}}"
                            started="[[scene.started]]"
                            idle="[[story.paused]]"
                            selected-step="{{currentStep}}"
                            state="{{state}}"
                            scene-variables="{{sceneVariables}}"
                            progress="[[progress]]"
                            can-go-back="[[canGoBack]]"
                            can-go-forward="[[canGoForward]]"
                            on-scene-done="sceneCompleted"
                            on-request-next-story="_concludeStory"
                            on-save="saveApp"
                            on-exit="_exit"
                            on-save-to-storage="saveToStorage"
                            on-load="loadApp"
                            on-request-share="askEditorToShare"
                            on-undo="historyBack"
                            on-redo="historyForward">
            <kano-app-editor id="editor"
                             added-parts="{{addedParts}}"
                             parts="[[parts]]"
                             default-categories="[[categories]]"
                             slot="editor"
                             running="{{running}}"
                             code="{{code}}"
                             mode="[[mode]]"
                             on-share="_pauseAndShare">
            </kano-app-editor>
        </kano-app-challenge>
        <paper-dialog id="share-modal" opened={{shareOpened}} modal>
            <kano-share-modal id="share-modal-content"
                              on-confirm="confirmShare"
                              on-dismiss="dismissShare"
                              on-share-attempted="_setUserShared"
                              on-share-successful="_setUserShared"
                              opened="[[shareOpened]]"
                              on-next-story="goToNextStory"
                              share-info="{{shareInfo}}"
                              world-url="[[config.WORLD_URL]]"
                              is-authenticated="[[user]]"
                              in-challenge>
                              </kano-share-modal>
        </paper-dialog>
        <kano-challenge-completed-modal id="challenge-completed"></kano-challenge-completed-modal>
        <kano-reward-modal id="reward-modal"
                           on-request-signup="_openSignup"
                           sound="/assets/audio/samples/challenge_complete.wav"></kano-reward-modal>
        <kano-alert id="leave-alert"
                    heading="[[localize('NOT_FINISHED', 'Oh oh.. not finished yet!')]]"
                    text="[[localize('LEAVE_CHALLENGE', 'Are you sure you want to leave the challenge?')]]"
                    entry-animation="from-big-animation"
                    with-backdrop>
            <button class="kano-alert-primary" on-tap="_confirmExit" dialog-confirm slot="actions">[[localize('CONFIRM', 'Confirm')]]</button>
            <button class="kano-alert-secondary" dialog-dismiss slot="actions">[[localize('CANCEL', 'Cancel')]]</button>
        </kano-alert>
        <kano-alert id="load-app-alert"
            heading="[[localize('NOT_FINISHED', 'Oh oh.. not finished yet!')]]"
            text="[[localize('LEAVE_CHALLENGE', 'Are you sure you want to leave the challenge?')]]"
            entry-animation="from-big-animation"
            opened="[[loadingApp]]"
            with-backdrop>
            <button class="kano-alert-primary" on-tap="_confirmLoadApp" dialog-confirm slot="actions">[[localize('CONFIRM', 'Load app')]]</button>
            <button class="kano-alert-secondary" dialog-dismiss slot="actions">[[localize('CANCEL', 'Cancel')]]</button>
        </kano-alert>
    </template>
</dom-module>

<script>

    Polymer({
        is: 'kano-view-story',
        behaviors: [
            Kano.Behaviors.ViewBehavior,
            Kano.Behaviors.EditorViewBehavior,
            Kano.Behaviors.SharingBehavior,
            Kano.Behaviors.KanoCode.GABehavior,
            Kano.Behaviors.ViewDropFileBehavior,
            Kano.Behaviors.I18nBehavior,
            Kano.MakeApps.Store.ReceiverBehavior,
            Kano.Behaviors.SoundPlayerBehavior
        ],
        properties: {
            selected: {
                type: Number,
                value: 0,
                observer: 'selectedChanged'
            },
            store: {
                type: Object,
                value: () => {
                    return {};
                }
            },
            story: {
                type: Object,
                observer: 'selectedChanged'
            },
            scene: {
                type: Object,
                observer: '_loadVariables'
            },
            currentStepIndex: {
                type: Number,
                notify: true,
                observer: '_currentStepIndexChanged'
            },
            currentStep: {
                type: Object
            },
            bannerButtonInactive: {
                type: Boolean,
                value: false
            },
            mode: {
                type: Object
            },
            addedParts: {
                type: Array
            },
            sceneVariables: {
                type: Object,
                computed: '_computeSceneVariables(categories)'
            },
            remix: {
                type: Boolean,
                value: false,
                observer: '_remixChanged'
            },
            code: Object,
            customAlert: Boolean,
            loadingApp: {
                type: Object,
                linkState: 'story.loadingApp'
            },
            editorApp: {
                type: Object,
                linkState: 'editor.app',
                observer: '_editorAppChanged'
            },
            progress: {
                type: Number,
                computed: 'computeProgress(currentStepIndex, scene)'
            },
            history: {
                type: Object,
                value: () => {
                    return {
                        backBuffer: [],
                        forwardBuffer: [],
                        ignoreNextStepChange: false
                    };
                }
            },
            canGoBack: {
                type: Boolean,
                computed: '_computeCanGoBack(history.backBuffer.splices)'
            },
            canGoForward: {
                type: Boolean,
                computed: '_computeCanGoForward(history.forwardBuffer.splices)'
            },
            state: {
                type: Object,
                value: () => {
                    return {
                        hints: {
                            enabled: true
                        }
                    };
                }
            }
        },
        listeners: {
            'parts-changed': '_partsChanged',
            'opened-changed': '_onModalChanged',
            'mode-ready': '_setupHardwareParts'
        },
        observers: [
            '_setupHardwareParts(addedParts.splices)',
            '_completedChanged(scene.completed)',
            '_addedPartsChanged(addedParts.splices)'
        ],
        ready () {
            this.hardwareAPI = new Kano.MakeApps.HardwareAPI(Kano.MakeApps.config);
            this.hardwareAPI.on('new-part-request', (e) => {
                this.fire('iron-signal', { name: 'new-part-request', data: e.detail });
            });

            Kano.AppModules.init(Object.assign({
                hardwareAPI: this.hardwareAPI,
                restartCodeHandler: () => {
                    this.resetAppState();
                }
            }, Kano.MakeApps.config));
            Kano.MakeApps.Blockly.init(Kano.MakeApps.config);
            Kano.MakeApps.Mode.init(Kano.MakeApps.config);

            this.modal = this.$['share-modal'];
            this.editor = this.$.editor;
            this.debounce('saveApp', () => {
                this.editor.addEventListener('change', (e) => {
                    this.saveApp(e);
                });
            }, 300);
        },
        attached () {
            Kano.MakeApps.Stories.getById(this.context.params.id)
                .then((story) => {
                    if (typeof story.next === 'string') {
                        return Kano.MakeApps.Stories.getById(story.next)
                            .then((nextStory) => {
                                this.set('story.next', nextStory);
                                return story;
                            })
                            .catch(() => {
                                return story;
                            });
                    }
                    return story;
                })
                .then((story) => {
                    this.story = story;
                    let trackingData = {
                        id: story.id,
                        name: story.name
                    };
                    if (story.progress && story.progress.group) {
                        trackingData.group = story.progress.group;
                    }
                    this.fire('track-challenge-event', {
                        type: 'attempt',
                        data: trackingData
                    });
                    if (story.progress) {
                        return Kano.MakeApps.Progress.loadProgress(story.progress.group);
                    }
                })
        },
        selectedChanged () {
            if (!this.story) {
                return;
            }
            this.$['share-modal-content'].set('nextButtonLabel', Boolean(this.story.next) ?
                    this.localize('NEXT_CHALLENGE', 'Next Challenge') : this.localize('BACK_TO_CHALLENGES', 'Back to Challenges'));

            Kano.MakeApps.Stories.getSceneByIndex(this.story, this.selected)
                .then((scene) => {
                    // FIXME This merging of scene and scene data will not be necessary once we restructure the challenge files
                    this.set('scene', Object.assign(scene, scene.data));
                    this.set('scene.started', true);
                    this.customAlert = true;
                    this.mode = Kano.MakeApps.Mode.modes[(this.scene.mode || 'normal')];
                });
        },
        _editorAppChanged () {
            if (!this.editorApp) {
                return;
            }
            // TODO replace this when routing is based on flow-down
            page.redirect('/');
        },
        _onModeReady () {
            Kano.Behaviors.EditorViewBehavior._onModeReady.apply(this, arguments);
            this._computeMode();
            this._computeCategories();
            this._computeParts();
            this._loadVariables();
            this.currentStepIndex = 0;
            this.async(() => {
                this._loadDefaultApp();
            });
        },
        _computeMode () {
            if (this.remix && this._originalModeCategories) {
                this.set('mode.categories', this._originalModeCategories);
            } else {
                const mode = this.mode;
                if (!mode) {
                    return;
                }
                // In case we filter blocks in the categories of the mode
                if (this.scene.filterBlocks) {
                    const whitelist = this.scene.filterBlocks[mode.id];
                    if (whitelist) {
                        this._originalModeCategories = Kano.MakeApps.Utils.deepCopy(this.mode.categories);
                        mode.categories.forEach((category, index) => {
                            // Filter the blocks of this category to the one whitelisted
                            category.blocks = category.blocks.filter(block => {
                                let definition = block.block(mode);
                                return whitelist.indexOf(definition.id) !== -1;
                            });
                        });
                    }
                }
                this.set('mode', mode);
            }
        },
        /**
         * Compute the categories that will be used in this challenge. Takes care of filtering the
         * categories and blocks that will not be used. Resets everything when the users enters remix mode
         */
        _computeCategories () {
            let cats = {},
                cat;
            if (this.remix) {
                cats = Kano.MakeApps.Blockly.categories;
            } else {
                cats.events = Object.assign({}, Kano.MakeApps.Blockly.categories.events);
                Object.keys(Kano.MakeApps.Blockly.categories).filter(key => {
                    return this.scene.modules.indexOf(key) >= 0;
                }).forEach(id => {
                    // Clone the object, because we might change its blocks
                    cats[id] = Object.assign({}, Kano.MakeApps.Blockly.categories[id]);
                });

                // Do not filter blocks if the list is not defined
                if (this.scene.filterBlocks) {
                    // Remove the excluded blocks from the categories
                    Object.keys(this.scene.filterBlocks).forEach(catId => {
                        cat = cats[catId];
                        if (!cat) {
                            return;
                        }
                        cat.blocks = cat.blocks.filter(block => this.scene.filterBlocks[catId].indexOf(block.id) !== -1);
                    });
                }
            }
            this.categories = cats;
        },
        _computeParts () {
            if (this.remix) {
                if (!this.mode) {
                    return;
                }

                this.parts = Kano.MakeApps.Parts.list.filter((part) => {
                    return this.mode.parts.indexOf(part.type) !== -1;
                });
            } else {
                this.parts = Kano.MakeApps.Parts.list.filter(part => this.scene.parts.indexOf(part.type) !== -1);
            }
        },
        _loadDefaultApp () {
            let editor = this.$.editor;
            if (this.scene && this.scene.defaultApp) {
                editor.load(JSON.parse(this.scene.defaultApp), Kano.MakeApps.Parts.list);
            }
        },
        _loadVariables () {
            let workspace = this.$.editor.getBlocklyWorkspace();
            if (this.scene && this.scene.variables && workspace) {
                this.scene.variables.forEach((v) => {
                    Blockly.Variables.addVariable(v, workspace);
                });
            }
        },
        _onFileDropped (contents) {
            let app;
            try {
                app = JSON.parse(contents);
                this.dispatch({ type: 'LOAD_APP_FROM_STORY', data: app });
            } catch (e) {}

        },
        _confirmLoadApp () {
            const state = this.getState();
            this.dispatch({ type: 'LOAD_EDITOR_APP', data: state.story.loadingApp });
        },
        _setupHardwareParts () {
            if (this.hardwareAPI) {
                this.hardwareAPI.setParts(this.addedParts);
            }
        },
        _partsChanged () {
            if (this.hardwareAPI) {
                this.hardwareAPI.requestDeviceUpdate();
            }
        },
        sceneCompleted (e) {
            if (this.scene.show_remix_options) {
                this.set('scene.completed', true);
            }

            if (this.scene['autoshare_disabled']) {
                this.set('scene.autoshareDisabled', true);
            }

            this.fire('ga-tracking-event', {
                event: 'worldTutorialCompleted'
            });

            this.trackUserProgress(this.story.id);
            if (this.selected < this.story.scenes.length - 1) {
                this.selected++;
            } else {
                //story completed
                let progress = this.story.progress,
                    extension = this.story.extension ? this.story.id : null;
                Kano.MakeApps.Progress.updateProgress(progress.group, progress.storyNo, extension, this.story.id);
                this.customAlert = false;
                this._displayUserReward();
            }
        },
        _completedChanged (completed) {
            if (completed) {
                this.remix = true;
                this.$.editor.generateCover().then((image) => {
                    this.appPreview = image.src;
                });
            }
        },
        goToNextStory () {
            let storyId;
            if (!this.story.next) {
                this.fire('exit-confirmed');
                return;
            }

            if (this.story.next) {
                window.history.pushState(null, null, `/story/${this.story}`);
                page.redirect(`/story/${this.story.next}`);
            }
        },
        _displayUserReward () {
            let headers = new Headers(),
                flags = Kano.MakeApps.config.getFlags(),
                fakeGamificationData,
                payload = {
                    name: 'kano-code-challenge-completed',
                    detail: {
                        id: this.story.id
                    }
                },
                trackingData = {
                    id: this.story.id,
                    name: this.story.name
                };
            if (this.story.progress && this.story.progress.group) {
                trackingData.group = this.story.progress.group;
            }
            this.fire('track-challenge-event', {
                type: 'complete',
                data: trackingData
            });
            this.bannerButtonInactive = true;
            this.$.challenge.computeBanner(this.currentStep);
            this.triggerGamificationEngine(payload)
                .then(res => {
                    this.bannerButtonInactive = false;
                    this.$.challenge.computeBanner(this.currentStep);
                    this._trackRewards(res.update);
                    this.$['reward-modal'].open(res, this.user);
                    this.fire('update-user-progress', res.update);
                });
        },
        _trackRewards (update) {
            let levelChanges = update.levels && update.levels.changes,
                badgeChanges = update['badges-basic'] && update['badges-basic'].changes,
                xpChanges = levelChanges && levelChanges['total-xp'];
            if (xpChanges) {
                this.fire('tracking-event', {
                    name: 'xp_earned',
                    data: {
                        previous_level: xpChanges.oldValue,
                        new_level: xpChanges.newValue,
                        xp_earned: xpChanges.newValue - xpChanges.oldValue,
                        leveled_up: !!levelChanges.level
                    }
                });
            }
            if (badgeChanges) {
                badgeChanges.new.forEach(badge => {
                    this.fire('tracking-event', {
                        name: 'badge_unlocked',
                        data: {
                            badge_id: badge.id,
                            badge_name: badge.title
                        }
                    });
                });
            }
        },
        _openSignup () {
            this.fire('signup');
        },
        _setUserShared () {
            this.set('user.hasSharedInSession', true);
        },
        _confirmExit () {
            this.fire('exit-confirmed');
        },
        _exit () {
            if (this.customAlert) {
                this.$['leave-alert'].open();
            } else {
                this.fire('exit-confirmed');
            }
        },
        resetAppState () {
            this.$.editor.resetAppState();
        },
        _runningChanged () {
            if (!this.scene || !this.scene.started) {
                return;
            }
            Kano.Behaviors.EditorViewBehavior._runningChanged.apply(this, arguments);
        },
        loadApp (e) {
            let id = e.detail,
                savedState,
                challenge;
            savedState = this.fromStore(id);
            challenge = this.$.challenge;
            this.$.editor.load(savedState.app, this._computeParts());
            challenge.set('stepIds', savedState.stepIds);
            challenge.set('blockIds', savedState.blockIds);
        },
        saveApp (e) {
            let id = e.detail.id || 'current',
                blockIds = e.detail.blockIds,
                stepIds = e.detail.stepIds,
                app = this.$.editor.save(true, false);
            this.addToStore(id, {
                app,
                blockIds,
                stepIds
            });
        },
        shareApp () {
            this.$.editor.share();
        },
        saveToStorage () {
            let app = this.$.editor.save();
            localStorage.setItem('savedApp', JSON.stringify(app));
        },
        computeProgress (currentStepIndex, scene) {
            if (currentStepIndex < 0) {
                return 1;
            }
            return (currentStepIndex + 1) / scene.steps.length;
        },
        _currentStepIndexChanged (stepNumber) {
            let step = this.scene.steps[stepNumber];
            if (this.history.ignoreNextStepChange) {
                this.set('history.ignoreNextStepChange', false);
            } else {
                if (this._isStepSafeToSaveInHistory(step)) {
                    this.debounce('save-history', () => {
                        this.saveHistory();
                    }, 400);
                }
            }
        },
        _computeSceneVariables (categories) {
            let sceneVariables = {};
            Object.keys(categories).forEach((key) => {
                sceneVariables[`${key}_color`] = categories[key].colour;
            });
            return sceneVariables;
        },
        showHints () {
            this.set('banner', null);
            this.computeBanner(this.currentStep);
            this.set('state.hints', { enabled: true });
        },
        _concludeStory () {
            // Go to next story or share automatically
            Kano.MakeApps.Utils.onLine().then((isOnline) => {
                if (!this.user || this.user.hasSharedInSession || this._userAlreadyShared(this.story) ||
                        this.scene.autoshareDisabled || !isOnline) {
                    this.goToNextStory();
                } else {
                    const detail = this.$.editor.compileApp();
                    detail.title = this.story.name;
                    detail.autoshare = true;
                    this.scene.autoshareDisabled = true;
                    this.running = false;
                    this.share({ detail });
                }
            });
        },
        _userAlreadyShared (story) {
            const progress = this._getUserProgress(this.user);
            return progress.indexOf(story.id) > -1;
        },
        _getUserProgress (user) {
            let groups = this._getProgressGroups(user),
                stories = [];
            if (groups) {
                Object.keys(groups).forEach(key => {
                    stories = stories.concat(groups[key].completedStories);
                });
            }
            return stories;
        },
        _getProgressGroups (user) {
            return user && user.profile && user.profile.stats['make-apps'] &&
                    user.profile.stats['make-apps'].progress || null;
        },
        _pauseAndShare (e) {
            this.running = false;
            this.share(e);
            e.preventDefault();
            e.stopPropagation();
        },
        _remixChanged (remix) {
            if (remix) {
                this._computeMode();
                this._computeCategories();
                this._computeParts();
                // Look for the previously removed blocks in the addedParts
                this.addedParts.forEach((part, i) => {
                    // Some blocks were removed, we need to add them back
                    if (part.removedBlocks) {
                        // Go through all the removed blocks and inject them back in the blocks array
                        Object.keys(part.removedBlocks).forEach(index => {
                            this.splice(`addedParts.${i}.blocks`, index, 0, part.removedBlocks[index]);
                        });
                        delete part.removedBlocks;
                    }
                });
            }
        },
        /**
         * Observes the `addedParts` array. Goes through the added splice and removes the blocks from a part if needed.
         * Stores the removed blocks in a `removedBlocks` object for future re-injection
         */
        _addedPartsChanged (e) {
            if (!e || this.remix || !this.scene.filterBlocks) {
                return;
            }
            e.indexSplices.forEach(splice => {
                splice.object.forEach(part => {
                    Object.keys(this.scene.filterBlocks).forEach(key => {
                        if (part.id !== key) {
                            return;
                        }
                        part.blocks = part.blocks.filter((block, index) => {
                            let id, definition, remove;
                            if (typeof block === 'string') {
                                id = block;
                            } else {
                                definition = block.block(part);
                                id = definition.id
                            }
                            remove = this.scene.filterBlocks[key].indexOf(id) === -1;
                            // We're about to remove the block from the part. Save it under another object to
                            // be able to inject it back later
                            if (remove) {
                                part.removedBlocks = part.removedBlocks || {};
                                part.removedBlocks[index] = block;
                            }
                            return !remove;
                        });
                    });
                });
            });
        },
        _onModalChanged (e) {
            if (!this.story) {
                return;
            }
            //TODO Refactor this when challenge modal is implemented similarly to share-modal i.e. as child of a paper dialog
            const pathIds = Polymer.dom(e).path.map(path => path.id);

            if (pathIds.indexOf('share-modal') > -1 || pathIds.indexOf('reward-modal') > -1) {
                this.set('story.paused', e.detail.value);
            }
        },
        saveHistory () {
            let step = this.currentStepIndex;

            this.push('history.backBuffer', {
                stepNumber: step,
                editorState: Kano.MakeApps.Utils.deepCopy(this.$.editor.save())
            });
            this.history.forwardBuffer.length = 0;
        },
        historyBack () {
            if (this.canGoBack) {
                let currentState = this.pop('history.backBuffer'),
                    history = this.history.backBuffer[this.history.backBuffer.length - 1];
                this.push('history.forwardBuffer', currentState);
                Kano.MakeApps.Parts.clear();
                this.$.editor.load(history.editorState, Kano.MakeApps.Parts.list);
                this.set('history.ignoreNextStepChange', true);
                this.set('currentStepIndex', history.stepNumber);
            }
        },
        historyForward () {
            if (this.canGoForward) {
                let history = this.pop('history.forwardBuffer');
                this.push('history.backBuffer', history);
                Kano.MakeApps.Parts.clear();
                this.$.editor.load(history.editorState, Kano.MakeApps.Parts.list);
                this.set('history.ignoreNextStepChange', true);
                this.set('currentStepIndex', history.stepNumber);
            }
        },
        _computeCanGoBack () {
            return this.history.backBuffer && this.history.backBuffer.length > 1;
        },
        _computeCanGoForward () {
            return this.history.forwardBuffer && this.history.forwardBuffer.length > 0;
        },
        _isStepSafeToSaveInHistory(step) {
            if (step.validation) {
                if (step.validation.blockly) {
                    let b = step.validation.blockly;

                    if (b['open-flyout'] || b.value) {
                        return true;
                    }
                }

                if (step.validation['open-parts']) {
                    return true;
                }
            }

            if (step.banner && step.banner['open-parts']) {
                return true;
            }

            return step.isLast;
        },
        addToStore (id, data) {
            this.store[id] = data;
        },
        fromStore (id) {
            return this.store[id];
        },
        askEditorToShare () {
            this.editor.share();
        }
    });
</script>
