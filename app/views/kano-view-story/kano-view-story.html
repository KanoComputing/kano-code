<link rel="import" href="../../bower_components/web-components/kano-sound-player-behavior/kano-sound-player-behavior.html">
<link rel="import" href="../../scripts/kano/make-apps/mode/mode.html">
<link rel="import" href="../../scripts/kano/make-apps/hardware-api.html">
<link rel="import" href="../../scripts/kano/make-apps/utils.html">
<link rel="import" href="../../scripts/kano/make-apps/parts/parts.html">
<link rel="import" href="../../scripts/kano/util/router.html">
<link rel="import" href="../../scripts/kano/make-apps/blockly/blockly.html">
<link rel="import" href="../../scripts/kano/app-modules/index.html">
<link rel="import" href="../../scripts/kano/make-apps/stories.html">
<link rel="import" href="../../elements/behaviors/kano-editor-view-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-sharing-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-code-ga-tracking-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-i18n-behavior.html">
<link rel="import" href="../../elements/kano-app-editor/kano-app-editor.html">
<link rel="import" href="../../elements/kano-story-scene/kano-story-scene.html">
<link rel="import" href="../../elements/kano-challenge-completed-modal/kano-challenge-completed-modal.html">
<link rel="import" href="../../elements/kano-reward-modal/kano-reward-modal.html">
<link rel="import" href="../../elements/kano-share-modal/kano-share-modal.html">

<link rel="import" href="../../scripts/kano/make-apps/progress.html">

<dom-module id="kano-view-story">
    <style>
        :host {
            display: block;
            position: relative;
            @apply(--layout-vertical);
        }
        :host kano-story-scene {
            @apply(--layout-flex);
        }
        paper-dialog {
            border-radius: 5px;
            overflow: hidden;
            background: transparent;
        }
        paper-dialog#share-modal kano-share-modal {
            padding: 0px;
            margin: 0px;
        }
    </style>
    <template>
        <kano-story-scene id="story-scene"
                            user="[[user]]"
                            scene="{{scene}}"
                            on-scene-done="nextScene"
                            story="[[story]]"
                            extensions="[[story.extensions]]"
                            on-extend-story="extendStory"
                            on-next-story="goToNextStory"
                            on-share="share"
                            added-parts="{{addedParts}}"></kano-story-scene>
        <paper-dialog id="share-modal" no-cancel-on-esc-key no-cancel-on-outside-click with-backdrop>
            <kano-share-modal id="share-modal-content"
                              on-confirm="confirmShare"
                              on-dismiss="dismissShare"
                              on-next-story="goToNextStory"
                              share-info="{{shareInfo}}"
                              world-url="[[config.WORLD_URL]]"
                              is-authenticated="[[user]]"
                              in-challenge></kano-share-modal>
       </paper-dialog>
       <kano-challenge-completed-modal id="challenge-completed"
                                       on-close="_setStoryEnded"></kano-challenge-completed-modal>
        <kano-reward-modal id="reward-modal"
                       on-confirm="_setStoryEnded"
                       on-second-action="_openSignup"
                       on-close="_setStoryEnded"></kano-reward-modal>
    </template>
</dom-module>

<script>
    /* globals Polymer, Kano, page */
    Polymer({
        is: 'kano-view-story',
        behaviors: [
            Kano.Behaviors.ViewBehavior,
            Kano.Behaviors.SharingBehavior,
            Kano.Behaviors.Tracking.GABehavior,
            Kano.Behaviors.SoundPlayerBehavior,
            Kano.Behaviors.I18nBehavior
        ],
        properties: {
            selected: {
                type: Number,
                value: 0,
                observer: 'selectedChanged'
            },
            story: {
                type: Object,
                observer: 'selectedChanged'
            },
            addedParts: {
<<<<<<< Updated upstream
                type: Array
=======
                type: Array,
                observer: '_addedPartsChanged'
            },
            isChallenge: {
                type: Boolean,
                value: true
>>>>>>> Stashed changes
            }
        },
        listeners: {
            'parts-changed': '_partsChanged'
        },
        observers: [
            '_addedPartsChanged(addedParts.splices)'
        ],
        ready () {
            Kano.MakeApps.config.HOST = Kano.Util.Router.parseQsParam(this.context.querystring, 'host') || Kano.MakeApps.config.HOST;
            Kano.MakeApps.config.PORT = Kano.Util.Router.parseQsParam(this.context.querystring, 'port') || Kano.MakeApps.config.PORT;

            this.hardwareAPI = new Kano.MakeApps.HardwareAPI(Kano.MakeApps.config);
            this.hardwareAPI.on('new-part-request', (e) => {
                this.fire('iron-signal', { name: 'new-part-request', data: e.detail });
            });

            this.modal = this.$['share-modal'];

            Kano.AppModules.init(Object.assign({ hardwareAPI: this.hardwareAPI }, Kano.MakeApps.config));
            Kano.MakeApps.Blockly.init(Kano.MakeApps.config);
            Kano.MakeApps.Mode.init(Kano.MakeApps.config);
            Kano.MakeApps.config.PROJECTS_URL = Kano.Util.Router.parseQsParam(this.context.querystring, 'projectsUrl') || Kano.MakeApps.config.PROJECTS_URL;
        },
        attached () {
            Kano.MakeApps.Stories.getById(this.context.params.id)
                .then((story) => {
                    if (typeof story.next === 'string') {
                        return Kano.MakeApps.Stories.getById(story.next)
                            .then((nextStory) => {
                                this.set('story.next', nextStory);
                                return story;
                            })
                            .catch(() => {
                                return story;
                            });
                    }
                    return story;
                })
                .then((story) => {
                    this.story = story;
                    let trackingData = {
                        id: story.id,
                        name: story.name
                    };
                    if (story.progress && story.progress.group) {
                        trackingData.group = story.progress.group;
                    }
                    this.fire('track-challenge-event', {
                        type: 'attempt',
                        data: trackingData
                    });
                    if (story.progress) {
                        return Kano.MakeApps.Progress.loadProgress(story.progress.group);
                    }
                })
                .then((progress) => this.updateExtensions(progress));
        },
        _addedPartsChanged () {
            if (this.hardwareAPI) {
                this.hardwareAPI.setParts(this.addedParts);
            }
        },
        _partsChanged () {
            if (this.hardwareAPI) {
                this.hardwareAPI.requestDeviceUpdate();
            }
        },
        updateExtensions (progress) {
            let story = this.story,
                extensions = story.extensions,
                progressGroup = story.progress && progress[story.progress.group] || {},
                progressExtensions = progressGroup.extensions;
            if (story.extensions && progressExtensions) {
                for (let i = 0, len = extensions.length; i < len; i++) {
                    if (progressExtensions.indexOf(extensions[i].id) !== -1) {
                        this.set(`story.extensions.${i}.completed`, true);
                    }
                }
            }
        },
        isSelected (index) {
            return index === this.selected;
        },
        nextScene (e) {
            let hints = e.detail && e.detail.hints;
            this.trackUserProgress(this.story.id);
            if (this.selected < this.story.scenes.length - 1) {
                this.selected++;
            } else {
                //story completed
                let progress = this.story.progress,
                    extension = this.story.extension ? this.story.id : null;
                Kano.MakeApps.Progress.updateProgress(progress.group, progress.storyNo, extension, this.story.id)
                    .then((progress) => this.updateExtensions(progress));
                this._displayUserReward(hints);
            }
        },
        _displayUserReward (hints) {
            let flags = Kano.MakeApps.config.getFlags(),
                //FIXME for demo we turn the gamification enabled always true on this branch
                gamificationEnabled = true || flags.experiments.indexOf('gamification_modal') !== -1,
                payload = {
                    name: 'kano-code-challenge-completed',
                    detail: {
                        id: this.story.id
                    }
                },
                trackingData = {
                    id: this.story.id,
                    name: this.story.name
                };
            if (this.story.progress && this.story.progress.group) {
                trackingData.group = this.story.progress.group;
            }
            this.fire('track-challenge-event', {
                type: 'complete',
                data: trackingData
            });
            this._triggerGamificationEngine(payload)
                .then(res => {
                    if (gamificationEnabled) {
                        this._trackRewards(res.update);
                        this.$['reward-modal'].open(res, this.user);
                        this.fire('update-user-progress', res.update);
                    } else {
                        this.$['challenge-completed'].set('hints', hints);
                        this.$['challenge-completed'].open();
                    }
                    this.playSound('/assets/audio/samples/challenge_complete.wav');
                })
                .catch(res => {
                    let fakeGamificationData = {
                        "update": {
                            "levels": {
                                "progress": {
                                    "level": 1
                                },
                                "changes": {
                                    "total-xp": {
                                        "oldValue": 0,
                                        "newValue": 100
                                    },
                                    "level": {
                                        "oldValue": 1,
                                        "newValue": 2
                                    },
                                    "xp-offset": {
                                        "oldValue": 0,
                                        "newValue": 100
                                    },
                                    "next-threshold": {
                                        "oldValue": 100,
                                        "newValue": 260
                                    }
                                }
                            }
                        }
                    }
                    if (gamificationEnabled) {
                        this.$['reward-modal'].open(fakeGamificationData);
                    } else {
                        this.$['challenge-completed'].set('hints', hints);
                        this.$['challenge-completed'].open();
                    }
                    this.playSound('/assets/audio/samples/challenge_complete.wav');
                });

        },
        _trackRewards (update) {
            let levelChanges = update.levels && update.levels.changes,
                badgeChanges = update['badges-basic'] && update['badges-basic'].changes,
                xpChanges = levelChanges && levelChanges['total-xp'];
            if (xpChanges) {
                this.fire('tracking-event', {
                    name: 'xp_earned',
                    data: {
                        previous_level: xpChanges.oldValue,
                        new_level: xpChanges.newValue,
                        xp_earned: xpChanges.newValue - xpChanges.oldValue,
                        leveled_up: !!levelChanges.level
                    }
                });
            }
            if (badgeChanges) {
                badgeChanges.new.forEach(badge => {
                    this.fire('tracking-event', {
                        name: 'badge_unlocked',
                        data: {
                            badge_id: badge.id,
                            badge_name: badge.title
                        }
                    });
                });
            }
        },
        selectedChanged () {
            if (!this.story) {
                return;
            }
            this.$['share-modal-content'].set('nextButtonLabel', Boolean(this.story.next) ?
                    this.localize('NEXT_CHALLENGE', 'Next Challenge') : this.localize('BACK_TO_CHALLENGES', 'Back to Challenges'));

            Kano.MakeApps.Stories.getSceneByIndex(this.story, this.selected)
                .then((scene) => {
                    this.set('scene', scene);
                    this.set('scene.modeConfig', {
                        HOST: Kano.Util.Router.parseQsParam(this.context.querystring, 'host'),
                        PORT: Kano.Util.Router.parseQsParam(this.context.querystring, 'port')
                    });
                    this.set('scene.ended', false);
                });
        },
        extendStory (e) {
            let extensionId = e.detail;
            page.redirect(`/story/${extensionId}`);
        },
        goToNextStory (e) {
            let storyId;
            if (!this.story.next) {
                location.href = Kano.MakeApps.config.PROJECTS_URL;
                return;
            }

            if (this.story.next) {
                page.redirect(`/story/${this.story.next}`);
            }
        },
        _setStoryEnded () {
            this.set('scene.ended', true);
        },
        _openSignup () {
            let detail = {
                onSuccess: this._setStoryEnded.bind(this),
                onCancel: this._setStoryEnded.bind(this)
            };
            this.fire('signup', detail);
        }
    });
</script>
