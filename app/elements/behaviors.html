<script type="text/javascript">

    /* globals app, Blockly */

    window.KanoBehaviors = window.KanoBehaviors || {};

    window.KanoBehaviors.SharingBehavior = {

        properties: {
            shareInfo: {
                type: Object,
                value: function () {
                    return {};
                },
                notify: true
            }
        },

        shareApp () {
            // Generates the standalone component
            let savedApp = app.components.generateStandaloneComponent(
                    this.shareInfo.parts,
                    this.shareInfo.background,
                    this.shareInfo.size,
                    this.shareInfo.code
                ),
                attachment = new Blob([savedApp], { type: 'text/html' }),
                cover = app.file_utils.dataURItoBlob(this.shareInfo.image.src),
                workspaceInfo = new Blob([this.shareInfo.workspaceInfo], { type: 'application/json' });

            attachment.filename = 'code.html';
            cover.filename = 'cover.png';
            workspaceInfo.filename = 'workspace_info.json';

            //Share by calling the API
            app.sdk.api.share.post({
                app: 'make-apps',
                title: this.shareInfo.title,
                description: this.shareInfo.description,
                files: {
                    attachment: attachment,
                    cover: cover,
                    workspace_info: workspaceInfo
                }
            }).then((res) => {
                if (res.status == 200) {
                    this.set('shareInfo.page', 2);
                    this.set('shareInfo.id', res.body.item.id);
                } else {
                    this.set('shareInfo.page', 3);
                }
            });
        },
        /**
         * Opens the sharing modal and share the app
         */
        share (e) {
            let shareInfo = {
                    image: e.detail.cover,
                    workspaceInfo: e.detail.workspaceInfo,
                    page: 0,
                    title: '',
                    description: '',
                    id: null,
                    background: e.detail.background,
                    parts: e.detail.parts,
                    code: e.detail.code,
                    size: e.detail.size,
                };

            this.set('shareInfo', shareInfo);
            this.modal.open();
        },

        confirmShare () {
            this.set('shareInfo.page', 1);
            this.shareApp();
        },

        dismissShare () {
            this.modal.close();
        }

    };

    window.KanoBehaviors.SceneComponentBehavior = {

        properties: {
            scene: Object,
            store: {
                type: Object,
                notify: true
            },
            storyName: {
                type: String
            },
            nextStory: {
                type: String
            }
        },

        finish () {
            this.fire('scene-done');
        },

        addToStore (id, data) {
            this.store[id] = data;
        },

        fromStore (id) {
            return this.store[id];
        }

    };

    window.KanoBehaviors.CodeEditorBehavior = {
        properties: {
            code: {
                type: String,
                notify: true
            }
        },
        show () {

        },
        hide () {

        },
        save () {
            return Promise.resolve();
        },
        load () {

        }
    };

    window.KanoBehaviors.AppEditorBehavior = {
        notifyChange (type, data={}) {
            data.type = type;
            this.fire('change', data);
        }
    };

    window.KanoBehaviors.PartEditorBehavior = {
        properties: {
            selected: {
                type: Object,
                notify: true
            },
            data: {
                type: Object,
                notify: true
            }
        }
    };

    window.KanoBehaviors.ValidatorBehavior = {
        properties: {
            step: {
                type: Number,
                value: 0
            },
            steps: {
                type: Array,
                value: () => []
            },
            instruction: {
                type: String,
                computed: 'computeInstruction(step, steps.*, done)',
                readOnly: true
            },
            done: {
                type: Boolean,
                value: false
            },
            stepIds: {
                type: Object,
                value: () => {
                    return {};
                }
            }
        },
        /**
         * Get the instruction to display
         */
        computeInstruction () {
            if (!this.steps[this.step]) {
                return;
            }
            return this.done ? 'Done' : this.steps[this.step].instruction;
        },
        /**
         * Move to the next step or set the challenge as done
         */
        nextStep () {
            if (this.step < this.steps.length - 1) {
                this.step++;
            } else {
                this.set('done', true);
                this.fire('scene-done');
            }
        }
    };

    window.KanoBehaviors.BlocklyValidatorBehavior = {
        properties: {
            blockIds: {
                type: Object,
                value: () => {
                    return {};
                }
            }
        },
        attached () {
            this.eventsMap = {
                create: 'Create',
                connect: 'Move',
                value: 'Change',
                delete: 'Delete'
            };
            this.blocklyValidators = {
                'create': this.matchCreate.bind(this),
                'connect': this.matchConnect.bind(this),
                'value': this.matchBlocklyValue.bind(this),
                'delete': this.matchDelete.bind(this),
                'open_flyout': this.matchCategory.bind(this)
            };
        },
        matchCategory (validation, event) {
            if (validation.part) {
                validation = this.stepIds[validation.part];
            }
            return event.categoryId === validation;
        },
        matchBlockType (type, event) {
            return event.xml.getAttribute('type') === type;
        },
        matchBlocklyEvent (type, event) {
            return event.type === type;
        },
        getBlockType (validation) {
            let target = this.stepIds[validation.target],
                type;
            // Use the type or the value directly
            // Allows to declare shorthand creation as:
            // create: 'text'
            // or
            // create: {
            //     type: 'text'
            // }
            if (typeof validation === 'string') {
                type = validation;
            } else if (validation.type) {
                type = validation.type;
                type = target ? `${target}#${type}` : type;
            }
            return type;
        },
        matchDelete (validation, event) {
            let target = validation.target || validation,
                blockId = this.blockIds[target];
            if (blockId !== event.blockId) {
                return;
            }
            delete this.blockIds[target];
            return true;
        },
        matchCreate (validation, event) {
            let type = this.getBlockType(validation);
            // Check the type of the added block
            if (this.matchBlockType(type, event)) {
                // The new block created is added to the step, using its
                // step id for further reference
                if (validation.id) {
                    this.blockIds[validation.id] = event.blockId;
                }
                return true;
            }
        },
        matchConnect (validation, event) {
            // Extract the validation object, target and parent step ids and
            // the block moved
            let targetId = this.blockIds[validation.target],
                parentId = this.blockIds[validation.parent];
            // Check that the element moved is the one targeted and that its
            // new parent is the right one
            if (event.blockId === targetId && event.newParentId === parentId) {
                return true;
            }
        },
        matchBlocklyValue (validation, event) {
            let targetId = this.blockIds[validation.target],
                block = event,
                failed = false;
            // Check that the element that changed is the one we target
            if (block.blockId === targetId) {
                if (validation.minLength &&
                        block.newValue.length &&
                        block.newValue.length < validation.minLength) {
                    failed = true;
                }
                // Check that
                // the value is set to the one we expect
                // We use the double equal to be sure we catch Number/String
                // parsing
                if (validation.value && block.newValue != validation.value) {
                    failed = true;
                }
                return !failed;
            }
        },
        handleBlocklyChange (step, e) {
            // Store current step object
            Object.keys(step).forEach((type) => {
                let validation;
                if (!this.matchBlocklyEvent(type, e)) {
                    return;
                }
                validation = step[type];
                if (validation === true) {
                    return this.nextStep();
                }
                if (typeof this.blocklyValidators[type] === 'function' &&
                        this.blocklyValidators[type](validation, e)) {
                    this.nextStep();
                }
            });
        }
    };

    window.KanoBehaviors.AnimatableBehavior = {
        properties: {
            noAnimations: {
                type: Boolean,
                value: false,
                observer: 'noAnimationsChanged'
            }
        },
        ready () {
            this.toggleClass('animatable', true);
        },
        noAnimationsChanged (noAnimations) {
            this.toggleClass('no-animations', noAnimations);
        }
    };

</script>
