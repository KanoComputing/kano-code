<link rel="import" href="../kano-light-shape-behavior.html">
<link rel="import" href="../../../bower_components/web-components/kano-style/part.html">
<link rel="import" href="../../../scripts/kano/make-apps/parts-api/light-frame.html">
<dom-module id="kano-part-light-frame">
    <style is="custom-style" include="part-style"></style>
    <style>
    :host {
        display: block;
    }
    .container {
        position: relative;
        border: 1px solid blue;
        padding: 2px;
    }
    .pixel {
        width: 21px;
        height: 21px;
        margin: 3px;
    }
    .container[running] {
        display: none;
    }
    </style>
    <template>
        <div class="container" running$="[[isRunning]]">
            <kano-bitmap-renderer width="[[model.userProperties.width]]" height="[[model.userProperties.height]]" pixel-size="21" spacing="3" bitmap="[[model.userProperties.bitmap]]"></kano-bitmap-renderer>
        </div>
    </template>
    <script type="text/javascript">
        /* globals Polymer, Kano */

        Polymer({
            is: 'kano-part-light-frame',
            behaviors: [Kano.MakeApps.PartsAPI['light-frame'], Kano.Behaviors.LightShapeBehavior],
            observers: [
                '_sizeChanged(model.userProperties.width, model.userProperties.height)',
                '_onBitmapChanged(model.userProperties.bitmap.*)'
            ],

            get bitmap () {
                return this.get('model.userProperties.bitmap');
            },

            _onBitmapChanged (e) {
                //Lock observer as it's resetting the observed property
                if (this.lock) {
                    return;
                }
                this.lock = true;
                this.async(() => this.lock = false);

                if (e.path.search(/splices/) !== -1) {
                    this._setBitmap();
                }
            },
            _setBitmap () {
                this.set('storedBitmap', this._adjustBitmapForStorage(this.model.userProperties.bitmap));
                this.set('model.userProperties.bitmap',
                    this._adjustBitmapForDisplay(this.storedBitmap));
            },
            _sizeChanged () {
                if (this.model.userProperties.bitmap.length === 0) {
                    this._generateEmptyFrame();
                    return;
                }
                this.storedBitmap = this.storedBitmap ||
                        this._adjustBitmapForStorage(this.model.userProperties.bitmap);
                this.set('model.userProperties.bitmap',
                    this._adjustBitmapForDisplay(this.storedBitmap));
            },
            _adjustBitmapForStorage (bitmap) {
                let newBitmap = [],
                    width = this.model.userProperties.width,
                    height = this.model.userProperties.height;

                for (let i = 0; i < 128; i++) {
                    newBitmap.push('#000000');
                }

                bitmap.forEach((color, i) => {
                    let x = i % width,
                        y = Math.floor(i / width),
                        storedPos = x + y * 16;
                    if (storedPos < 128) {
                        newBitmap[storedPos] = color;
                    }
                });
                return newBitmap;
            },
            _adjustBitmapForDisplay (bitmap) {
                let newBitmap = [],
                    width = this.model.userProperties.width,
                    height = this.model.userProperties.height;

                for (let i = 0; i < height * width; i++) {
                    newBitmap.push('#000000');
                }

                bitmap.forEach((color, i) => {
                    let x = i % 16,
                        y = Math.floor(i / 16),
                        realPos = x + y * width;
                    if (realPos < newBitmap.length) {
                        newBitmap[realPos] = color;
                    }
                });
                return newBitmap;
            },
            _generateEmptyFrame () {
                let emptyFrame = [];
                for (let i = 0; i < this.model.userProperties.height * this.model.userProperties.width; i++) {
                    emptyFrame.push('#000000');
                }
                this.set('model.userProperties.bitmap', emptyFrame);
            },
            detached () {
                // Firing a regular event won't do much as this is detached and the workspace will not receive it.
                // This make iron-signals dispatch the event to the interested elements
                document.dispatchEvent(new CustomEvent('iron-signal', {
                    bubbles: false,
                    detail: {
                        name: 'remove-shape',
                        data: this.model.id
                    }
                }));
            }
        });
    </script>
</dom-module>
