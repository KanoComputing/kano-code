<link rel="import" href="../kano-light-shape-behavior.html">
<dom-module id="kano-part-light-frame">
    <style>
    :host {
        display: block;
    }
    .container {
        position: relative;
        border: 1px solid blue;
    }
    .pixel {
        width: 22px;
        height: 22px;
        margin: 3px;
    }
    .canvas {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        padding: 2px;
    }
    .container[running] {
        display: none;
    }
    </style>
    <template>
        <div class="container" style$="[[_computeContainerStyle(model.userProperties.*)]]" running$="[[isRunning]]">
            <div class="canvas" style$="[[_computeCanvasStyle(model.userProperties.width)]]">
                <template is="dom-repeat" items="[[model.userProperties.bitmap]]" as="pixel" id="repeat">
                    <div class="pixel" style$="[[_computePixelStyle(pixel)]]"></div>
                </template>
            </div>
        </div>
    </template>
    <script type="text/javascript">
        /* globals Polymer, Kano */

        Polymer({
            is: 'kano-part-light-frame',
            behaviors: [Kano.Behaviors.LightShapeBehavior],
            observers: [
                '_sizeChanged(model.userProperties.width, model.userProperties.height)'
            ],
            _computeContainerStyle () {
                let width = this.model.userProperties.width * this.PIXEL_SIZE + 4,
                    height = this.model.userProperties.height * this.PIXEL_SIZE + 4;
                return `width: ${width}px; height: ${height}px;`;
            },
            _computeCanvasStyle (width) {
                return `max-width: ${width * this.PIXEL_SIZE + 4}px;`;
            },
            _computePixelStyle (pixel) {
                return `background-color: ${pixel};`;
            },
            _sizeChanged () {
                let newBitmap = [],
                    width = this.model.userProperties.width,
                    height = this.model.userProperties.height,
                    prevColor;
                for (let i = 0; i < height * width; i++) {
                    // If prevSize is not set, we load the previous bitmap
                    prevColor = this.prevSize || !this.model.userProperties.bitmap ? '#000000' : this.model.userProperties.bitmap[i];
                    newBitmap.push(prevColor);
                }

                if (this.prevSize) {
                    this.model.userProperties.bitmap.forEach((color, i) => {
                        let y = Math.floor(i / this.prevSize.width),
                            x = i % this.prevSize.width,
                            newPos = x + y * width;
                        if (newPos < newBitmap.length) {
                            newBitmap[newPos] = color;
                        }
                    });
                }

                this.prevSize = {
                    width: width,
                    height: height
                };

                this.set('model.userProperties.bitmap', newBitmap);
            },
            _updateLightboard () {
                this.debounce('_updateLightboard', () => {
                    let shape = {
                        id: this.model.id,
                        x: this.getX(),
                        y: this.getY(),
                        width: this.model.userProperties.width,
                        height: this.model.userProperties.height,
                        bitmap: this.model.userProperties.bitmap,
                        type: 'frame'
                    };
                    this.fire('update-shape', shape);
                });
            }
        });
    </script>
</dom-module>
