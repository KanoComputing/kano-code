<link rel="import" href="../kano-ui-behavior.html">
<link rel="import" href="../../../scripts/kano/make-apps/parts-api/base.html">
<link rel="import" href="../../../scripts/kano/microphone.html">

<script type="text/javascript">
    /* globals Polymer, Kano */

    Polymer({
        is: 'kano-part-microphone',
        behaviors: [Kano.MakeApps.PartsAPI.Base, Kano.Behaviors.UIBehavior],
        properties: {
            model: {
                type: Object,
                notify: true
            }
        },

        ready () {
            this.reset();
        },
        attached () {
            Kano.Microphone.start().then(() => {
                this._update();
            }).catch(error => {
                let message;
                if (error.name === 'PermissionDeniedError') {
                    message = 'Kano Code needs permission to use your microphone. You can allow access from your browser settings.';
                } else {
                    message = 'Your browser doesn\'t support audio input. The microphone part has been disabled.';
                }
                this.fire('kano-error', {
                    text: message,
                    duration: 0,
                    closeWithButton: true,
                    buttonText: 'OK'
                });
            });
        },
        detached () {
            clearTimeout(this.timeoutId);
        },
        start () {
            Kano.MakeApps.PartsAPI.Base.start.apply(this, arguments);
            this.reset();
        },
        stop () {
            Kano.MakeApps.PartsAPI.Base.stop.apply(this, arguments);
            this.reset();
        },
        _update () {
            this.volume = Kano.Microphone.getVolume();
            this.pitch = Kano.Microphone.getPitch();

            if (this.isRunning) {
                this._executeThresholds();
            }

            this.timeoutId = setTimeout(this._update.bind(this), 32);
        },
        _executeThresholds () {
            this.thresholds.forEach((threshold, index, self) => {
                if (this.volume > threshold.top) {
                    if (threshold.over && !threshold.isOver) {
                        self[index].isOver = true;
                        threshold.cb.call({});
                    } else if (!threshold.over && threshold.isUnder) {
                        self[index].isUnder = false;
                    }
                } else if (this.volume < threshold.bottom) {
                    if (threshold.over && threshold.isOver) {
                        self[index].isOver = false;
                    } else if (!threshold.over && !threshold.isUnder) {
                        self[index].isUnder = true;
                        threshold.cb.call({});
                    }
                }
            });
        },
        onVolumeThreshold (value, over, cb) {
            let threshold = {
                value: Math.max(0, Math.min(100, value)),
                over,
                cb
            };
            threshold.top = Math.min(100 - 2.5, threshold.value + 2.5);
            threshold.bottom = Math.max(2.5, threshold.value - 2.5);
            this.thresholds.push(threshold);
        },
        getvolume () {
            return this.volume
        },
        getpitch () {
            return this.pitch;
        },
        reset () {
            this.thresholds = [];
        }
    });
</script>
