<link rel="import" href="../../ui/behaviors.html">
<link rel="import" href="../../../bower_components/iron-image/iron-image.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../kano-style/part.html">
<dom-module id="kano-part-microphone">
    <style is="custom-style" include="part-style"></style>
    <style>
    :host {
        display: block;
    }
    .container {
        position: relative;
        width: 40px;
        height: 40px;
    }
    .ripple {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        @apply(--layout-vertical);
        @apply(--layout-center);
        @apply(--layout-center-justified);
    }
    :host[disabled] .ripple {
        background-color: #9e9e9e;
    }
    .ripple {
        width: 40px;
        height: 40px;
        border-radius: 50%;
    }
    .image {
        background-color: rgb(229, 57, 53);
        background-image: url('/assets/part/microphone.svg');
        background-size: cover;
        background-blend-mode: soft-light;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        @apply(--shadow-elevation-2dp);
    }
    .data {
        color: white;
        position: absolute;
        top: 0px;
        width: 40px;
        height: 40px;
        text-align: center;
        @apply(--layout-vertical);
        @apply(--layout-center);
        @apply(--layout-center-justified);
        font-size: 24px;
    }
    </style>
    <template>
        <div class="container">
            <div class="ripple" style$="[[_computeRippleStyle(volume)]]"></div>
            <div class="ripple" style$="[[_computeRippleStyle(low)]]"></div>
            <div class="image"></div>
            <div class="data">
                <span>[[volumeData]]</span>
            </div>
        </div>
    </template>
    <script type="text/javascript">
        /* globals Polymer, Kano */

        // Cross browser tweaks
        // Putting getUserMedia in navigator is a wrong practice, since the spec moved it inside MediaDevices
        // but calling it outside of navigator will fail on chrome
        window.MediaDevices = window.MediaDevices || {};
        if (window.MediaDevices && window.MediaDevices.getUserMedia) {
            navigator.getUserMedia = window.MediaDevices.getUserMedia;
        }
        navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
        window.AudioContext = window.AudioContext || window.webkitAudioContext;


        Polymer({
            is: 'kano-part-microphone',
            behaviors: [Kano.Behaviors.UIBehavior],
            properties: {
                volume: {
                    type: Number,
                    value: 0,
                    readOnly: true,
                    notify: true
                },
                low: {
                    type: Number,
                    value: 0,
                    readOnly: true,
                    notify: true
                },
                disabled: {
                    type: Boolean,
                    value: false,
                    notify: true,
                    reflectToAttribute: true
                }
            },
            ready () {
                this.reset();
            },
            attached () {
                this._onStreamReady = this._onStreamReady.bind(this);
                this._onStreamError = this._onStreamError.bind(this);
                try {
                    navigator.getUserMedia({ audio: true }, this._onStreamReady, this._onStreamError);
                } catch (e) {
                    this.fire('kano-error', {
                        text: `Your browser doesn't support audio input. The microphone part has been disabled.`,
                        duration: 0,
                        closeWithButton: true,
                        buttonText: 'OK'
                    });
                    this.disabled = true;
                }
            },
            detached () {
                cancelAnimationFrame(this.requestId);
                if (this.stream) {
                    this.stream.getAudioTracks().forEach((track) => {
                        track.stop();
                    });
                }
            },
            start () {
                Kano.Behaviors.UIBehavior.start.apply(this, arguments);
                this.reset();
            },
            stop () {
                Kano.Behaviors.UIBehavior.stop.apply(this, arguments);
                this.reset();
            },
            _onStreamReady (stream) {
                this.disabled = false;
                this.stream = stream;
                this.audioContext = new window.AudioContext();
                this.analyser = this.audioContext.createAnalyser();
                this.source = this.audioContext.createMediaStreamSource(stream);
                this.analyser.smoothingTimeConstant = 0.5;
                this.analyser.fftSize = 64;
                this.soundData = new Uint8Array(this.analyser.frequencyBinCount);

                this.source.connect(this.analyser);
                this._updateVisualisation();
            },
            _onStreamError (e) {
                if (e.name === 'PermissionDeniedError') {
                    this.fire('kano-error', {
                        text: `Make Apps needs permission to use your microphone. You can allow access from your browser settings.`,
                        duration: 0,
                        closeWithButton: true,
                        buttonText: 'OK'
                    });
                }
                this.disabled = true;
            },
            _updateVisualisation (timestamp) {
                let stats;
                // Populates the sound data array
                this.analyser.getByteFrequencyData(this.soundData);
                stats = this._getSoundStats(this.soundData);
                this._setVolume(Math.min(120, stats.volume) / 1.2);
                this._setLow(Math.min(120, stats.low) / 1.2);

                if (this.isRunning) {
                    this._executeThresholds();
                }

                if (!this.prevTimestamp || timestamp - this.prevTimestamp > 150) {
                    this.prevTimestamp = timestamp;
                    this.set('volumeData', Math.round(this.volume));
                }

                this.requestId = requestAnimationFrame(this._updateVisualisation.bind(this));
            },
            _executeThresholds () {
                this.thresholds.forEach((threshold, index, self) => {
                    if (this.volume > threshold.top) {
                        if (threshold.over && !threshold.isOver) {
                            self[index].isOver = true;
                            threshold.cb.call({});
                        } else if (!threshold.over && threshold.isUnder) {
                            self[index].isUnder = false;
                        }
                    } else if (this.volume < threshold.bottom) {
                        if (threshold.over && threshold.isOver) {
                            self[index].isOver = false;
                        } else if (!threshold.over && !threshold.isUnder) {
                            self[index].isUnder = true;
                            threshold.cb.call({});
                        }
                    }
                });
            },
            _computeRippleStyle (volume) {
                return `box-shadow: 0px 0px 0px ${(volume * 0.5)}px rgba(229, 57, 53, 0.4);`;
            },
            _getSoundStats (array) {
                let values = 0,
                    lows = 0,
                    length = array.length,
                    average;

                // get all the frequency amplitudes
                for (let i = 0; i < length; i++) {
                    values += array[i];
                    if (i === 21) {
                        lows = values;
                    }
                }

                average = values / length;
                return { volume: average, low: lows / 21 };
            },
            onVolumeThreshold (value, over, cb) {
                let threshold = {
                    value: Math.max(0, Math.min(100, value)),
                    over,
                    cb
                };
                threshold.top = Math.min(100 - 2.5, threshold.value + 2.5);
                threshold.bottom = Math.max(2.5, threshold.value - 2.5);
                this.thresholds.push(threshold);
            },
            reset () {
                console.log('microphone reset');
                this.thresholds = [];
            }
        });
    </script>
</dom-module>
