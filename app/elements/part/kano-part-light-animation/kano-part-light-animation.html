<link rel="import" href="../kano-light-shape-behavior.html">
<link rel="import" href="../../../bower_components/web-components/kano-style/part.html">
<link rel="import" href="../../../scripts/kano/make-apps/parts-api/light-animation.html">
<dom-module id="kano-part-light-animation">
    <style is="custom-style" include="part-style"></style>
    <style>
    :host {
        display: block;
    }
    .container {
        position: relative;
        border: 1px solid blue;
        padding: 2px;
    }
    .container[running] {
        display: none;
    }
    </style>
    <template>
        <div class="container" running$="[[isRunning]]">
            <kano-bitmap-renderer width="[[model.userProperties.width]]" height="[[model.userProperties.height]]" bitmap="[[bitmap]]" pixel-size="21" spacing="3"></kano-bitmap-renderer>
        </div>
    </template>
    <script type="text/javascript">
        /* globals Polymer, Kano */

        Polymer({
            is: 'kano-part-light-animation',
            behaviors: [Kano.MakeApps.PartsAPI['light-animation'], Kano.Behaviors.LightShapeBehavior],
            observers: [
                '_sizeChanged(model.userProperties.width, model.userProperties.height)',
                '_onBitmapsChanged(model.userProperties.bitmaps.*)'
            ],
            _onBitmapsChanged (e) {
                //Skip function if bitmaps were newly set. We only want to store while individual frames are being edited.
                if (e.path === 'model.userProperties.bitmaps') {
                    return;
                }
                this.storedBitmaps = this.model.userProperties.bitmaps.map(this._adjustBitmapForStorage.bind(this));
            },
            ready () {
                this.frameIndex = 0;
            },
            _sizeChanged () {
                let bitmaps = this.model.userProperties.bitmaps || [],
                    width = this.model.userProperties.width,
                    height = this.model.userProperties.height;

                if (!this.storedBitmaps) {
                    let firstBitmap = [];
                    for (let i = 0; i < height * width; i++) {
                        firstBitmap.push('#000000');
                    }
                    this.set('model.userProperties.bitmaps', [firstBitmap]);
                    return;
                }
                bitmaps = this.storedBitmaps.map(this._adjustBitmapForDisplay.bind(this));
                this.set('model.userProperties.bitmaps', bitmaps);
            },
            _adjustBitmapForStorage (bitmap) {
                let unfilledPixels = 128 - bitmap.length,
                    clone = bitmap.slice(0);
                
                //Fill out bitmap with #000 pixels to have everything stored in 16 x 8
                if (unfilledPixels) {
                    for (let i = 0; i < unfilledPixels; i++) {
                        clone.push('#000');
                    }
                }
                return clone;
            },
            _adjustBitmapForDisplay (bitmap) {
                //Filter unnecessary pixels from 16 x 8 stored bitmap
                let maxIndex = this.model.userProperties.width * this.model.userProperties.height;
                    adjustedBitmap = bitmap.filter((color, index) => index < maxIndex);
                return adjustedBitmap;
            }
        });
    </script>
</dom-module>
