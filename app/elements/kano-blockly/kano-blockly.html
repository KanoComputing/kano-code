<script src="../../assets/vendor/google-blockly/blockly_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/blocks_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/javascript_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/msg/js/en.js"></script>
<script src="./blockly-override.js"></script>
<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../behaviors.html">

<dom-module id="kano-blockly">
    <link rel="import" type="css" href="./kano-blockly.css">
    <template>
        <div id="workspace"></div>
    </template>
</dom-module>

<script>
    /* globals Polymer, KanoBehaviors, Blockly */

    class KanoBlockly {

        get behaviors () {
            return [KanoBehaviors.CodeEditorBehavior, KanoBehaviors.AppEditorBehavior];
        }

        beforeRegister () {
            this.is = 'kano-blockly';
            this.properties = {
                toolbox: {
                    type: Array,
                    value: () => []
                },
                toolboxXml: {
                    type: String,
                    computed: 'computeToolboxXml(toolbox)'
                },
                code: {
                    type: String,
                    notify: true
                }
            };
        }
        /**
         * Inject blockly to the workspace div and register the resize event
         */
        attached () {
            this.visible = false;
            this.workspace = Blockly.inject(this.$.workspace, {
                toolbox: this.toolboxXml,
                media: '/assets/vendor/google-blockly/media/'
            });
            window.addEventListener('resize', this.onResize.bind(this), false);
            this.workspace.addChangeListener(this.onBlocklyChange.bind(this));
            this.onResize();
            this.fire('blockly-ready');
        }
        detached () {
            this.workspace.dispose();
        }
        /**
         * Triggers the resize event on the window
         */
        resize () {
            Blockly.fireUiEvent(window, 'resize');
        }
        /**
         * Debounce function that will apply style rules to the workspace
         * element to let know Blockly the new dimensions.
         */
        onResize () {
            requestAnimationFrame(() => {
                // Check if the ws is visible
                if (this.offsetWidth > 0 && this.offsetHeight > 0) {
                    // The visibilty went from false to true, notify with an event
                    if (!this.visible) {
                        this.visible = true;
                        this.fire('blockly-ready');
                    } else {
                        this.visible = true;
                    }
                } else {
                    this.visible = false;
                }
                let workspace = this.$.workspace;
                workspace.style.top = '0px';
                workspace.style.bottom = '0px';
                workspace.style.left = '0px';
                workspace.style.right = '0px';
            });
        }
        /**
         * Takes a categories definition in JSON and generates the XML
         * string blockly needs to display the toolbox.
         * It will also update the current blockly workspace.
         * @param  {Object} toolbox A JSON toolbox definition
         * @return {String}         A XML toolbox definition
         */
        computeToolboxXml () {
            // Force default toolbox if empty since blockly is not able
            // to switch from empty to category mode
            if (!this.toolbox || !this.toolbox.length) {
                return '<xml><category name=""></category></xml>';
            }
            let xml,
                categoriesXml = this.toolbox.map((category) => {
                    if (category.type === 'separator') {
                        return '<sep gap="8"></sep>';
                    }
                    let blocksXml = category.blocks.map((block) => {
                        let colourAttr = block.colour ? `colour="${block.colour}"` : '',
                            shadow = block.shadow || {},
                            content = Object.keys(shadow).map(field => `<value name="${field}">${block.shadow[field]}</value>`);
                        return `<block type="${block.id}" ${colourAttr}>${content}</block>`;
                    }).join(''),
                        colour = category.colour;

                    if (colour && typeof colour.replace === 'function') {
                        colour = colour.replace(/"/g, '&quot;');
                    }
                    return `<category name="${category.name}" colour="${colour}" id="${category.id}">
                                ${blocksXml}
                            </category>`;
                }).join('');
            xml = `<xml>${categoriesXml}</xml>`;
            // Update the workspace if it exists
            if (this.workspace) {
                try {
                    this.workspace.updateToolbox(xml);
                } catch (e) {} // Ignore toolbox loading errors
                this.resize();
            }
            return xml;
        }
        /**
         * Remove every block in the workspace
         */
        clearWorkspace () {
            if (!this.workspace) {
                return;
            }
            this.workspace.clear();
        }
        /**
         * Update the code on any blockly change and
         * bubble up the event
         * @param  {Event} e    A Blockly event
         * @return {[type]}   [description]
         */
        onBlocklyChange (e) {
            this.set('code', this.getCode('JavaScript'));
            this.notifyChange('blockly', {
                event: e
            });
        }
        /**
         * Generate a XML string representation of the blocks
         * currently on the workspace
         * @return {String}     XML string representation of the blocks
         */
        getBlocks () {
            let xml = Blockly.Xml.workspaceToDom(this.workspace),
                xmlString = Blockly.Xml.domToText(xml);
            return xmlString;
        }
        /**
         * Compute the current code for a given language
         * @param  {String} type Language to use to compute the code
         * @return {String}      A piece of code
         */
        getCode (type) {
            try {
                return Blockly[type].workspaceToCode(this.workspace);
            } catch (e) {
                return '';
            }
        }

        save () {
            let javascript = this.getCode('JavaScript'),
                pseudo = this.getCode('Pseudo'),
                blocks = this.getBlocks(),
                snapshot = {
                javascript,
                pseudo,
                blocks
            };
            this.set('snapshot', snapshot);
            return Promise.resolve(snapshot);
        }

        load (snapshot = {}) {
            // Defer the load until the workspace exists and is visible
            if (!this.workspace || !this.visible) {
                return this.addEventListener('blockly-ready', this.load.bind(this, snapshot));
            }
            if (!snapshot.blocks) {
                return;
            }
            let blocks = snapshot.blocks || '<xml></xml>';
            let xml = Blockly.Xml.textToDom(blocks);
            this.clearWorkspace();
            try {
                Blockly.Xml.domToWorkspace(this.workspace, xml);
            } catch (e) {} // Ignore loading errors
        }

        getScreenshot () {
            return new Promise((resolve) => {
                let svg = this.$$('svg'),
                    canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    loader = new Image(),
                    svgAsXML = (new XMLSerializer()).serializeToString(svg),
                    rect = this.getBoundingClientRect(),
                    offsetX = rect.width / 2;

                loader.width = rect.width;
                loader.height = rect.height;
                canvas.width = loader.width - offsetX;
                canvas.height = loader.height;
                loader.onload = () => {
                    ctx.drawImage(loader, offsetX, 0, canvas.width, loader.height, 0, 0, canvas.width, canvas.height);
                    resolve(canvas.toDataURL());
                };
                loader.src = 'data:image/svg+xml,' + encodeURIComponent(svgAsXML);
            });
        }

        getWorkspace () {
            return this.workspace;
        }
    }
    Polymer(KanoBlockly);
</script>
