<script src="../../assets/vendor/google-blockly/blockly_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/blocks_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/javascript_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/msg/js/en.js"></script>
<script src="./blockly-override.js"></script>
<link rel="import" href="../behaviors.html">

<dom-module id="kano-blockly">
    <style>
    :host {
        display: block;
        position: relative;
    }
    :host #workspace {
        position: absolute;
        top: 0px;
        bottom: 0px;
        left: 0px;
        right: 0px;
    }
    :host ::content svg {
        @apply(--kano-dotted-background);
    }
    </style>
    <template>
        <div id="workspace"></div>
    </template>
</dom-module>

<script>
    /* globals Polymer, KanoBehaviors, Blockly */

    class KanoBlockly {

        get behaviors () {
            return [KanoBehaviors.CodeEditorBehavior, KanoBehaviors.AppEditorBehavior];
        }

        beforeRegister () {
            this.is = 'kano-blockly';
            this.properties = {
                toolbox: {
                    type: Array,
                    value: () => []
                },
                toolboxXml: {
                    type: String,
                    computed: 'computeToolboxXml(toolbox)'
                },
                code: {
                    type: String,
                    notify: true
                }
            };
        }
        created () {
            Blockly.HSV_SATURATION = 0.8;
            Blockly.HSV_VALUE = 0.8;
        }
        /**
         * Inject blockly to the workspace div and register the resize event
         */
        attached () {
            this.workspace = Blockly.inject(this.$.workspace, {
                toolbox: this.toolboxXml,
                media: '/assets/vendor/google-blockly/media/'
            });
            window.addEventListener('resize', this.onResize.bind(this), false);
            this.workspace.addChangeListener(this.onBlocklyChange.bind(this));
            this.onResize();
        }
        // Wrap around the querySelector, and caches the values to
        // gain performances
        getToolboxElements () {
            if (this.toolboxElements) {
                return this.toolboxElements;
            }
            this.toolboxElements = document.querySelectorAll([
                '.blocklyWidgetDiv',
                '.blocklyTooltipDiv',
                '.blocklyToolboxDiv',
            ].join(','));
            this.toolboxElements = [].slice.call(this.toolboxElements);
            this.toolboxDiv = this.toolboxElements[2];
            return this.toolboxElements;
        }
        detached () {
            this.workspace.dispose();
        }
        /**
         * Triggers the resize event on the window
         */
        resize () {
            Blockly.fireUiEvent(window, 'resize');
        }
        /**
         * Debounce function that will apply style rules to the workspace
         * element to let know Blockly the new dimensions.
         * It also forces the toolbox to be 50% the width of the workspace
         */
        onResize () {
            this.debounce('resize', () => {
                let workspace = this.$.workspace;
                workspace.style.top = '0px';
                workspace.style.bottom = '0px';
                workspace.style.left = '0px';
                workspace.style.right = '0px';
            }, 10);
        }
        /**
         * Takes a categories definition in JSON and generates the XML
         * string blockly needs to display the toolbox.
         * It will also update the current blockly workspace.
         * @param  {Object} toolbox A JSON toolbox definition
         * @return {String}         A XML toolbox definition
         */
        computeToolboxXml () {
            // Force default toolbox if empty since blockly is not able
            // to switch from empty to category mode
            if (!this.toolbox || !this.toolbox.length) {
                this.toolbox = [{ name: 'Category', blocks: [] }];
            }
            let xml,
                categoriesXml = this.toolbox.map((category) => {
                    if (category.type === 'separator') {
                        return '<sep gap="8"></sep>';
                    }
                    let blocksXml = category.blocks.map((block) => {
                        let colourAttr = block.colour ? `colour="${block.colour}"` : '';
                        return `<block type="${block.id}" ${colourAttr}></block>`;
                    }).join(''),
                        colour = category.colour;

                    if (colour && typeof colour.replace === 'function') {
                        colour = colour.replace(/"/g, '&quot;');
                    }
                    return `<category name="${category.name}"
                                    colour="${colour}">
                                ${blocksXml}
                            </category>`;
                }).join('');
            xml = `<xml>${categoriesXml}</xml>`;
            // Update the workspace if it exists
            if (this.workspace) {
                this.workspace.updateToolbox(xml);
                this.resize();
            }
            return xml;
        }
        /**
         * Remove every block in the workspace
         */
        clearWorkspace () {
            this.workspace.clear();
        }
        /**
         * Update the code on any blockly change and
         * bubble up the event
         * @param  {Event} e    A Blockly event
         * @return {[type]}   [description]
         */
        onBlocklyChange (e) {
            this.set('code', this.getCode('JavaScript'));
            this.notifyChange('blockly', {
                event: e
            });
        }
        /**
         * Generate a XML string representation of the blocks
         * currently on the workspace
         * @return {String}     XML string representation of the blocks
         */
        getBlocks () {
            let xml = Blockly.Xml.workspaceToDom(this.workspace),
                xmlString = Blockly.Xml.domToText(xml);
            return xmlString;
        }
        /**
         * Compute the current code for a given language
         * @param  {String} type Language to use to compute the code
         * @return {String}      A piece of code
         */
        getCode (type) {
            return Blockly[type].workspaceToCode(this.workspace);
        }

        save () {
            let javascript = this.getCode('JavaScript'),
                pseudo = this.getCode('Pseudo'),
                blocks = this.getBlocks();
            return this.getScreenshot().then((screenshot) => {
                let snapshot = {
                    javascript,
                    pseudo,
                    screenshot,
                    blocks
                };
                this.set('snapshot', snapshot);
                return snapshot;
            });
        }

        load (snapshot) {
            let blocks = snapshot.blocks || '<xml></xml>';
            let xml = Blockly.Xml.textToDom(blocks);
            this.clearWorkspace();
            Blockly.Xml.domToWorkspace(this.workspace, xml);
            this.set('code', this.getCode('JavaScript'));
        }

        getScreenshot () {
            return new Promise((resolve) => {
                let svg = this.$$('svg'),
                    canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    loader = new Image(),
                    svgAsXML = (new XMLSerializer()).serializeToString(svg),
                    rect = this.getBoundingClientRect(),
                    offsetX = rect.width / 2;

                loader.width = rect.width;
                loader.height = rect.height;
                canvas.width = loader.width - offsetX;
                canvas.height = loader.height;
                loader.onload = () => {
                    ctx.drawImage(loader, offsetX, 0, canvas.width, loader.height, 0, 0, canvas.width, canvas.height);
                    resolve(canvas.toDataURL());
                };
                loader.src = 'data:image/svg+xml,' + encodeURIComponent(svgAsXML);
            });
        }
    }
    Polymer(KanoBlockly);
</script>
