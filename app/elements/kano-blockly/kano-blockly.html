<script src="../../assets/vendor/google-blockly/blockly_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/blocks_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/javascript_compressed.js"></script>
<script src="../../assets/vendor/google-blockly/msg/js/en.js"></script>
<script src="./blockly-override.js">

</script>

<dom-module id="kano-blockly">
    <style>
    :host {
        display: block;
        position: relative;
    }
    :host #workspace {
        position: absolute;
        top: 0px;
        bottom: 0px;
        left: 0px;
        right: 0px;
    }
    :host ::content svg {
        @apply(--kano-dotted-background);
    }
    </style>
    <template>
        <div id="workspace"></div>
    </template>
</dom-module>

<script>
    class KanoBlockly {
        beforeRegister () {
            this.is = 'kano-blockly';
            this.properties = {
                toolbox: {
                    type: Array,
                    value: () => []
                },
                toolboxXml: {
                    type: String,
                    computed: 'computeToolboxXml(toolbox)'
                },
                code: {
                    type: String,
                    notify: true
                },
                blocks: {
                    type: String,
                    observer: 'blocksChanged'
                }
            };
        }
        created () {
            Blockly.HSV_SATURATION = 0.8;
            Blockly.HSV_VALUE = 0.8;
        }
        /**
         * Inject blockly to the workspace div and register the resize event
         */
        attached () {
            this.workspace = Blockly.inject(this.$.workspace, {
                toolbox: this.toolboxXml
            });
            window.addEventListener('resize', this.onResize.bind(this), false);
            this.workspace.addChangeListener(this.onBlocklyChange.bind(this));
            this.onResize();
        }
        // Wrap around the querySelector, and caches the values to
        // gain performances
        getToolboxElements () {
            if (this.toolboxElements) {
                return this.toolboxElements;
            }
            this.toolboxElements = document.querySelectorAll([
                '.blocklyWidgetDiv',
                '.blocklyTooltipDiv',
                '.blocklyToolboxDiv',
            ].join(','));
            this.toolboxElements = [].slice.call(this.toolboxElements);
            this.toolboxDiv = this.toolboxElements[2];
            return this.toolboxElements;
        }
        /**
         * Set the sisibility of all the toolbox elements to hidden
         * Needs to be done since these elements are added to the DOM
         * by Blockly
         */
        hideToolbox () {
            this.getToolboxElements().forEach((el) => {
                el.style.visibility = 'hidden';
            });
        }
        /**
         * Set the sisibility of all the toolbox elements to visible
         * Counteract the effects of `hideToolbox`
         */
        showToolbox () {
            this.getToolboxElements().forEach((el) => {
                el.style.visibility = 'visible';
            });
        }
        detached () {
            // Hack to get rid of the remaining blockly elements
            this.getToolboxElements().forEach((el) => {
                el.parentNode.removeChild(el);
            });
        }
        /**
         * Triggers the resize event on the window
         */
        resize () {
            Blockly.fireUiEvent(window, 'resize');
        }
        /**
         * Debounce function that will apply style rules to the workspace
         * element to let know Blockly the new dimensions.
         * It also forces the toolbox to be 50% the width of the workspace
         */
        onResize () {
            this.debounce('resize', () => {
                let workspace = this.$.workspace;
                    rows = document.querySelectorAll('.blocklyTreeRow');
                workspace.style.top = '0px';
                workspace.style.bottom = '0px';
                workspace.style.left = '0px';
                workspace.style.right = '0px';
            }, 10);
        }
        /**
         * Takes a categories definition in JSON and generates the XML
         * string blockly needs to display the toolbox.
         * It will also update the current blockly workspace.
         * @param  {Object} toolbox A JSON toolbox definition
         * @return {String}         A XML toolbox definition
         */
        computeToolboxXml (toolbox) {
            // Force default toolbox if empty since blockly is not able
            // to switch from empty to category mode
            if (!this.toolbox || !this.toolbox.length) {
                this.toolbox = [{ name: 'Category', blocks: [] }];
            }
            let xml;
                categoriesXml = this.toolbox.map((category) => {
                    let blocksXml = category.blocks.map((block) => {
                        return `<block type="${block.id}"></block>`;
                    }).join(''),
                        colour = category.colour;

                    if (colour && typeof colour.replace === 'function') {
                        colour = colour.replace(/"/g, '&quot;');
                    }
                    return `<category name="${category.name}"
                                    colour="${colour}">
                                ${blocksXml}
                            </category>`;
                }).join('');
            xml = `<xml>${categoriesXml}</xml>`;
            // Update the workspace if it exists
            if (this.workspace) {
                this.workspace.updateToolbox(xml);
                this.resize();
            }
            return xml;
        }
        /**
         * Remove every block in the workspace
         */
        clearWorkspace () {
            this.workspace.clear();
        }
        /**
         * Update the workspace and current code with the new blocks
         */
        blocksChanged () {
            this.blocks = this.blocks || '<xml></xml>';
            let xml = Blockly.Xml.textToDom(this.blocks);
            this.clearWorkspace();
            Blockly.Xml.domToWorkspace(this.workspace, xml);
            this.set('code', this.getCode('JavaScript'));
        }
        /**
         * Update the code on any blockly change and
         * bubble up the event
         * @param  {Event} e    A Blockly event
         * @return {[type]}   [description]
         */
        onBlocklyChange (e) {
            this.set('code', this.getCode('JavaScript'));
            this.fire('change', e);
        }
        /**
         * Generate a XML string representation of the blocks
         * currently on the workspace
         * @return {String}     XML string representation of the blocks
         */
        getBlocks () {
            let xml = Blockly.Xml.workspaceToDom(this.workspace),
                xmlString = Blockly.Xml.domToText(xml);
            return xmlString;
        }
        /**
         * Compute the current code for a given language
         * @param  {String} type Language to use to compute the code
         * @return {String}      A piece of code
         */
        getCode (type) {
            return Blockly[type].workspaceToCode(this.workspace);
        }

        getScreenshot () {
            return new Promise((resolve, reject) => {
                let svg = this.$$('svg'),
                    canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    loader = new Image(),
                    svgAsXML = (new XMLSerializer()).serializeToString(svg),
                    rect = this.getBoundingClientRect(),
                    offsetX = rect.width / 3;

                loader.width = canvas.width = rect.width;
                loader.height = canvas.height = rect.height;
                loader.onload = () => {
                    ctx.drawImage(loader, 0, 0, loader.width, loader.height);
                    resolve(canvas.toDataURL());
                };
                loader.src = 'data:image/svg+xml,' + encodeURIComponent(svgAsXML);
            });
        }
    }
    Polymer(KanoBlockly);
</script>
