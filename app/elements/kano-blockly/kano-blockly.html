<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../bower_components/neon-animation/animations/scale-up-animation.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-out-animation.html">
<link rel="import" href="../../bower_components/iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="./import.html">
<link rel="import" href="../kano-style/dialog.html">
<link rel="import" href="../kano-blockly-omnibox/kano-blockly-omnibox.html">
<link rel="import" href="../kano-blockly-toolbox/kano-blockly-toolbox.html">
<link rel="import" href="../kano-animation/animations/from-big-animation.html">
<link rel="import" href="./kano-blockly-style.html">

<!--
`kano-blockly`

Example:
    <kano-blockly></kano-blockly>

 The following custom properties and mixins are also available for styling:

 Custom property | Description | Default
 ----------------|-------------|----------
 `--kano-blockly-background` | Background | `white`

@group Kano Elements
@hero hero.svg
@demo demo/index.html
-->
<dom-module id="kano-blockly">
    <template>
        <style include="kano-blockly-style"></style>
        <style include="kano-style-dialog"></style>
        <style>
            :host {
                display: block;
                position: relative;
            }
            #workspace {
                position: absolute;
                top: 0px;
                bottom: 0px;
                left: 0px;
                right: 0px;
                @apply(--layout-horizontal);
                background-color: var(--kano-blockly-background, white);
            }
            #toolbox {
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                box-sizing: border-box;
                --kano-blockly-toolbox-background: var(--kano-blockly-background, white);
            }
            #svg {
                @apply --layout-flex;
                height: 100%;
            }
            .gutter {
                width: 20px;
                color: rgb(85, 100, 109);
                @apply(--layout-vertical);
                padding-top: 22px;
                padding-left: 22px;
            }

            .gutter div {
                height: 22px;
                font-weight: 400;
                @apply(--layout-horizontal);
                @apply(--layout-center);
            }
            .buttons button {
                @apply(--kano-button);
                background-color: var(--color-green, green);
            }
            .container input {
                @apply(--kano-input);
                width: 100%;
                border: 2px solid var(--color-lightgrey, grey);
                padding: 5px;
                font-size: 17px;
                box-sizing: border-box;
            }
            .container input:focus {
                outline: none;
                border: 2px solid var(--color-orange, orange);
            }
            .container {
                padding: 16px 8px 8px 8px;
            }
            .omnibox-wrapper {
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                @apply(--layout-vertical);
                @apply(--layout-center);
                display: none;
                /* 150px is half the max size of the flyout */
                padding-top: calc(50% - 150px);
            }
            paper-dialog .buttons .confirm {
                background: var(--color-grassland);
                color: white;
            }
            #dialog-content {
                min-width: 320px;
            }
        </style>
        <div id="workspace" class="injectionDiv">
            <kano-blockly-toolbox id="toolbox" toolbox="[[toolbox]]" on-block-created="_onToolboxBlockCreated" auto-close hidden$="{{noToolbox}}"></kano-blockly-toolbox>
            <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <div class="omnibox-wrapper" id="omnibox-wrapper" on-tap="_omniboxWrapperTapped">
            <kano-blockly-omnibox id="omnibox" on-close="_closeOmnibox" on-confirm="_onOmniboxConfirm"></kano-blockly-omnibox>
        </div>
        <paper-dialog id="dialog" entry-animation="from-big-animation" fit-into="[[svg]]" with-backdrop>
            <div id="dialog-content">
                <h2>[[dialog.message]]</h2>
                <div class="container" hidden$="[[dialog.noInput]]">
                    <kano-input-text id="dialog-input" value="{{dialog.input}}" no-label autofocus on-keydown="_dialogKeydown"></kano-input-text>
                </div>
                <div class="buttons">
                    <button dialog-confirm class="confirm">Confirm</button>
                    <button dialog-dismiss hidden$="[[dialog.noCancel]]">Cancel</button>
                </div>
            </div>
        </paper-dialog>
        <iron-a11y-keys keys="meta+f" on-keys-pressed="_openOmnibox" target="[[target]]"></iron-a11y-keys>
        <iron-a11y-keys keys="esc" on-keys-pressed="_closeOmnibox" target="[[target]]"></iron-a11y-keys>
    </template>
</dom-module>

<script>
    Polymer({
        is: 'kano-blockly',
        properties: {
            toolbox: {
                type: Array,
                value: () => []
            },
            code: {
                type: String,
                notify: true
            },
            defaultBlocks: {
                type: String,
                observer: '_defaultBlocksChanged'
            },
            language: {
                type: String,
                value: 'JavaScript'
            },
            scale: {
                type: Number,
                value: 0.9
            },
            noTrashcan: {
                type: Boolean,
                value: false
            },
            noZoomControl: {
                type: Boolean,
                value: false
            },
            noToolbox: {
                type: Boolean,
                value: false
            }
        },
        listeners: {
            'toolbox.scroll': '_onToolboxScroll'
        },
        ready () {
            this.codeRelatedEvents = [Blockly.Events.CREATE, Blockly.Events.MOVE, Blockly.Events.CHANGE];
            this._blurInput = this._blurInput.bind(this);
            this._onMouseWheel = this._onMouseWheel.bind(this);
        },
        /**
         * Inject blockly to the workspace div
         */

        attached () {
            let options, defs;
            this.dialog = {
                element: this.$.dialog
            };
            this.target = document.body;
            this.visible = false;
            options = new Blockly.Options({
                media: '/assets/vendor/google-blockly/media/',
                scrollbars: true,
                trashcan: !this.noTrashcan,
                comments: true,
                disable: true,
                zoom: {
                    controls: !this.noZoomControl,
                    startScale: this.scale,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                }
            });
            this.svg = this.$.svg;
            this.svg.addEventListener('mousewheel', this._onMouseWheel);
            defs = Blockly.utils.createSvgElement('defs', {}, this.svg);
            options.gridPattern = Blockly.utils.createSvgElement('pattern', {'id': 'blocklyGridPattern' + String(Math.random()).substring(2), 'patternUnits': 'userSpaceOnUse'}, defs);
            // Load CSS.
            Blockly.Css.inject(options.hasCss, options.pathToMedia);
            this._setupDialogs();
            this.workspace = this._createWorkspace(this.$.svg, options);
            this.workspace.toolbox = this.$.toolbox;
            this.workspace.toolbox_ = this.$.toolbox;
            this._initWorkspace();
            this.workspace.markFocused();
            Blockly.bindEvent_(this.$.svg, 'focus', this.workspace, this.workspace.markFocused);
            Blockly.svgResize(this.workspace);
            Polymer.dom(this.root).appendChild(Blockly.Css.styleSheet_.ownerNode.cloneNode(true));
            this.workspace.componentRoot_ = Polymer.dom(this.root);
            this.workspace.addChangeListener(this.onBlocklyChange.bind(this));

            this.$.omnibox.targetWorkspace = this.workspace;
            this.$.toolbox.targetWorkspace = this.workspace;

            this.async(() => {
                this.fire('blockly-ready');
                this.resize();
                // Trick to enable shadow DOM like styling of xtag generated components
                if (!Polymer.Settings.useNativeShadow) {
                    let elems = Polymer.dom(this.root).querySelectorAll('svg, div');

                    for (let i = 0; i < elems.length; i++) {
                        this.toggleClass('kano-blockly', true, elems[i]);
                    }
                }
            });

            document.body.style.overflow = 'hidden';
            document.addEventListener('iron-overlay-opened', this._blurInput);
        },
        detached () {
            this.svg.removeEventListener('mousewheel', this._onMouseWheel);
            this.workspace.dispose();
            document.body.style.overflow = undefined;
            document.removeEventListener('iron-overlay-opened', this._blurInput);
        },
        _onMouseWheel (e) {
            let workspace = this.workspace,
                metrics = workspace.getMetrics(),
                x = e.deltaX * workspace.scale,
                y = e.deltaY * workspace.scale,
                // Magic number, help me figure out why this works
                offset = 22;

            x = (workspace.scrollbar.hScroll.handlePosition_ / workspace.scrollbar.hScroll.ratio_) + x;
            y = (workspace.scrollbar.vScroll.handlePosition_ / workspace.scrollbar.vScroll.ratio_) + y;

            console.log(y, workspace.scrollbar.vScroll.scrollViewSize_ * workspace.scrollbar.hScroll.ratio_);

            x = Math.min(x, metrics.viewWidth - metrics.toolboxWidth - offset);
            //y = Math.min(y, (metrics.viewHeight * workspace.scale) - offset);
            x = Math.max(x, 0);
            y = Math.max(y, 0);

            // Move the scrollbars and the page will scroll automatically.
            workspace.scrollbar.set(x, y);
            e.stopPropagation();
            e.preventDefault();
        },
        _setupDialogs () {
            Blockly.prompt = (message, defaultValue, callback) => {
                this._openDialog(message, defaultValue, { inputSelect: true }).then(answer => {
                    if (!answer.length) {
                        return callback(null);
                    }
                    callback(answer);
                });
            };
            Blockly.confirm = (message, callback) => {
                this._openDialog(message, defaultValue, { noInput: true }).then(callback);
            };
            Blockly.alert = (message, callback) => {
                this._openDialog(message, defaultValue, { noInput: true, noCancel: true }).then(callback);
            };
        },
        _preventSubmit (e) {
            e.preventDefault();
            e.stopPropagation();
        },
        _onToolboxBlockCreated () {
            this.$.svg.style.zIndex = 1;
        },
        _onToolboxEndDrag () {
            this.$.svg.style.zIndex = '';
        },
        _createWorkspace (svg, options) {
            options.parentWorkspace = null;
            var mainWorkspace = new Blockly.WorkspaceSvg(options);
            mainWorkspace.scale = options.zoomOptions.startScale;
            svg.appendChild(mainWorkspace.createDom('blocklyMainBackground'));
            // A null translation will also apply the correct initial scale.
            mainWorkspace.translate(0, 0);
            mainWorkspace.markFocused();

            mainWorkspace.functionsRegistry = new Blockly.FunctionsRegistry(mainWorkspace);

            // The SVG is now fully assembled.
            Blockly.svgResize(mainWorkspace);
            Blockly.WidgetDiv.createDom();
            Blockly.Tooltip.createDom();
            return mainWorkspace;
        },
        _initWorkspace () {
            let options = this.workspace.options;
            var svg = this.workspace.getParentSvg();

            // Supress the browser's context menu.
            Blockly.bindEvent_(svg, 'contextmenu', null, (e) => {
                if (!Blockly.utils.isTargetInput(e)) {
                    e.preventDefault();
                }
            });

            var workspaceResizeHandler = Blockly.bindEvent_(window, 'resize', null, () => {
                Blockly.hideChaff(true);
                Blockly.svgResize(this.workspace);
            });
            this.workspace.setResizeHandlerWrapper(workspaceResizeHandler);

            Blockly.inject.bindDocumentEvents_();

            if (options.hasScrollbars) {
                this.workspace.scrollbar = new Blockly.ScrollbarPair(this.workspace);
                this.workspace.scrollbar.resize();
            }

            // Load the sounds.
            if (options.hasSounds) {
                Blockly.inject.loadSounds_(options.pathToMedia, this.workspace);
            }
        },
        _closeOmnibox (e) {
            if (!this._omniboxOpened) {
                return;
            }
            if (e && e.detail.keyboardEvent) {
                e.detail.keyboardEvent.stopPropagation();
                e.detail.keyboardEvent.preventDefault();
            }
            this._omniboxOpened = false;
            this.$.omnibox.animate([{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: 80,
                easing: 'ease-in'
            }).finished.then(_ => {
                this.$['omnibox-wrapper'].style.display = 'none';
            });
        },
        _openOmnibox (e) {
            if (e && e.detail && e.detail.keyboardEvent) {
                e.detail.keyboardEvent.preventDefault();
                e.detail.keyboardEvent.stopPropagation();
            }
            Blockly.ContextMenu.hide();
            this._omniboxOpened = true;
            this.$['omnibox-wrapper'].style.display = 'flex';
            this.$.omnibox.focus();
            this.$.omnibox.animate([{
                transform: 'scale(0)',
                opacity: 0
            }, {
                transform: 'scale(1)',
                opacity: 1
            }], {
                duration: 150,
                easing: 'cubic-bezier(0.2, 0, 0.13, 1.5)'
            });
        },
        _omniboxWrapperTapped (e) {
            let event = Polymer.dom(e);
            if (event.rootTarget === this.$['omnibox-wrapper']) {
                this._closeOmnibox();
            }
        },
        _onOmniboxConfirm (e) {
            let type = e.detail.selected.type,
                block = this.workspace.newBlock(type),
                svgRoot = block.getSvgRoot(),
                metrics = this.workspace.getMetrics(),
                workspaceRoot, workspaceRect, newPos, blockRect, blockPos, xy;

            block.fromQuery(this.$.omnibox.query, this.workspace);
            block.initSvg();
            block.render();

            workspaceRoot = this.workspace.getParentSvg();
            workspaceRect = workspaceRoot.getBoundingClientRect();

            newPos = {
                x: workspaceRect.width / 2,
                y: workspaceRect.height / 2
            };

            blockRect = svgRoot.getBoundingClientRect();
            blockPos = {
                x: (-blockRect.left + newPos.x + workspaceRect.left) * (1 / this.workspace.scale),
                y: (-blockRect.top + newPos.y + workspaceRect.top) * (1 / this.workspace.scale)
            };

            block.moveBy(blockPos.x, blockPos.y);
            xy = block.getRelativeToSurfaceXY();
            if ('animate' in SVGElement.prototype) {
                svgRoot.style.transformOrigin = 'center center';
                svgRoot.animate({
                    transform: [`translate(${xy.x}px, ${xy.y}px) scale(0, 0)`, `translate(${xy.x}px, ${xy.y}px) scale(1, 1)`]
                }, {
                    duration: 200,
                    easing: 'cubic-bezier(0.2, 0, 0.13, 1.5)'
                });
            }
            this._closeOmnibox();
        },
        _openDialog (message, defaultValue, opts) {
            let options = Object.assign({
                noInput: false,
                noCancel: false,
                inputSelect: false
            }, opts || {});
            return new Promise((resolve, reject) => {
                let dialog = this.dialog.element,
                onDialogClose = (e) => {
                    let reason = e.detail,
                        answer = this.dialog.input;
                    dialog.removeEventListener('iron-overlay-closed', onDialogClose);
                    if (reason.canceled) {
                        return resolve(null);
                    }
                    return resolve(answer);
                };
                this.set('dialog.message', message);
                this.set('dialog.input', defaultValue);
                this.set('dialog.noInput', options.noInput);
                this.set('dialog.noCancel', options.noCancel);
                this.$['dialog-input'].focus();
                if (options.inputSelect) {
                    this.$['dialog-input'].select();
                }
                dialog.addEventListener('iron-overlay-closed', onDialogClose);
                dialog.open();
            });
        },
        _dialogKeydown (e) {
            if (e.keyCode === 13) {
                this.dialog.element.close();
            }
        },
        /**
         * Triggers the resize event on the window
         */
        resize () {
            let ev = new Event('resize');
            window.dispatchEvent(ev);
            if (!this.workspace) {
                return;
            }
            Blockly.resizeSvgContents(this.workspace);
        },
        /**
         * Remove every block in the workspace
         */
        clearWorkspace () {
            if (!this.workspace) {
                return;
            }
            this.workspace.clear();
        },
        /**
         * Update the code on any blockly change and
         * bubble up the event
         * @param  {Event} e    A Blockly event
         * @return {[type]}   [description]
         */
        onBlocklyChange (e) {
            if (e.type === Blockly.Events.OPEN_SEARCHBOX) {
                this._openOmnibox();
                return;
            }
            if (e.type === Blockly.Events.SCROLL) {
                this.debounce('workspacePan', () => {
                    this.fire('workspace-scroll');
                }, 200);
                return;
            }
            if (e.type === Blockly.Events.CREATE) {
                this.lastCreated = e.blockId;
            }
            if ((e.type === Blockly.Events.MOVE || e.type === Blockly.Events.UI && e.element === 'click')) {
                let block = this.workspace.getBlockById(e.blockId),
                    coord, dimensions, toolboxRect;
                // If there is a move event or a click event, we check if it matches the last block created
                if (this.lastCreated === e.blockId) {
                    // The block targetted by the last event matches the last created,
                    //  we trigger a drop event
                    let ev = {
                        type: Blockly.Events.DROP_BLOCK,
                        blockId: e.blockId
                    };
                    this.workspace.fireChangeListener(ev);
                    this.lastCreated = null;
                    this._onToolboxEndDrag();
                } else if (e.type === Blockly.Events.MOVE) {
                    // The event type is `move` and the block concerned was not just created
                    this.fire('block-move');
                }
            }
            this.updateFunctions(e);
            this.fire('change', e);
            if (this.codeRelatedEvents.indexOf(e.type) !== -1) {
                this.set('code', this.getCode(this.language));
            }
        },
        updateFunctions (e) {
            let toolbox;
            if (e.type === Blockly.Events.UPDATE_FUNCTIONS) {
                for (let i = 0; i < this.toolbox.length; i++) {
                    if (this.toolbox[i].id === 'functions') {
                        toolbox = this.workspace.functionsRegistry.getToolbox();
                        this.set(`toolbox.${i}.blocks`, toolbox);
                        break;
                    }
                }
            }
        },
        /**
         * Generate a XML string representation of the blocks
         * currently on the workspace
         * @return {String}     XML string representation of the blocks
         */
        getBlocks () {
            let xml = Blockly.Xml.workspaceToDom(this.workspace),
                xmlString = Blockly.Xml.domToText(xml);
            return xmlString;
        },
        /**
         * Compute the current code for a given language
         * @param  {String} type Language to use to compute the code
         * @return {String}      A piece of code
         */
        getCode (type) {
            try {
                return Blockly[type].workspaceToCode(this.workspace);
            } catch (e) {
                console.log(e.stack);
                return '';
            }
        },
        save () {
            let javascript = this.getCode(this.language),
                pseudo = this.getCode('Pseudo'),
                blocks = this.getBlocks(),
                snapshot = {
                    javascript,
                    pseudo,
                    blocks
                };
            this.set('snapshot', snapshot);
            return Promise.resolve(snapshot);
        },
        load (snapshot = {}) {
            // Defer the load until the workspace exists
            if (!this.workspace) {
                return this.addEventListener('blockly-ready', this.load.bind(this, snapshot));
            }
            this._loadBlocks(snapshot.blocks);
        },
        _loadBlocks (blocksXml='<xml xmlns="http://www.w3.org/1999/xhtml"></xml>') {
            let xml = Blockly.Xml.textToDom(blocksXml);
            this.clearWorkspace();
            try {
                Blockly.Xml.domToWorkspace(xml, this.workspace);
            } catch (e) {console.log(e)} // Ignore loading errors
            this._checkDefaultBlocks();
        },
        _checkDefaultBlocks () {
            let blocks = this.workspace.getAllBlocks();
            if (!blocks.length && this.defaultBlocks) {
                this._loadBlocks(this.defaultBlocks);
            }
        },
        _defaultBlocksChanged () {
            // Defer the load until the workspace exists
            if (!this.workspace) {
                return this.addEventListener('blockly-ready', this._defaultBlocksChanged.bind(this));
            }
            this._checkDefaultBlocks();
        },
        _blurInput () {
            Blockly.WidgetDiv.hide();
        },
        getWorkspace () {
            return this.workspace;
        },
        getToolbox () {
            return this.$.toolbox;
        },
        _onToolboxScroll (e) {
            this.debounce('scrollEvent', () => {
                this.fire('toolbox-scroll');
            }, 200);
        }
    });
</script>
