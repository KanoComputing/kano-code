<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../bower_components/neon-animation/animations/scale-up-animation.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-out-animation.html">
<link rel="import" href="./import.html">
<link rel="import" href="../kano-blockly-omnibox/kano-blockly-omnibox.html">

<dom-module id="kano-blockly">
    <style>
        :host {
            display: block;
            position: relative;
        }
        #workspace {
            position: absolute;
            top: 0px;
            bottom: 0px;
            left: 0px;
            right: 0px;
            @apply(--layout-horizontal);
            background-color: rgb(33, 53, 66);
        }
        svg {
            @apply(--layout-flex);
        }
        .gutter {
            width: 20px;
            color: rgb(85, 100, 109);
            @apply(--layout-vertical);
            padding-top: 22px;
            padding-left: 22px;
        }

        .gutter div {
            height: 22px;
            font-weight: 400;
            @apply(--layout-horizontal);
            @apply(--layout-center);
        }

        .blocklyTreeRoot>div[role="group"]>div:not([role="treeitem"]), ::content .blocklyTreeRoot>div[role="group"]>div:not([role="treeitem"]) {
            display: none;
        }

        .blocklyEditableText>rect, ::content .blocklyEditableText>rect {
            fill: white;
            fill-opacity: 0.6;
        }

        .blocklyPathDark,
        .blocklyPathLight,
        ::content .blocklyPathDark,
        ::content .blocklyPathLight {
            fill: transparent !important;
            stroke-width: 0px !important;
        }
        .blocklySelected > .blocklyPath, ::content .blocklySelected > .blocklyPath {
            stroke-width: 1px !important;
            stroke: rgba(0, 0, 0, 0.5) !important;
            stroke-linejoin: round !important;
        }
        .blocklyHighlightedConnectionPath, ::content .blocklyHighlightedConnectionPath {
            stroke-width: 2px !important;
        }
        text.blocklyText, ::content text.blocklyText {
            font-family: bariol;
            font-size: 1em;
        }
        .blocklyEditableText:hover > rect, ::content .blocklyEditableText:hover > rect {
            stroke-width: 1px !important;
        }
        .blocklyEditableText .blocklyText, ::content .blocklyEditableText .blocklyText {
            font-size: 1em !important;
        }
        div.blocklyTreeRoot, ::content div.blocklyTreeRoot {
            padding: 0px;
        }
        span.blocklyTreeLabel, ::content span.blocklyTreeLabel {
            font-family: bariol;
            font-size: 14px;
        }
        div.blocklyTreeRow, ::content div.blocklyTreeRow {
            position: relative;
            height: auto !important;
            line-height: 20px !important;
            padding: 9px 12px !important;
            margin: 0px;
            color: white;
            font-size: 1em;
        }
        div.blocklyTreeRow:hover,
        span.blocklyTreeLabel:hover,
        ::content div.blocklyTreeRow:hover,
        ::content span.blocklyTreeLabel:hover {
            cursor: pointer;
        }
        div.blocklyTriangle {
            position: absolute;
            left: 130px;
            top: 0px;
            display: none;
            border: 12px solid transparent;
            border-left: 0px;
            border-right-width: 10px;
            border-right-color: #E8E8E8;
        }
        span.blocklyTreeIcon, ::content span.blocklyTreeIcon {
            width: 0px;
        }
        div.blocklyToolboxDiv, ::content div.blocklyToolboxDiv {
            background-color: transparent;
            position: absolute;
        }
        div.goog-tree-item, ::content div.goog-tree-item {
            border: 0px;
            visibility: hidden;
        }
        path.blocklyFlyoutBackground, ::content path.blocklyFlyoutBackground {
            fill: #E8E8E8;
            fill-opacity: 1;
        }
        rect.blocklyMainBackground, ::content rect.blocklyMainBackground {
            opacity: 0 !important;
        }
        .buttons button {
            @apply(--kano-button);
            background-color: var(--color-green, green);
        }
        input {
            @apply(--kano-input);
            width: 100%;
            border: 2px solid var(--color-lightgrey, grey);;
            padding: 5px;
            font-size: 17px;
        }
        input:focus {
            outline: none;
            border: 2px solid var(--color-orange, orange);
        }
        .container {
            padding: 8px 24px 8px 24px;
        }
        .buttons {
            padding: 8px 24px 16px 24px
        }
        .omnibox-wrapper {
            position: absolute;
            top: 0px;
            left: 0px;
            width: 100%;
            height: 100%;
            @apply(--layout-vertical);
            @apply(--layout-center);
            @apply(--layout-center-justified);
            display: none;
        }
        g.blocklyDragging {
            opacity: 0.45;
        }
    </style>
    <template>
        <div id="workspace">
            <div class="gutter">
                <template is="dom-repeat" items="[[lines]]" as="line">
                    <div style$="[[_computeLineHeight(line)]]">
                        <span>[[index]]</span>
                    </div>
                </template>
            </div>
            <svg id="svg" xmlns="http://www.w3.org/2000/svg"></svg>
        </div>
        <div class="omnibox-wrapper" id="omnibox-wrapper" on-tap="_omniboxWrapperTapped">
            <kano-blockly-omnibox id="omnibox" on-close="_closeOmnibox"></kano-blockly-omnibox>
        </div>
        <paper-dialog id="var-modal" entry-animation="scale-up-animation" exit-animation="fade-out-animation">
          <h2>[[modalText]]</h2>
          <div class="container">
              <input type="text" name="name" value="{{modalInput::input}}" on-keyup="_modalInputKeyup">
          </div>
          <div class="buttons">
              <button dialog-confirm>Confirm</button>
          </div>
        </paper-dialog>
    </template>
</dom-module>

<script>
    /* globals Polymer, Blockly */

    Polymer({
        is: 'kano-blockly',
        properties: {
            toolbox: {
                type: Array,
                value: () => []
            },
            toolboxXml: {
                type: String,
                computed: 'computeToolboxXml(toolbox)'
            },
            code: {
                type: String,
                notify: true
            }
        },
        ready () {
            this.codeRelatedEvents = [Blockly.Events.CREATE, Blockly.Events.MOVE];
        },
        /**
         * Inject blockly to the workspace div
         */
        attached () {
            this.visible = false;
            var options = new Blockly.Options({
                media: '/assets/vendor/google-blockly/media/',
                scrollbars: true,
                hasScrollbars: true,
                zoom: {
                    controls: true,
                    startScale: 1.0,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                }
            });
            // Load CSS.
            Blockly.Css.inject(options.hasCss, options.pathToMedia);
            this.workspace = this._createWorkspace(this.$.svg, options);
            this._initWorkspace(this.workspace);
            this.workspace.markFocused();
            Blockly.bindEvent_(this.$.svg, 'focus', this.workspace, this.workspace.markFocused);
            Blockly.svgResize(this.workspace);
            Polymer.dom(this.root).appendChild(Blockly.Css.styleSheet_.ownerNode.cloneNode(true));
            this.workspace.componentRoot_ = Polymer.dom(this.root);
            this.workspace.options.modalFunction = this._blocklyVarModal.bind(this);
            this.workspace.addChangeListener(this.onBlocklyChange.bind(this));

            this.$.omnibox.targetWorkspace = this.workspace;

            this.async(() => {
                this.fire('blockly-ready');
                this.resize();
                // Trick to enable shadow DOM like styling of xtag generated components
                if (!Polymer.Settings.useNativeShadow) {
                    let elems = Polymer.dom(this.root).querySelectorAll('svg, div');

                    for (let i = 0; i < elems.length; i++) {
                        this.toggleClass('kano-blockly', true, elems[i]);
                    }
                }
            });
            window.addEventListener('keydown', (e) => {
                if (e.key === 'f' && e.metaKey) {
                    this._openOmnibox();
                    e.preventDefault();
                    e.stopPropagation();
                }
            });
        },
        detached () {
            this.workspace.dispose();
        },
        _computeLineHeight (line) {
            return `height: ${line}px;`;
        },
        _updateGutter () {
            let topBlocks = this.workspace.getTopBlocks(),
                lines;
            this.set('lines', topBlocks.reduce((acc, block) => {
                lines = this._extractLines(block);
                // Extend the last line to include the space between top blocks
                lines[lines.length - 1] += 5;
                return acc.concat(lines);
            }, []));
        },
        _extractLines (block) {
            var hv = block.getHeightWidth(),
                lines = [hv.height],
                nextStatement,
                doStatement,
                connections = [],
                nextSize;
            if (block.nextConnection && block.nextConnection.targetConnection) {
                nextStatement = block.nextConnection.targetConnection;
            }
            block.inputList.forEach(input => {
                if (input.type === Blockly.NEXT_STATEMENT && input.connection.targetConnection) {
                    doStatement = input.connection.targetConnection;
                }
            });
            if (doStatement) {
                nextSize = this._extractLines(doStatement.getSourceBlock());
                nextSize.forEach(size => {
                    lines[0] -= size;
                });
                lines = lines.concat(nextSize);
            }
            // insert the line here if there is a nextStatement
            if (doStatement && nextStatement) {
                lines[0] -= 10;
                lines.push(10);
            }
            if (nextStatement) {
                nextSize = this._extractLines(nextStatement.getSourceBlock());
                nextSize.forEach(size => {
                    lines[0] -= size;
                });
                lines = lines.concat(nextSize);
            } else {
                lines[0] -= 3;
            }
            // Add the line at the end if there is a doStatement but no nextStatement
            if (doStatement && !nextStatement) {
                lines[0] -= 10;
                lines.push(10);
            }

            return lines;
        },
        _createWorkspace (svg, options) {
            options.parentWorkspace = null;
            var mainWorkspace = new Blockly.WorkspaceSvg(options);
            mainWorkspace.scale = options.zoomOptions.startScale;
            svg.appendChild(mainWorkspace.createDom());
            // A null translation will also apply the correct initial scale.
            mainWorkspace.translate(0, 0);
            mainWorkspace.markFocused();
            // The SVG is now fully assembled.
            Blockly.svgResize(mainWorkspace);
            Blockly.WidgetDiv.createDom();
            Blockly.Tooltip.createDom();
            return mainWorkspace;
        },
        _initWorkspace (mainWorkspace) {
            var options = mainWorkspace.options;
            var svg = mainWorkspace.getParentSvg();

            // Supress the browser's context menu.
            Blockly.bindEvent_(svg, 'contextmenu', null,
                function(e) {
                    if (!Blockly.isTargetInput_(e)) {
                    e.preventDefault();
                    }
                });

            var workspaceResizeHandler = Blockly.bindEvent_(window, 'resize', null, function() {
                    Blockly.hideChaff(true);
                    Blockly.svgResize(mainWorkspace);
                });
            mainWorkspace.setResizeHandlerWrapper(workspaceResizeHandler);

            Blockly.inject.bindDocumentEvents_();

            if (options.languageTree) {
                if (mainWorkspace.toolbox_) {
                    mainWorkspace.toolbox_.init(mainWorkspace);
                } else if (mainWorkspace.flyout_) {
                    // Build a fixed flyout with the root blocks.
                    mainWorkspace.flyout_.init(mainWorkspace);
                    mainWorkspace.flyout_.show(options.languageTree.childNodes);
                    mainWorkspace.flyout_.scrollToStart();
                    // Translate the workspace sideways to avoid the fixed flyout.
                    mainWorkspace.scrollX = mainWorkspace.flyout_.width_;
                    if (options.toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) {
                        mainWorkspace.scrollX *= -1;
                    }
                    mainWorkspace.translate(mainWorkspace.scrollX, 0);
                }
            }

            if (options.hasScrollbars) {
                mainWorkspace.scrollbar = new Blockly.ScrollbarPair(mainWorkspace);
                mainWorkspace.scrollbar.resize();
            }

            // Load the sounds.
            if (options.hasSounds) {
                Blockly.inject.loadSounds_(options.pathToMedia, mainWorkspace);
            }
        },
        _closeOmnibox () {
            if (!this._omniboxOpened) {
                return;
            }
            this._omniboxOpened = false;
            this.$.omnibox.animate([{
                opacity: 1
            }, {
                opacity: 0
            }], {
                duration: 80,
                easing: 'ease-in'
            }).finished.then(_ => {
                this.$['omnibox-wrapper'].style.display = 'none';
            });
        },
        _openOmnibox () {
            Blockly.ContextMenu.hide();
            this._omniboxOpened = true;
            this.$['omnibox-wrapper'].style.display = 'flex';
            this.$.omnibox.focus();
            this.$.omnibox.animate([{
                transform: 'scale(0)',
                opacity: 0
            }, {
                transform: 'scale(1)',
                opacity: 1
            }], {
                duration: 150,
                easing: 'cubic-bezier(0.2, 0, 0.13, 1.5)'
            });
        },
        _omniboxWrapperTapped (e) {
            let event = Polymer.dom(e);
            if (event.rootTarget === this.$['omnibox-wrapper']) {
                this._closeOmnibox();
            }
        },
        _blocklyVarModal (promptText, defaultText) {
            return new Promise((resolve, reject) => {
                let modal = this.$['var-modal'],
                onModalClose = function (e) {
                    let reason = e.detail,
                        varName = this.modalInput;
                    modal.removeEventListener('iron-overlay-closed', onModalClose);
                    if (reason.canceled) {
                        return resolve(null);
                    }
                    if (!varName.length) {
                        varName = null;
                    }
                    return resolve(varName);
                }.bind(this);
                this.modalText = promptText;
                this.modalInput = defaultText;
                modal.addEventListener('iron-overlay-closed', onModalClose);
                modal.open();
            });
        },
        _modalInputKeyup (e) {
            if (e.keyCode === 13) {
                this.$['var-modal'].close();
            }
        },
        /**
         * Triggers the resize event on the window
         */
        resize () {
            let ev = new Event('resize');
            window.dispatchEvent(ev);
            if (!this.workspace) {
                return;
            }
            Blockly.resizeSvgContents(this.workspace);
        },
        /**
         * Takes a categories definition in JSON and generates the XML
         * string blockly needs to display the toolbox.
         * It will also update the current blockly workspace.
         * @param  {Object} toolbox A JSON toolbox definition
         * @return {String}         A XML toolbox definition
         */
        computeToolboxXml () {
            // Force default toolbox if empty since blockly is not able
            // to switch from empty to category mode
            if (!this.toolbox || !this.toolbox.length) {
                return '<xml><category name=""></category></xml>';
            }
            let xml,
                categoriesXml = this.toolbox.map((category) => {
                    if (category.type === 'separator') {
                        return '<sep gap="8"></sep>';
                    }
                    let blocksXml = category.blocks.map((block) => {
                        let shadow = block.shadow || {},
                            content = Object.keys(shadow).map(field => `<value name="${field}">${block.shadow[field]}</value>`);
                        return `<block type="${block.id}">${content}</block>`;
                    }).join(''),
                        colour = category.colour;

                    if (colour && typeof colour.replace === 'function') {
                        colour = colour.replace(/"/g, '&quot;');
                    }
                    return `<category name="${category.name}" colour="${colour}" id="${category.id}">
                                ${blocksXml}
                            </category>`;
                }).join('');
            xml = `<xml>${categoriesXml}</xml>`;
            // Update the workspace if it exists
            if (this.workspace) {
                try {
                    this.workspace.updateToolbox(xml);
                } catch (e) {} // Ignore toolbox loading errors
            }
            return xml;
        },
        /**
         * Remove every block in the workspace
         */
        clearWorkspace () {
            if (!this.workspace) {
                return;
            }
            this.workspace.clear();
        },
        /**
         * Update the code on any blockly change and
         * bubble up the event
         * @param  {Event} e    A Blockly event
         * @return {[type]}   [description]
         */
        onBlocklyChange (e) {
            if (e.type === Blockly.Events.CREATE) {
                this.lastCreated = e.blockId;
            }
            // If there is a move event or a click event, we check if it matches the last block created
            if ((e.type === Blockly.Events.MOVE || e.type === Blockly.Events.UI && e.element === 'click') &&
                this.lastCreated === e.blockId) {
                // The block targetted by the last event matches the last created,
                //  we trigger a drop event
                let ev = {
                    type: Blockly.Events.DROP_BLOCK,
                    blockId: e.blockId
                };
                this.workspace.fireChangeListener(ev);
                this.lastCreated = null;
            }
            this.fire('change', e);
            if (this.codeRelatedEvents.indexOf(e.type) !== -1) {
                this.set('code', this.getCode('JavaScript'));
            }
            this._updateGutter();
        },
        /**
         * Generate a XML string representation of the blocks
         * currently on the workspace
         * @return {String}     XML string representation of the blocks
         */
        getBlocks () {
            let xml = Blockly.Xml.workspaceToDom(this.workspace),
                xmlString = Blockly.Xml.domToText(xml);
            return xmlString;
        },
        /**
         * Compute the current code for a given language
         * @param  {String} type Language to use to compute the code
         * @return {String}      A piece of code
         */
        getCode (type) {
            try {
                return Blockly[type].workspaceToCode(this.workspace);
            } catch (e) {
                return '';
            }
        },
        save () {
            let javascript = this.getCode('JavaScript'),
                pseudo = this.getCode('Pseudo'),
                blocks = this.getBlocks(),
                snapshot = {
                    javascript,
                    pseudo,
                    blocks
                };
            this.set('snapshot', snapshot);
            return Promise.resolve(snapshot);
        },
        load (snapshot = {}) {
            // Defer the load until the workspace exists
            if (!this.workspace) {
                return this.addEventListener('blockly-ready', this.load.bind(this, snapshot));
            }
            if (!snapshot.blocks) {
                return;
            }
            let blocks = snapshot.blocks || '<xml></xml>';
            let xml = Blockly.Xml.textToDom(blocks);
            this.clearWorkspace();
            try {
                Blockly.Xml.domToWorkspace(xml, this.workspace);
            } catch (e) {} // Ignore loading errors
        },
        getScreenshot () {
            return new Promise((resolve) => {
                let svg = this.$$('svg'),
                    canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    loader = new Image(),
                    svgAsXML = (new XMLSerializer()).serializeToString(svg),
                    rect = this.getBoundingClientRect(),
                    offsetX = rect.width / 2;

                loader.width = rect.width;
                loader.height = rect.height;
                canvas.width = loader.width - offsetX;
                canvas.height = loader.height;
                loader.onload = () => {
                    ctx.drawImage(loader, offsetX, 0, canvas.width, loader.height, 0, 0, canvas.width, canvas.height);
                    resolve(canvas.toDataURL());
                };
                loader.src = 'data:image/svg+xml,' + encodeURIComponent(svgAsXML);
            });
        },
        getWorkspace () {
            return this.workspace;
        }
    });
</script>
