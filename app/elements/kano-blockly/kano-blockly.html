<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../bower_components/neon-animation/animations/scale-up-animation.html">
<link rel="import" href="../../bower_components/neon-animation/animations/fade-out-animation.html">
<link rel="import" href="./import.html">

<dom-module id="kano-blockly">
    <style>
        :host {
            display: block;
            position: relative;
        }
        :host #workspace {
            position: absolute;
            top: 0px;
            bottom: 0px;
            left: 0px;
            right: 0px;
        }
        svg {
            @apply(--kano-crossed-background);
        }

        .blocklyEditableText>rect, ::content .blocklyEditableText>rect {
            fill: white;
            fill-opacity: 0.6;
        }

        .blocklyPathDark,
        .blocklyPathLight,
        ::content .blocklyPathDark,
        ::content .blocklyPathLight {
            fill: transparent !important;
            stroke-width: 0px !important;
        }
        .blocklySelected > .blocklyPath, ::content .blocklySelected > .blocklyPath {
            stroke-width: 1px !important;
            stroke: rgba(0, 0, 0, 0.5) !important;
            stroke-linejoin: round !important;
        }
        .blocklyHighlightedConnectionPath, ::content .blocklyHighlightedConnectionPath {
            stroke-width: 2px !important;
        }
        text.blocklyText, ::content text.blocklyText {
            font-family: bariol;
            font-size: 1em;
        }
        .blocklyEditableText:hover > rect, ::content .blocklyEditableText:hover > rect {
            stroke-width: 1px !important;
        }
        .blocklyEditableText .blocklyText, ::content .blocklyEditableText .blocklyText {
            font-size: 1em !important;
        }
        div.blocklyTreeRoot, ::content div.blocklyTreeRoot {
            padding: 0px;
        }
        span.blocklyTreeLabel, ::content span.blocklyTreeLabel {
            font-family: bariol;
            font-size: 1.1em;
        }
        div.blocklyTreeRow, ::content div.blocklyTreeRow {
            position: relative;
            height: auto !important;
            line-height: 20px !important;
            padding: 18px 12px !important;
            margin: 0px;
            color: white;
            font-size: 1em;
        }
        div.blocklyTreeRow:hover,
        span.blocklyTreeLabel:hover,
        ::content div.blocklyTreeRow:hover,
        ::content span.blocklyTreeLabel:hover {
            cursor: pointer;
        }
        div.blocklyTriangle {
            position: absolute;
            left: 140px;
            display: none;
            border: 12px solid transparent;
            border-left: 0px;
            border-right-width: 10px;
            border-right-color: #E8E8E8;
        }
        span.blocklyTreeIcon, ::content span.blocklyTreeIcon {
            width: 0px;
        }
        div.blocklyToolboxDiv, ::content div.blocklyToolboxDiv {
            background-color: transparent;
            position: absolute;
        }
        div.goog-tree-item, ::content div.goog-tree-item {
            border: 0px;
            visibility: hidden;
        }
        path.blocklyFlyoutBackground, ::content path.blocklyFlyoutBackground {
            fill: #E8E8E8;
            fill-opacity: 1;
        }
        rect.blocklyMainBackground, ::content rect.blocklyMainBackground {
            opacity: 0 !important;
        }
        .buttons button {
            @apply(--kano-button);
            background-color: var(--color-green, green);
        }
        input {
            @apply(--kano-input);
            width: 100%;
            border: 2px solid var(--color-lightgrey, grey);;
            padding: 5px;
            font-size: 17px;
        }
        input:focus {
            outline: none;
            border: 2px solid var(--color-orange, orange);
        }
        .container {
            padding: 8px 24px 8px 24px;
        }
        .buttons {
            padding: 8px 24px 16px 24px
        }
    </style>
    <template>
        <div id="workspace"></div>
        <paper-dialog id="var-modal" entry-animation="scale-up-animation" exit-animation="fade-out-animation">
          <h2>[[modalText]]</h2>
          <div class="container">
              <input type="text" name="name" value="{{modalInput::input}}" on-keyup="_modalInputKeyup">
          </div>
          <div class="buttons">
              <button dialog-confirm>Confirm</button>
          </div>
        </paper-dialog>
    </template>
</dom-module>

<script>
    /* globals Polymer, Blockly */

    Polymer({
        is: 'kano-blockly',
        properties: {
            toolbox: {
                type: Array,
                value: () => []
            },
            toolboxXml: {
                type: String,
                computed: 'computeToolboxXml(toolbox)'
            },
            code: {
                type: String,
                notify: true
            }
        },
        /**
         * Inject blockly to the workspace div
         */
        attached () {
            this.visible = false;
            this.workspace = Blockly.inject(this.$.workspace, {
                toolbox: this.toolboxXml,
                media: '/assets/vendor/google-blockly/media/',
                scrollbars: true,
                zoom: {
                    controls: true,
                    startScale: 1.0,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                }
            });
            // Oddly, panning doesn't work if the background has a fill property
            Polymer.dom(this.root).querySelector('.blocklyMainBackground').style.fill = '';
            Polymer.dom(this.root).appendChild(Blockly.Css.styleSheet_.ownerNode.cloneNode(true));
            this.workspace.componentRoot_ = Polymer.dom(this.root);
            this.workspace.options.modalFunction = this._blocklyVarModal.bind(this);
            this.workspace.addChangeListener(this.onBlocklyChange.bind(this));
            this.async(() => {
                this.fire('blockly-ready');
                this.resize();
                // Trick to enable shadow DOM like styling of xtag generated components
                if (!Polymer.Settings.useNativeShadow) {
                    let elems = Polymer.dom(this.root).querySelectorAll('svg, div');

                    for (let i = 0; i < elems.length; i++) {
                        this.toggleClass('kano-blockly', true, elems[i]);
                    }
                }
            });
        },
        detached () {
            this.workspace.dispose();
        },
        _blocklyVarModal (promptText, defaultText) {
            return new Promise((resolve, reject) => {
                let modal = this.$['var-modal'],
                onModalClose = function (e) {
                    let reason = e.detail,
                        varName = this.modalInput;
                    modal.removeEventListener('iron-overlay-closed', onModalClose);
                    if (reason.canceled) {
                        return resolve(null);
                    }
                    if (!varName.length) {
                        varName = null;
                    }
                    return resolve(varName);
                }.bind(this);
                this.modalText = promptText;
                this.modalInput = defaultText;
                modal.addEventListener('iron-overlay-closed', onModalClose);
                modal.open();
            });
        },
        _modalInputKeyup (e) {
            if (e.keyCode === 13) {
                this.$['var-modal'].close();
            }
        },
        /**
         * Triggers the resize event on the window
         */
        resize () {
            let ev = new Event('resize');
            window.dispatchEvent(ev);
            if (!this.workspace) {
                return;
            }
            Blockly.resizeSvgContents(this.workspace);
        },
        /**
         * Takes a categories definition in JSON and generates the XML
         * string blockly needs to display the toolbox.
         * It will also update the current blockly workspace.
         * @param  {Object} toolbox A JSON toolbox definition
         * @return {String}         A XML toolbox definition
         */
        computeToolboxXml () {
            // Force default toolbox if empty since blockly is not able
            // to switch from empty to category mode
            if (!this.toolbox || !this.toolbox.length) {
                return '<xml><category name=""></category></xml>';
            }
            let xml,
                categoriesXml = this.toolbox.map((category) => {
                    if (category.type === 'separator') {
                        return '<sep gap="8"></sep>';
                    }
                    let blocksXml = category.blocks.map((block) => {
                        let colourAttr = block.colour ? `colour="${block.colour}"` : '',
                            shadow = block.shadow || {},
                            content = Object.keys(shadow).map(field => `<value name="${field}">${block.shadow[field]}</value>`);
                        return `<block type="${block.id}" ${colourAttr}>${content}</block>`;
                    }).join(''),
                        colour = category.colour;

                    if (colour && typeof colour.replace === 'function') {
                        colour = colour.replace(/"/g, '&quot;');
                    }
                    return `<category name="${category.name}" colour="${colour}" id="${category.id}">
                                ${blocksXml}
                            </category>`;
                }).join('');
            xml = `<xml>${categoriesXml}</xml>`;
            // Update the workspace if it exists
            if (this.workspace) {
                try {
                    this.workspace.updateToolbox(xml);
                } catch (e) {} // Ignore toolbox loading errors
            }
            return xml;
        },
        /**
         * Remove every block in the workspace
         */
        clearWorkspace () {
            if (!this.workspace) {
                return;
            }
            this.workspace.clear();
        },
        /**
         * Update the code on any blockly change and
         * bubble up the event
         * @param  {Event} e    A Blockly event
         * @return {[type]}   [description]
         */
        onBlocklyChange (e) {
            this.fire('change', e);
            this.set('code', this.getCode('JavaScript'));
        },
        /**
         * Generate a XML string representation of the blocks
         * currently on the workspace
         * @return {String}     XML string representation of the blocks
         */
        getBlocks () {
            let xml = Blockly.Xml.workspaceToDom(this.workspace),
                xmlString = Blockly.Xml.domToText(xml);
            return xmlString;
        },
        /**
         * Compute the current code for a given language
         * @param  {String} type Language to use to compute the code
         * @return {String}      A piece of code
         */
        getCode (type) {
            try {
                return Blockly[type].workspaceToCode(this.workspace);
            } catch (e) {
                return '';
            }
        },
        save () {
            let javascript = this.getCode('JavaScript'),
                pseudo = this.getCode('Pseudo'),
                blocks = this.getBlocks(),
                snapshot = {
                javascript,
                pseudo,
                blocks
            };
            this.set('snapshot', snapshot);
            return Promise.resolve(snapshot);
        },
        load (snapshot = {}) {
            // Defer the load until the workspace exists
            if (!this.workspace) {
                return this.addEventListener('blockly-ready', this.load.bind(this, snapshot));
            }
            if (!snapshot.blocks) {
                return;
            }
            let blocks = snapshot.blocks || '<xml></xml>';
            let xml = Blockly.Xml.textToDom(blocks);
            this.clearWorkspace();
            try {
                Blockly.Xml.domToWorkspace(xml, this.workspace);
            } catch (e) {} // Ignore loading errors
        },
        getScreenshot () {
            return new Promise((resolve) => {
                let svg = this.$$('svg'),
                    canvas = document.createElement('canvas'),
                    ctx = canvas.getContext('2d'),
                    loader = new Image(),
                    svgAsXML = (new XMLSerializer()).serializeToString(svg),
                    rect = this.getBoundingClientRect(),
                    offsetX = rect.width / 2;

                loader.width = rect.width;
                loader.height = rect.height;
                canvas.width = loader.width - offsetX;
                canvas.height = loader.height;
                loader.onload = () => {
                    ctx.drawImage(loader, offsetX, 0, canvas.width, loader.height, 0, 0, canvas.width, canvas.height);
                    resolve(canvas.toDataURL());
                };
                loader.src = 'data:image/svg+xml,' + encodeURIComponent(svgAsXML);
            });
        },
        getWorkspace () {
            return this.workspace;
        }
    });
</script>
