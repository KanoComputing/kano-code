<dom-module id="kano-blockly-challenge">
    <style>
    :host {
        display: block;
        @apply(--layout-vertical);
    }
    :host .instruction-overlay {
        @apply(--layout-vertical);
        @apply(--layout-center);
    }
    :host content {
        @apply(--layout-flex);
    }
    </style>
    <template>
        <div class="instruction-overlay">
            <h3>{{instruction}}</h3>
        </div>
        <content select=".blockly" id="content"></content>
    </template>
</dom-module>

<script type="text/javascript">
    class KanoBlocklyChallenge {
        beforeRegister () {
            this.is = 'kano-blockly-challenge';
            this.properties = {
                step: {
                    type: Number,
                    value: 0
                },
                steps: {
                    type: Array,
                    value: () => []
                },
                instruction: {
                    type: String,
                    computed: 'computeInstruction(step, steps.*, done)',
                    readOnly: true
                },
                done: {
                    type: Boolean,
                    value: false
                }
            };
        }
        /**
         * Find the blockly element and listens to the change event
         */
        attached () {
            this.stepIds = {};
            let node = Polymer.dom(this.$.content).getDistributedNodes()[0];
            node.addEventListener('change', this.blocklyChanged.bind(this));
        }
        /**
         * Get the instruction to display
         */
        computeInstruction () {
            if (!this.steps[this.step]) {
                return;
            }
            return this.done ? 'Done' : this.steps[this.step].instruction;
        }
        /**
         * Try to match the blockly event to the current step
         * @param  {Event} e  A blockyl change event
         */
        blocklyChanged (e) {
            // Store current step object
            let step = this.steps[this.step];
            // Check the 'create' case. We are waiting for a Create Blockly event
            if (step.validation.create && e.detail instanceof Blockly.Events.Create) {
                let validation = step.validation.create,
                    type;
                // Use the type or the value directly
                // Allows to declare shorthand creation as:
                // create: 'text'
                // or
                // create: {
                //     type: 'text'
                // }
                if (typeof validation === 'string') {
                    type = validation;
                } else if (validation.type) {
                    type = validation.type;
                } else {
                    return;
                }
                // Check the type of the added block
                if (e.detail.xml.getAttribute('type') === type) {
                    // The new block created is added to the step, using its
                    // step id for further reference
                    this.stepIds[validation.id] = e.detail.blockId;
                    this.nextStep();
                }
            // Check the 'connect' case> We are waiting for a Move Blockly event
            } else if (step.validation.connect && e.detail instanceof Blockly.Events.Move) {
                // Extract the validation object, target and parent step ids and
                // the block moved
                let validation = step.validation.connect,
                    targetId = this.stepIds[validation.target],
                    parentId = this.stepIds[validation.parent],
                    block = e.detail;
                // Check that the element moved is the one targeted and that its
                // new parent is the right one
                if (block.blockId === targetId && block.newParentId === parentId) {
                    this.nextStep();
                }
            // Check the 'value' case. We are waiting for a Change Blockly event
            } else if (step.validation.value &&
                        e.detail instanceof Blockly.Events.Change) {
                let validation = step.validation.value,
                    targetId = this.stepIds[validation.target],
                    block = e.detail,
                    failed = false;
                // Check that the element that changed is the one we target
                if (block.blockId === targetId) {
                    if (validation.minLength &&
                            block.newValue.length &&
                            block.newValue.length < validation.minLength) {
                        failed = true;
                    }
                    // Check that
                    // the value is set to the one we expect
                    // We use the double equal to be sure we catch Number/String
                    // parsing
                    if (validation.value && block.newValue != validation.value) {
                        failed = true;
                    }
                    if (!failed) {
                        this.nextStep();
                    }
                }
            }
        }
        /**
         * Move to the next step or set the challenge as done
         */
        nextStep () {
            if (this.step < this.steps.length - 1) {
                this.step++;
            } else {
                this.set('done', true);
                this.fire('done');
            }
        }
    }
    Polymer(KanoBlocklyChallenge);
</script>
