<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../behaviors/kano-scene-component-behavior.html">
<link rel="import" href="../behaviors/kano-editor-view-behavior.html">
<link rel="import" href="../behaviors/kano-i18n-behavior.html">
<link rel="import" href="../kano-challenge-completed-modal/kano-challenge-completed-modal.html">
<link rel="import" href="../kano-app-challenge/kano-app-challenge.html">
<link rel="import" href="../kano-app-editor/kano-app-editor.html">
<link rel="import" href="../kano-editor-banner/kano-editor-banner.html">
<link rel="import" href="../kano-editor-topbar/kano-editor-topbar.html">
<dom-module id="kano-scene-editor">
    <style>
        :host {
          display: block;
          @apply(--layout-vertical);
        }
        :host kano-app-challenge {
            @apply(--layout-flex);
        }
        :host kano-app-editor {
            @apply(--layout-flex);
        }
        kano-editor-banner {
            background: #394148;
            color: white;
            border-bottom: 1px solid var(--kano-app-editor-workspace-border, #22272d);
            height: 82px;
        }
        .bolt {
            background: black;
            width: 11px;
            height: 11px;
            margin: 3px 4px;
            border-radius: 2px;
            padding: 3px;
        }
        .progress {
            position: relative;
            color: white;
            background: #32393F;
            height: 22px;
            border-top: 1px solid var(--kano-app-editor-workspace-border, #22272d);
        }
        .progress .bar {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 100%;
            background: #e4e6e7;
            opacity: 0.4;
            transition: transform 200ms ease-out;
        }
        .progress .bar-content {
            position: absolute;
            @apply --layout-horizontal;
        }
        .progress .story-name {
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            margin-top: 2px;
        }
    </style>
    <template>
        <kano-app-challenge id="challenge"
                            steps="[[scene.steps]]"
                            on-save="saveApp"
                            on-save-to-storage="saveToStorage"
                            on-load="loadApp"
                            step="{{currentStep}}"
                            started="[[scene.started]]"
                            hint-stats="{{hintStats}}"
                            selected-step="{{selectedStep}}"
                            state="{{state}}"
                            scene-variables="{{sceneVariables}}"
                            hints="{{hints}}">
            <kano-app-editor id="editor"
                             added-parts="{{addedParts}}"
                             parts="[[parts]]"
                             default-categories="[[categories]]"
                             slot="editor"
                             running="{{running}}"
                             code="{{code}}"
                             mode="[[mode]]"
                             on-share="_pauseAndShare"
                             on-lockdown-clicked="_notifyBanner"
                             hide-leave-alert="[[alertDisabled]]">
                <div slot="above-code">
                    <kano-editor-topbar exit-url="[[exitUrl]]" user="[[user]]" profile="[[user.profile]]"></kano-editor-topbar>
                    <kano-editor-banner id="banner"
                                       head="[[banner.head]]"
                                       text="[[banner.text]]"
                                       img-src="[[banner.icon]]"
                                       img-page="[[banner.imgPage]]"
                                       show-button="[[banner.showButton]]"
                                       button-label="[[banner.buttonLabel]]"
                                       is-last="[[banner.isLast]]"
                                       on-button-tapped="_bannerButtonTapped"></kano-editor-banner>
                </div>
                <div class="progress" slot="under-code">
                    <div class="bar" id="bar"></div>
                    <div class="bar-content">
                        <iron-icon class="bolt" src="/assets/icons/lightning.svg"></iron-icon>
                        <div class="story-name">[[story.name]]</div>
                    </div>
                </div>
            </kano-app-editor>
        </kano-app-challenge>
   </template>
</dom-module>
<script type="text/javascript">

    /* globals Polymer, Kano */

    const BANNER_ICONS = {
        'default': '/assets/avatar/judoka-face.svg'
    };

    Polymer({
        is: 'kano-scene-editor',
        behaviors: [
            Kano.Behaviors.EditorViewBehavior,
            Kano.Behaviors.SceneComponentBehavior,
            Kano.Behaviors.SoundPlayerBehavior,
            Kano.Behaviors.I18nBehavior
        ],
        properties: {
            story: {
                type: Object,
                value: () => {
                    return {};
                }
            },
            currentStep: {
                type: Number,
                notify: true
            },
            scene: {
                type: Object
            },
            progress: {
                type: Number,
                computed: 'computeProgress(currentStep, scene)',
                observer: '_progressChanged'
            },
            addedParts: {
                type: Array,
                notify: true
            },
            remix: {
                type: Boolean,
                observer: '_remixChanged'
            },
            sceneVariables: {
                type: Object,
                computed: '_computeSceneVariables(categories)'
            },
            hintStats: {
                type: Object,
                notify: true
            },
            state: {
                type: Object,
                value: () => {
                    return {
                        hints: {
                            enabled: true
                        }
                    };
                }
            }
        },
        observers: [
            '_sceneChanged(scene)',
            '_selectedStepChanged(selectedStep)',
            '_completedChanged(scene.completed)',
            '_addedPartsChanged(addedParts.splices)'
        ],
        forceReloadStep () {
            this.$.challenge.forceReloadStep();
        },
        _selectedStepChanged (step) {
            if (!step && !this.modeReady) {
                return;
            }
            this.computeBanner(step);
        },
        _progressChanged (progress) {
            this.transform(`translateX(-${100 - progress * 100}%)`, this.$.bar);
            this.$.bar.animate({
                opacity: [0.4, 1, 0.4]
            }, {
                duration: 1200,
                easing: 'ease-in-out'
            });
        },
        _computeSceneVariables (categories) {
            let sceneVariables = {};
            Object.keys(categories).forEach((key) => {
                sceneVariables[`${key}_color`] = categories[key].colour;
            });
            return sceneVariables;
        },
        computeBanner (step) {
            let iconId, animation;
            clearTimeout(this.showButtonTimeout);
            this.debounce('banner', () => {
                this.set('banner', null);
                if (this.state.hints.enabled) {
                    if (step.banner) {
                        let label = (step.banner.buttonLabel || this.localize('NEXT', 'Next'));
                        this.banner = this.banner || {};
                        this.set('banner.head', step.banner.head);
                        this.set('banner.text', step.banner.text);
                        this.set('banner.buttonLabel', step.banner.next_button ? label : null);
                        this.set('banner.showButton', !!this.banner.buttonLabel);
                    } else {
                        this.banner = null;
                    }
                } else {
                    let bannerProps = this.state.hints['disabled-banner'];
                    if (bannerProps) {
                        this.banner = this.banner || {};
                        this.set('banner.head', bannerProps.head);
                        this.set('banner.text', bannerProps.text);
                        this.set('banner.buttonLabel', this.localize('HINTS', 'Hints'));
                        this.showButtonTimeout = setTimeout(() => {
                            this.set('banner.showButton', true);
                        }, 6000);
                    } else {
                        this.banner = null;
                    }
                }
                if (this.banner) {
                    if (step.banner) {

                        this.$.editor.set('lockdown', step.banner.lockdown);    //restrict click events if true
                        this.set('banner.isLast', step.isLast);

                        if (step.isLast) {
                            this.set('banner.icon', null);
                            this.set('banner.imgPage', 'star');
                            this.set('banner.buttonLabel', Boolean(this.story.next) ?
                                    this.localize('NEXT_CHALLENGE', 'Next Challenge') : this.localize('BACK_TO_CHALLENGES', 'Back to Challenges'));
                        } else if (step.banner.animation) {
                            animation = step.banner.animation;
                            this.set('banner.imgPage', animation);
                            this.set('banner.icon', null);
                        } else if (step.banner.icon) {
                            iconId = step.banner.icon;
                            this.set('banner.icon', BANNER_ICONS[iconId]);
                            this.set('banner.imgPage', null);
                        } else {
                            this.set('banner.icon', null);
                            this.set('banner.imgPage', 'judoka');
                        }
                    } else {
                        //TODO quickfix for demo. Needs to be removed.
                        this.set('banner.icon', null);
                        this.set('banner.imgPage', 'judoka');
                    }
                }
            }, 200);
        },
        _bannerButtonTapped () {
            if (this.selectedStep.isLast) {
                Kano.MakeApps.Utils.onLine().then((isOnline) => {
                    if (!this.user || this.user.hasSharedInSession || this._userAlreadyShared(this.story) ||
                            this.scene.autoshareDisabled || !isOnline) {
                        this.fire('next-story');
                    } else {
                        const shareDetail = this.$.editor.compileApp();
                        shareDetail.title = `${this.user.username}'s ${this.story.name}`;
                        shareDetail.autoshare = true;
                        this.scene.autoshareDisabled = true;

                        this.running = false;
                        this.fire('share', shareDetail);
                    }
                });
            } else if (this.state.hints && this.state.hints.enabled) {
                this.$.challenge.nextStep();
            } else {
                this.showHints();
            }
        },
        _userAlreadyShared (story) {
            const progress = this._getUserProgress(this.user);
            return progress.indexOf(story.id) > -1;
        },
        _getUserProgress (user) {
            let groups = this._getProgressGroups(user),
                stories = [];
            if (groups) {
                Object.keys(groups).forEach(key => {
                    stories = stories.concat(groups[key].completedStories);
                });
            }
            return stories;
        },
        _getProgressGroups (user) {
            return user && user.profile && user.profile.stats['make-apps'] &&
                    user.profile.stats['make-apps'].progress || null;
        },
        showHints () {
            this.set('banner', null);
            this.computeBanner(this.selectedStep);
            this.set('state.hints', { enabled: true });
            this.$.challenge.hintUsed();
        },
        _pauseAndShare (e) {
            this.running = false;
            this.fire('share', e.detail);
            e.preventDefault();
            e.stopPropagation();
        },
        _remixChanged (remix) {
            if (remix) {
                this._computeMode();
                this._computeCategories();
                this._computeParts();
                // Look for the previously removed blocks in the addedParts
                this.addedParts.forEach((part, i) => {
                    // Some blocks were removed, we need to add them back
                    if (part.removedBlocks) {
                        // Go through all the removed blocks and inject them back in the blocks array
                        Object.keys(part.removedBlocks).forEach(index => {
                            this.splice(`addedParts.${i}.blocks`, index, 0, part.removedBlocks[index]);
                        });
                        delete part.removedBlocks;
                    }
                });
            }
        },
        /**
         * Observes the `addedParts` array. Goes through the added splice and removes the blocks from a part if needed.
         * Stores the removed blocks in a `removedBlocks` object for future re-injection
         */
        _addedPartsChanged (e) {
            if (!e || this.remix || !this.scene.filterBlocks) {
                return;
            }
            e.indexSplices.forEach(splice => {
                splice.object.forEach(part => {
                    Object.keys(this.scene.filterBlocks).forEach(key => {
                        if (part.id !== key) {
                            return;
                        }
                        part.blocks = part.blocks.filter((block, index) => {
                            let definition = block.block(part),
                                remove = this.scene.filterBlocks[key].indexOf(definition.id) === -1;
                            // We're about to remove the block from the part. Save it under another object to
                            // be able to inject it back later
                            if (remove) {
                                part.removedBlocks = part.removedBlocks || {};
                                part.removedBlocks[index] = block;
                            }
                            return !remove;
                        });
                    });
                });
            });
        },
        _onModeReady () {
            Kano.Behaviors.EditorViewBehavior._onModeReady.apply(this, arguments);
            this._computeMode();
            this._computeCategories();
            this._computeParts();
            this._loadVariables();
            this.currentStep = 0;
            this.async(() => {
                this._loadDefaultApp();
            });
        },
        _sceneChanged () {
            this._loadVariables();
            //async for correct data-binding with child element
            this.async(this.resetHints, 0);
        },
        _loadVariables () {
            let workspace = this.$.editor.getBlocklyWorkspace();
            if (this.scene && this.scene.variables && workspace) {
                this.scene.variables.forEach((v) => {
                    Blockly.Variables.addVariable(v, workspace);
                });
            }
        },
        _loadDefaultApp () {
            let editor = this.$.editor;
            if (this.scene && this.scene.defaultApp) {
                editor.load(JSON.parse(this.scene.defaultApp), Kano.MakeApps.Parts.list);
            }
        },
        _completedChanged (completed) {
            if (completed) {
                this.remix = true;
                this.$.editor.generateCover().then((image) => {
                    this.appPreview = image.src;
                });
            //don't alert user on leaving if it's the last story
            } else if (completed && !this.story.next) {
                this.alertDisabled = true;
            }
        },
        computeProgress (currentStep, scene) {
            if (currentStep < 0) {
                return 1;
            }
            return (currentStep + 1) / scene.steps.length;
        },
        resetHints () {
            this.set('hints.total', 0);
            this.set('hints.used', 0);
        },
        ready () {
            this.remix = false;
            this.code = {};

            this.debounce('saveApp', () => {
                this.editor = this.$.editor;
                this.editor.addEventListener('change', (e) => {
                    this.saveApp(e);
                });
            }, 300);
        },
        attached () {
            this.mode = Kano.MakeApps.Mode.modes[(this.scene.mode || 'normal')];
        },
        shareApp () {
            this.$.editor.share();
        },
        _computeParts () {
            if (this.remix) {
                this.parts = Kano.MakeApps.Parts.list.filter((part) => {
                    return this.mode.parts.indexOf(part.type) !== -1;
                });
            } else {
                this.parts = Kano.MakeApps.Parts.list.filter(part => this.scene.parts.indexOf(part.type) !== -1);
            }
        },
        /**
         * Compute the categories that will be used in this challenge. Takes care of filtering the
         * categories and blocks that will not be used. Resets everything when the users enters remix mode
         */
        _computeCategories () {
            let cats = {},
                cat;
            if (this.remix) {
                cats = Kano.MakeApps.Blockly.categories;
            } else {
                this.scene.modules.forEach(id => {
                    // Clone the object, because we might change its blocks
                    cats[id] = Object.assign({}, Kano.MakeApps.Blockly.categories[id]);
                });
                cats.events = Object.assign({}, Kano.MakeApps.Blockly.categories.events);

                // Do not filter blocks if the list is not defined
                if (this.scene.filterBlocks) {
                    // Remove the excluded blocks from the categories
                    Object.keys(this.scene.filterBlocks).forEach(catId => {
                        cat = cats[catId];
                        if (!cat) {
                            return;
                        }
                        cat.blocks = cat.blocks.filter(block => this.scene.filterBlocks[catId].indexOf(block.id) !== -1);
                    });
                }
            }
            this.categories = cats;
        },
        _computeMode () {
            let mode = this.mode;
            if (this.remix) {
                if (mode.originalCategories) {
                    this.set('mode.categories', mode.originalCategories);
                    delete mode.originalCategories;
                }
            } else if (this.scene.filterBlocks) {
                let whitelist = this.scene.filterBlocks[mode.id];
                if (whitelist) {
                    this.set('mode.originalCategories', mode.categories.slice(0));
                    this.mode.categories.forEach((category, index) => {
                        /* Poor man's way of deep-copying categories into originalCategories */
                        this.set(`mode.originalCategories.${index}`, Object.assign({}, category));
                        this.set(`mode.originalCategories.${index}.blocks`, category.blocks.slice(0));

                        this.set(`mode.categories.${index}.blocks`, category.blocks.filter(block => {
                            let definition = block.block(mode);
                            return whitelist.indexOf(definition.id) !== -1;
                        }));
                    });
                }
            }
        },
        saveApp (e) {
            let id = e.detail.id || 'current',
                blockIds = e.detail.blockIds,
                stepIds = e.detail.stepIds,
                app = this.$.editor.save(true, false);
            this.addToStore(id, {
                app,
                blockIds,
                stepIds
            });
        },
        saveToStorage () {
            let app = this.$.editor.save();
            localStorage.setItem('savedApp', JSON.stringify(app));
        },
        loadApp (e) {
            let id = e.detail,
                savedState,
                challenge;
            savedState = this.fromStore(id);
            challenge = this.$.challenge;
            this.$.editor.load(savedState.app, this._computeParts());
            challenge.set('stepIds', savedState.stepIds);
            challenge.set('blockIds', savedState.blockIds);
        },
        powerUp (e) {
            let extensionId = e.detail.id;
            this.fire('extend-story', extensionId);
            e.stopPropagation();
        },
        _runningChanged () {
            if (!this.scene.started) {
                return;
            }
            Kano.Behaviors.EditorViewBehavior._runningChanged.apply(this, arguments);
        },
        _notifyBanner () {
            this.$.banner.animateButton();
        }
    });
</script>
