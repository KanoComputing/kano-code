<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/kwc-blockly/kwc-blockly-style.html">
<link rel="import" href="../blockly.html">
<link rel="import" href="../kano-blockly/kano-blockly-style.html">
<dom-module id="kano-blockly-block">
    <template>
        <style include="kwc-blockly-style"></style>
        <style>
            :host {
                display: block;
                pointer-events: none;
            }
            svg path.blocklyPathDark, svg path.blocklyPathLight {
                display: none;
            }
            svg text.blocklyText {
                fill: white;
            }
            svg g.blocklyEditableText {
                fill: white;
                fill-opacity: 0.6;
            }
            svg .blocklyEditableText text.blocklyText {
                fill: black;
                font-size: 16px;
            }
        </style>
        <svg xmlns="http://www.w3.org/2000/svg" id="svg"></svg>
    </template>
    <script type="text/javascript">
        Polymer({
            is: 'kano-blockly-block',
            properties: {
                type: {
                    type: String,
                    observer: '_typeChanged'
                }
            },
            _createWorskspace () {
                this.ws = new Blockly.WorkspaceSvg({});
                this.ws.isFlyout = true;
                this.wsDom = this.ws.createDom();
                this.transform('translate(10px, 0px)', this.wsDom);
                this.$.svg.appendChild(this.wsDom);
            },
            _typeChanged (type) {
                if (!this.ws) {
                    this._createWorskspace();
                }
                let catId = Kano.MakeApps.Blockly.Defaults.categoryMap[type],
                    cat, colour, xml, extraArgs = '';
                if (catId) {
                    cat = Kano.MakeApps.Blockly.modules[catId];
                    if (cat) {
                        colour = cat.category.colour;
                        extraArgs += `colour="${colour}"`;
                    }
                }
                xml = Blockly.Xml.textToDom(`<xml><block type="${type}" ${extraArgs}></block></xml>`);
                this.ws.clear();
                this.ws.scale = 0.9;
                this.async(() => {
                    try {
                        Blockly.Xml.domToWorkspace(xml, this.ws);
                    } catch (e) {} // Ignore loading errors
                    this._updateSvgSize();
                });
            },
            _updateSvgSize () {
                let rect = this.wsDom.getBoundingClientRect();
                this.$.svg.style.width = `${rect.width + 10}px`;
                this.$.svg.style.height = `${rect.height}px`;
            },
            getBlock () {
                return this.ws.getAllBlocks()[0];
            },
            detached () {
                if (this.ws) {
                    this.ws.dispose();
                }
            }
        });
    </script>
</dom-module>
