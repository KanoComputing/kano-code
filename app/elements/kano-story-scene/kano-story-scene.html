<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../kano-scene-editor/kano-scene-editor.html">
<link rel="import" href="../kano-scene-challenge-overlay/kano-scene-challenge-overlay.html">
<dom-module id="kano-story-scene">
    <style>
    :host {
        display: block;
        position: relative;
        @apply(--layout-vertical);
        overflow: hidden;
    }
    .scene, .overlay {
        @apply(--layout-flex);
        @apply(--layout-vertical);
    }
    .scene>*, .overlay>* {
        @apply(--layout-flex);
    }
    .overlay {
        position: absolute;
        top: 0px;
        bottom: 0px;
        left: 0px;
        right: 0px;
    }
    *[hidden] {
        display: none !important;
    }
    </style>
    <template>
        <iron-lazy-pages class="scene" attr-for-selected="name" selected="[[name]]" restamp>
            <template is="iron-lazy-page" name="editor">
                <kano-scene-editor store="{{store}}" story-name="[[storyName]]" scene="[[scene]]" extensions="[[extensions]]" on-scene-done="sceneFinished"></kano-scene-editor>
            </template>
        </iron-lazy-pages>
        <iron-lazy-pages class="overlay" attr-for-selected="name" selected="[[overlayName]]" restamp hidden$="[[overlayHidden]]">
            <template is="iron-lazy-page" name="challenge-overlay">
                <kano-scene-challenge-overlay id="overlay" scene="[[overlayScene]]"></kano-scene-challenge-overlay>
            </template>
        </iron-lazy-pages>
    </template>
</dom-module>
<script type="text/javascript">
    /* globals Polymer */

    Polymer({
        is: 'kano-story-scene',
        properties: {
            scene: {
                type: Object,
                value: () => {
                    return {};
                }
            },
            storyName: {
                type: String,
                value: ''
            },
            nextStory: {
                type: Object
            },
            location: {
                type: String
            },
            name: {
                type: String
            },
            attributes: {
                type: Object
            },
            store: {
                type: Object,
                value: () => {
                    return {};
                }
            },
            extensions: {
                type: Array
            }
        },
        observers: [
            'componentChanged(scene.component)',
            'extensionsChanged(extensions.*)'
        ],
        listeners: {
            'overlay-done': 'overlayDone'
        },
        extensionsChanged(e) {
            this.set(`attributes.${e.path}`, e.value);
        },
        ready () {
            this.overlayDone = this.overlayDone.bind(this);
            this.overlayHidden = true;
        },
        sceneFinished (e) {
            if (this.scene.overlay_after) {
                e.stopPropagation();
                this.setupOverlay(this.scene.overlay_after);
            } else if (this.scene.show_remix_options) {
                this.set('scene.ended', true);
            }
        },
        componentChanged () {
            let scene = this.scene,
                pieces,
                name,
                loc;
            if (!scene.component && !scene.load) {
                return;
            }
            this.setupOverlay(scene.overlay_before);
            // Cut using '/'
            pieces = scene.component.split('/');
            // Extract the last piece
            name = pieces.pop();
            // Join back the first pieces to get the location
            loc = pieces.join('/');
            this.scene = Object.assign({}, scene.data);
            // Let the end of the overlay load the data
            if (!this.scene.overlay_before) {
                this.set('scene.started', true);
            }
            this.set('name', name);
        },
        overlayDone () {
            let started = false;
            console.log(this.scene);
            if (!this.beforeDone && this.scene.overlay_before) {
                this.beforeDone = true;
                started = true;
            } else if (this.scene.overlay_after) {
                if (this.scene.show_remix_options) {
                    this.set('scene.ended', true);
                }
                this.fire('scene-done');
            }
            this.$$('#overlay').end().then(() => {
                this.overlayHidden = true;
                if (started) {
                    this.set('scene.started', true);
                }
            });
        },
        setupOverlay (overlayConfig) {
            let pieces,
                name;
            if (!overlayConfig || !overlayConfig.component) {
                return;
            }
            // Cut using '/'
            pieces = overlayConfig.component.split('/');
            // Extract the last piece
            name = pieces.pop();
            this.set('overlayName', name);
            this.set('overlayScene', overlayConfig.data);
            this.overlayHidden = false;
        }
    });
</script>
