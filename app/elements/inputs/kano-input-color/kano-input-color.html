<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../behaviors.html">
<link rel="import" href="../../kano-color-wheel/kano-color-wheel.html">
<link rel="import" href="../../kano-tooltip/kano-tooltip.html">
<link rel="import" href="../../kano-icons/kc-ui.html">
<link rel="import" href="../../kano-code-shared-styles/kano-code-shared-styles.html">
<!--
`kano-input-color` Display a color palette and allows selection by clicking on one of them

Example:
    <kano-input-color value="{{value}}"></kano-input-color>

@group Kano Elements
@hero hero.svg
@demo ./demo/kano-input-color.html

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--kano-color-input-field` | Mixin for the input field | {}
`--kano-input-color-size` | Size of a single color field | 29px
`--kano-input-color-margin` | Size of margin around a color field | 2px
`--kano-input-color-background` | Background color on host | 'transparent'
-->
<dom-module id="kano-input-color">
    <style include="kano-code-shared-styles">
    :host {
        display: block;
    }
    label {
        @apply --kano-part-editor-label;
    }
    #input-field {
        cursor: pointer;
        margin: 0 auto;
        @apply --kano-color-input-field;
    }
    #colors {
        @apply --layout-horizontal;
        @apply --layout-wrap;
        position: relative;
    }
    #select-frame {
        @apply --layout-horizontal;
        @apply --layout-center-justified;
        @apply --layout-center;
        position: absolute;
        top: calc(var(--kano-input-color-margin, 0.5px) * -2);
        left: calc(var(--kano-input-color-margin, 0.5px) * -2);
        width: var(--kano-input-color-size, 32px);
        height: var(--kano-input-color-size, 32px);
        z-index: 3;
        outline: 3px solid #bbb;
        outline-offset: -1px;
        margin: var(--kano-input-color-margin, 0.5px);
    }
    :host(.animate) #select-frame {
        transition: transform 200ms linear;
    }
    #tick {
        transition: opacity 200ms linear;
    }
    .color {
        width: var(--kano-input-color-size, 32px);
        height: var(--kano-input-color-size, 32px);
        margin: var(--kano-input-color-margin, 0.5px);
        transition: transform 150ms;
        outline-offset: -1px;
        box-sizing: border-box;
    }
    iron-icon {
        --iron-icon-height: calc(var(--kano-input-color-size, 32px) / 1.5);
        --iron-icon-width: calc(var(--kano-input-color-size, 32px) / 1.5);
        fill: #fff;
    }
    [hidden] {
        display: none !important;
    }
    </style>
    <template>
        <label hidden$="[[!label]]">[[label]]</label>
        <div id="input-field">
            <div id="colors" data-animate="450">
                <div id="select-frame" hidden$="[[_hideSelectFrame(colors.*, idle)]]">
                    <iron-icon id="tick" icon="kc-ui:tick"></iron-icon>
                </div>
                <template id="palette" is="dom-repeat" items="{{colors}}" as="color">
                    <div id$="color-[[index]]" class="color" style$="[[_computeColor(color)]]" on-tap="_doSelectColor" on-mouseenter="_hoverOn" on-mouseleave="_hoverOff"></div>
                </template>
            </div>
        </div>
    </template>
</dom-module>
<script type="text/javascript">

    Polymer({
        is: 'kano-input-color',
        behaviors: [
            Kano.Behaviors.Input
        ],
        properties: {
            colors: {
                type: Array,
                value: () => [
                    '#ffffff',  // White
                    '#000000',  // Black
                    '#e95c5a',  // Red
                    '#ff842a',  // Kano Orange
                    '#f8eb1e',  // Yellow
                    '#3caa36',  // Green
                    '#0e6633',  // Dark Green
                    '#59b3d0',  // Light Blue
                    '#2a3080',  // Dark Blue
                    '#642682',  // Violet
                    '#db7d92',  // Pink
                    '#683d12'   // Brown
                ]
            },
            value: {
                type: String,
                notify: true
            },
            rowSize: {
                type: Number,
                value: 12
            },
            selectedIndex: {
                type: Number,
                observer: 'selectColor'
            },
            idle: {
                type: Boolean,
                value: false
            }
        },
        observers: [
            '_onIdleChanged(idle, frame)',
            '_updateSelected(colors.splices)',
            '_setSize(rowSize, isAttached)'
        ],
        attached () {
            if (!this.idle) {
                if (this.value) {
                    this.set('selectedIndex', this.getIndexByValue(this.value));
                } else {
                    this.set('selectedIndex', 0);
                }
            }
            this.frame = this.$['select-frame'];
        },
        getIndexByValue (value) {
            return Math.max(0, this.colors.indexOf(value));
        },
        getBrightness (hexCode) {
            let r, g, b;
            hexCode = hexCode.replace('#', '');

            r = parseInt(hexCode.substr(0, 2),16);
            g = parseInt(hexCode.substr(2, 2),16);
            b = parseInt(hexCode.substr(4, 2),16);

            return ((r * 299) + (g * 587) + (b * 114)) / 1000;
        },
        _highlight (index) {
            const target = this.$$(`#color-${index}`);
            let brightness;

            if (target) {
                this.transform(`translate(${target.offsetLeft}px, ${target.offsetTop}px)`, this.frame);
                this._animateIcon();
                brightness = this.getBrightness(this.colors[index]);
                this.frame.style['outline-color'] = this.$.tick.style.fill = brightness > 230 ? '#bbb' : '#fff';
                // The first value was just set, enable the frame animation from now on
                if (!this.firstValueSet) {
                    this.firstValueSet = true;
                    // Let the current transform be applied before enabling animations
                    Polymer.RenderStatus.afterNextRender(this, () => {
                        this.toggleClass('animate', true);
                    });
                }
            }
        },
        _onIdleChanged (idle, wasIdle) {
            if (idle) {
                this.selectedIndex = this.value = null;
                this.frame.style.transition = `none`;
            } else if (!idle && wasIdle) {
                //reapply transition only after the frame is visible again
                this.async(() => this.frame.style.transition = `transform 200ms`, 10);
            }
        },
        _setSize (rowSize, isAttached) {
            if (!isAttached) {
                return;
            }
            const colorSize = this.getComputedStyleValue('--kano-input-color-size') || '32px',
                margin = this.getComputedStyleValue('--kano-input-color-margin') || '0.5px';
            this.$['input-field'].style.width = `${(parseFloat(colorSize, 10) + 2 *
                    parseFloat(margin, 10)) * this.rowSize}px`;

        },
        addColor (color) {
            if (/^#[0-9A-F]{6}$/i.test(color)) {
                this.push('colors', color);
                this.selectedIndex = this.colors.length - 1;
            }
        },
        _hoverOn (e) {
            const target = e.currentTarget ? e.currentTarget : Polymer.dom(e).rootTarget,
                color = this.$.palette.modelForElement(target).get('color'),
                index = this.$.palette.indexForElement(target);
            
            let brightness;

            if (index !== this.selectedIndex) {
                brightness = this.getBrightness(color);
                target.style.outline = '3px solid #fff';
                target.style['z-index'] = '2';
                target.style['outline-color'] = brightness > 230 ? '#bbb' : '#fff';
            }
        },
        _hoverOff (e) {
            const target = e.currentTarget ? e.currentTarget : Polymer.dom(e).rootTarget;
            target.style['z-index'] = '0';
            target.style.outline = 'none';
        },
        removeColor (index) {
            this.splice('colors', index, 1);
            this.selectedIndex = this.colors.length ? this.selectedIndex - 1 : null;
        },
        _computeColor (color, value) {
            return `background-color: ${color};`;
        },
        _updateSelected () {
            this.selectedIndex = this.selectedIndex === 0 ? this.selectedIndex : this.selectedIndex - 1;
        },
        _doSelectColor (e) {
            const target = e.currentTarget ? e.currentTarget : Polymer.dom(e).rootTarget;
            this.selectedIndex = this.$.palette.indexForElement(target);
        },
        selectColor (index) {
            if (typeof index !== 'number') {
                return;
            }
            this.set('value', this.colors[index]);
            this.fire('change', this.value);
            this.async(() => this._highlight(index));
        },
        _hideSelectFrame () {
            return !this.colors || !this.colors.length || this.idle;
        },
        _animateIcon () {
            this.$.tick.animate({
                opacity: [0, 1]
            }, {
                duration: 300,
                easing: 'ease-in-out'
            });
        },
        getColorField () {
            return this.$.colors;
        }
    });
</script>
