<link rel="import" href="../behaviors/kano-emitter-behavior.html">
<script type="text/javascript">


window.Kano = window.Kano || {};

window.Kano.Behaviors = window.Kano.Behaviors || {};

/**
 * Behavior common to all UI components
 * Adds the style object that can be used to give the user
 * customization features
 * @type {Object}
 */
window.Kano.Behaviors.UIBehavior = {
    properties: {
        model: {
            type: Object,
            notify: true
        },
        isRunning: {
            type: Boolean,
            value: false
        },
        autoStart: {
            type: Boolean,
            value: false
        }
    },
    observers: [
        'applyTransform(model.*)'
    ],
    listeners: {
        'tap': 'onTap'
    },
    onTap () {
        if (!this.isRunning) {
            this.fire('part-tapped', this);
        }
    },
    attached () {
        this.fire('ui-ready', this);
        if (this.autoStart) {
            this.start();
        }
    },
    getPartialStyle (attrs) {
        if (!this.model) {
            return '';
        }
        attrs = attrs || Object.keys(this.model.userStyle);
        return attrs.reduce((acc, key) => {
            acc += this.model.userStyle && this.model.userStyle[key] ? `${key}:${this.model.userStyle[key]};` : '';
            return acc;
        }, '');
    },
    start () {
        this.savedState = {
            position: {
                x: this.model.position.x,
                y: this.model.position.y
            },
            rotation: this.model.rotation,
            scale: this.model.scale,
            visible: this.model.visible,
            userProperties: Object.assign({}, this.model.userProperties),
            userStyle: Object.assign({}, this.model.userStyle)
        };
        this.isRunning = true;
    },
    stop () {
        let savedState = this.savedState || {};
        savedState.position = savedState.position || { x: 0, y: 0 };
        this.set('model.position.x', savedState.position.x);
        this.set('model.position.y', savedState.position.y);
        this.set('model.rotation', savedState.rotation);
        this.set('model.scale', savedState.scale);
        this.set('model.visible', savedState.visible);
        this.set('model.userProperties', savedState.userProperties);
        this.set('model.userStyle', savedState.userStyle);
        this.isRunning = false;
    },
    moveAlong (distance) {
        let direction = (this.get('model.rotation') || 0) * Math.PI / 180,
            alongY = Math.round(parseInt(distance) * Math.sin(direction)),
            alongX = Math.round(parseInt(distance) * Math.cos(direction));
        this.move(alongX, alongY);
    },
    move (x, y) {
        let position = this.model.position;
        // Set separate values otherwise, the reference is compared and
        // change triggers are not fired
        this.set('model.position.x', position.x + x);
        this.set('model.position.y', position.y + y);
    },
    setXY (x, y) {
        this.setX(x);
        this.setY(y);
    },
    setX (x) {
        this.set('model.position.x', x);
    },
    setY (y) {
        this.set('model.position.y', y);
    },
    getX () {
        return this.get('model.position.x');
    },
    getY () {
        return this.get('model.position.y');
    },
    getSize () {
        return this.get('model.scale');
    },
    getRotation () {
        return this.get('model.rotation');
    },
    rotate (deg) {
        let rotation = this.model.rotation;
        this.set('model.rotation', parseInt(rotation) + parseInt(deg));
    },
    absolute_rotate (deg) {
        this.set('model.rotation', parseInt(deg));
    },
    scale (factor) {
        this.set('model.scale', factor);
    },
    resize (factor) {
        let curFactor = this.get('model.scale') || 100;
        this.set('model.scale', curFactor * factor / 100);
    },
    show (visibility) {
        this.set('model.visible', visibility);
    },
    toggleVisibility () {
        this.set('model.visible', !this.model.visible);
    },
    applyTransform () {
        if (!this.model) {
            return;
        }
        let position = this.model.position || { x: 0, y: 0 },
            rotation = this.model.rotation || 0,
            scale = this.model.scale / 100 || 1,
            transform,
            visibility;
        transform = `translate(${position.x}px, ${position.y}px) rotate(${rotation}deg) scale(${scale}, ${scale})`;
        visibility = this.model.visible ? 'visible' : 'hidden';
        this.style.webkitTransform = this.style.transform = transform;
        this.style.visibility = visibility;
    },
    renderOnCanvas (ctx) {
        if (this.model.partType !== 'ui') {
            return Promise.resolve();
        }
        let position = this.model.position || { x: 0, y: 0 },
            rotation = this.model.rotation || 0,
            scale = this.model.scale / 100 || 1,
            rect = this.getBoundingClientRect();

        ctx.save();
        ctx.translate(position.x + rect.width / 2, position.y + rect.height / 2);
        ctx.rotate(rotation * Math.PI / 180);
        ctx.scale(scale, scale);
        ctx.translate(-(rect.width / 2), -(rect.height / 2));
        return Promise.resolve();
    },
    renderFallback (ctx) {
        let width = this.offsetWidth,
            height = this.offsetHeight;
        ctx.fillStyle = this.model.colour;
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = 'white';
        ctx.font = '24px Bariol';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.model.name, width / 2, height / 2);
        ctx.restore();
        return Promise.resolve();
    },
    getConnectable (property) {
        let connectable = {
            node: this,
            property
        },
            customizable;
        if (property.indexOf('model.userProperties') === 0) {
            for (let i = 0; i < this.model.customizable.properties.length; i++) {
                customizable = this.model.customizable.properties[i];
                if (customizable.key === property.replace('model.userProperties.', '')) {
                    connectable.bounds = {
                        min: customizable.min,
                        max: customizable.max
                    };
                    break;
                }
            }
        }
        return connectable;
    }
};

</script>
