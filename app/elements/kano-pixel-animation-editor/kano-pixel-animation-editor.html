<link rel="import" href="../kano-pixel-canvas/kano-pixel-canvas.html">
<link rel="import" href="../kano-tooltip/kano-tooltip.html">
<link rel="import" href="../kano-style/input.html">
<dom-module id="kano-pixel-animation-editor">
    <style>
    :host {
        display: block;
    }
    .content {
        @apply(--layout-vertical);
        @apply(--layout-center);
    }
    .frame-list {
        @apply(--layout-horizontal);
        @apply(--layout-center);
        padding: 11px 4px;
        overflow-x: auto;
    }
    .frame-list kano-bitmap-renderer {
        cursor: pointer;
        border: 1px solid white;
        border-radius: 3px;
        background: grey;
        margin-left: -2px;
        @apply(--shadow-elevation-2dp);
        --kano-bitmap-renderer-canvas: {
            border-radius: 3px;
        };
    }
    .frame-list kano-bitmap-renderer:nth-child(odd) {
        transform: rotate(-1deg);
    }
    .frame-list kano-bitmap-renderer:nth-child(even) {
        transform: rotate(1deg);
    }
    .frame-list kano-bitmap-renderer.selected {
        border-color: var(--color-orange);
    }
    .add-frame {
        background: transparent;
        border: 0px;
        line-height: 34px;
        font-family: Bariol;
        font-weight: bold;
        font-size: 32px;
        padding: 0px 20px;
        /* Recenter the font in the button */
        margin-bottom: 12px;
    }
    .add-frame:focus {
        outline: none;
        color: var(--color-orange);
    }
    .toolbox {
        box-sizing: border-box;
        width: 100%;
        @apply(--layout-horizontal);
        padding: 7px;
    }
    .palette, .controls {
        @apply(--layout-flex);
    }
    .palette {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        @apply(--layout-start-justified);
    }
    .palette-color, .pen-control button {
        width: 26px;
        height: 26px;
        margin: 3px;
        cursor: pointer;
        border: 1px solid transparent;
        box-sizing: border-box;
    }
    .palette-color.selected {
        border-color: grey;
    }
    .controls {
        @apply(--layout-horizontal);
        @apply(--layout-end-justified);
    }
    .pen {
        position: fixed;
        top: 0;
        left: 0;
        width: 30px;
        height: 30px;
        opacity: 0.45;
        border: 2px solid white;
        pointer-events: none;
        @apply(--shadow-elevation-2dp);
        border-radius: 1px;
    }
    .add-color {
        background: transparent;
        color: grey;
        font-size: 22px;
        font-family: Bariol;
        line-height: 20px;
    }
    .add-color:focus {
        outline: none;
        color: var(--color-orange);
    }
    .pen-control iron-selector {
        @apply(--layout-vertical);
    }
    .pen-control button:focus {
        outline: none;
    }
    .pen-control button.iron-selected {
        outline: none;
        background: blue;
        border-color: grey;
    }
    kano-pixel-canvas {
        cursor: none;
    }
    .divider {
        margin: 3px 2px;
        width: 2px;
        background: lightgrey;
    }
    </style>
    <template>
        <div class="content">
            <div class="frame-list">
                <template is="dom-repeat" items="[[bitmaps]]" as="bm">
                    <kano-bitmap-renderer width="[[width]]" height="[[height]]" spacing="1" pixel-size="5" bitmap="[[bm]]" on-tap="_selectFrame" class$="[[_isFrameSelectedClass(index, selectedIndex)]]"></kano-bitmap-renderer>
                </template>
            </div>
            <kano-pixel-canvas id="canvas" bitmap="{{selected}}" spacing="2" width="[[width]]" height="[[height]]" pixel-size="30" palette="[[palette]]" pen-color="[[penColor]]" pen-type="[[penType]]"></kano-pixel-canvas>
            <div class="toolbox">
                <div class="pen-control">
                    <iron-selector selected="[[penType]]" attr-for-selected="name">
                        <button on-tap="_penControlTapped" name="draw">I</button>
                        <button on-tap="_penControlTapped" name="fill">O</button>
                    </iron-selector>
                </div>
                <div class="divider"></div>
                <div class="palette">
                    <template is="dom-repeat" items="[[palette]]" as="color">
                        <div class$="palette-color [[_computePaletteItemSelectedClass(color, penColor)]]" style$="[[_computePaletteColor(color)]]" on-tap="_paletteItemTapped"></div>
                    </template>
                    <button class="palette-color add-color" on-tap="_openWheel" id="add-color">+</button>
                </div>
                <div class="controls">
                    <button type="button" name="button" on-tap="_addFrame" class="add-frame">+</button>
                </div>
            </div>
        </div>
        <kano-tooltip class="tooltip" position="right" id="tooltip" target="[[tooltipTarget]]">
            <kano-color-wheel value="{{penColor}}" on-value-changed="_penColorChanged"></kano-color-wheel>
            <button type="button" name="button" class="close" on-tap="_closeWheel">&times;</button>
        </kano-tooltip>
        <div class="pen" id="pen" style$="[[_computePenStyle(penColor)]]"></div>
    </template>
    <script type="text/javascript">
        Polymer({
            is: 'kano-pixel-animation-editor',
            properties: {
                bitmaps: {
                    type: Array,
                    value: () => {
                        return [['#000000']];
                    },
                    notify: true
                },
                width: {
                    type: Number,
                    value: 1
                },
                height: {
                    type: Number,
                    value: 1
                },
                penType: {
                    type: String,
                    computed: '_computePenType(_penType, _isShiftPressed)'
                }
            },
            listeners: {
                'canvas.mouseover': '_onMouseOver',
                'canvas.mouseout': '_onMouseOut',
                'canvas.mousemove': '_onMouseMove',
                'keydown': '_onKeyEvent',
                'keyup': '_onKeyEvent'
            },
            observers: [
                '_bitmapChanged(bitmap, width, height)',
                '_bitmapsChanged(bitmaps.splices)',
                '_selectedChanged(selected.*)'
            ],
            attached () {
                this._penType = 'draw';
                this._isShiftPressed = false;
            },
            select (bitmap) {
                this.selected = bitmap.slice(0);
                this.selectedIndex = this.bitmaps.indexOf(bitmap);
            },
            isSelected (index) {
                return index === this.selectedIndex;
            },
            _computePenType (penType, shiftPressed) {
                return shiftPressed ? 'fill' : penType;
            },
            _onKeyEvent (e) {
                this.set('_isShiftPressed', e.shiftKey);
            },
            _penControlTapped (e) {
                let target = e.target;
                this.set('_penType', target.getAttribute('name'));
            },
            _computePenStyle (color) {
                return `background: ${color};`;
            },
            _onMouseOver () {
                this._isMouseOver = true;
                this.$.pen.style.display = 'block';
            },
            _onMouseMove (e) {
                if (this._isMouseOver) {
                    this.transform(`translate(${e.x - 14}px, ${e.y - 14}px)`, this.$.pen);
                }
            },
            _onMouseOut () {
                this._isMouseOver = false;
                this.$.pen.style.display = 'none';
            },
            _penColorChanged () {
                this._computePalette();
                this._closeWheel();
            },
            _openWheel () {
                requestAnimationFrame(() => {
                    this.tooltipTarget = this.$['add-color'].getBoundingClientRect();
                    this.$.tooltip.open();
                });
            },
            _paletteItemTapped (e) {
                let color = e.model.get('color');
                this.set('penColor', color);
            },
            _closeWheel () {
                this.$.tooltip.close();
            },
            _computePaletteColor (color) {
                return `background: ${color}`;
            },
            _selectedChanged (e) {
                let index = this.selectedIndex,
                    splices;

                if (e.path === 'selected.splices') {
                    splices = e.value;
                    splices.indexSplices.forEach(splice => {
                        this.splice(`bitmaps.#${index}`, splice.index, 1, this.selected[splice.index]);
                    });
                }
                this._computePalette();
            },
            _generateEmptyBitmap (name, width, height, color='#000000') {
                let length = width * height;
                for (let i = 0; i < length; i++) {
                    this.push(name, color);
                }
            },
            _bitmapChanged () {
                if (!this.bitmap) {
                    return;
                }
                if (this.bitmap.length === 0) {
                    this._generateEmptyBitmap('bitmap', this.width, this.height);
                }
            },
            _bitmapsChanged () {
                if (this.bitmaps.length === 0) {
                    this.set('bitmaps', [[]]);
                }
                this.select(this.bitmaps[0]);
            },
            _addFrame () {
                let copy;
                if (!this.bitmaps.length) {
                    copy = [];
                    for (let i = 0; i < this.width * this.height; i++) {
                        copy.push('#000000');
                    }
                } else {
                    copy = this.bitmaps[this.bitmaps.length - 1].slice(0);
                }
                this.push('bitmaps', copy);
                this.select(copy);
            },
            _selectFrame (e) {
                this.select(e.model.get('bm'));
            },
            _isFrameSelectedClass (index) {
                return this.isSelected(index) ? 'selected' : '';
            },
            _computePalette () {
                this.debounce('palette', () => {
                    let palette = this.bitmaps.reduce((acc, bitmap) => {
                        return acc.concat(bitmap);
                    }, []);

                    palette.push(this.penColor);
                    
                    palette = palette.filter((elem, pos, self) => {
                        return self.indexOf(elem) === pos && elem !== null && typeof elem !== 'undefined';
                    }).splice(-16, 16);
                    this.set('palette', palette);
                    if (!this.penColor) {
                        this.set('penColor', this.palette[0]);
                    }
                }, 16);
            },
            _computePaletteItemSelectedClass (color, penColor) {
                return color === penColor ? 'selected' : '';
            }
        });
    </script>
</dom-module>
