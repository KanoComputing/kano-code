<link rel="import" href="../behaviors/kano-app-editor-behavior.html">
<link rel="import" href="../behaviors/kano-validator-behavior.html">
<link rel="import" href="../behaviors/kano-blockly-validator-behavior.html">
<link rel="import" href="../kano-tooltip/kano-tooltip.html">
<link rel="import" href="../kano-blockly/kano-blockly.html">
<link rel="import" href="../../bower_components/iron-signals/iron-signals.html">

<dom-module id="kano-root-view">
    <style>
    :host {
        display: block;
        @apply(--layout-vertical);
        background-color: var(--color-grey-darker, grey);
        --tooltip-color: #21596F;
    }
    :host kano-blockly,
    :host kano-code-editor {
        @apply(--layout-flex);
    }
    :host .tooltip-content {
        @apply(--layout-vertical);
        @apply(--layout-center);
    }
    :host .tooltip-content button {
        margin-top: 10px;
        background-color: white;
        color: #435055;
        text-shadow: none;
    }
    kano-tooltip {
        z-index: 101;
        --kano-tooltip-background-color: var(--tooltip-color);
        --kano-tooltip-border-color: white;
        --kano-tooltip-border-width: 1px;
        color: white;
        --kano-tooltip: {
            box-shadow: 0px 2px 0px 0px rgba(0, 0, 0, 0.25);
            padding: 18px 26px 20px;
            font-size: 20px;
            line-height: 25px;
        };
        --kano-tooltip-caret: {
            box-shadow: 0px 0px 0px 0px;
        };
    }
    kano-tooltip[position="top"] {
        --kano-tooltip-caret: {
            box-shadow: 0px 0px 0px 2px rgba(0, 0, 0, 0.25);
        };
    }
    kano-tooltip[position="left"] {
        --kano-tooltip-caret: {
            box-shadow: 2px 0px 0px 0px rgba(0, 0, 0, 0.25);
        };
    }
    kano-tooltip[position="right"] {
        --kano-tooltip-caret: {
            box-shadow: 0px 2px 0px 0px rgba(0, 0, 0, 0.25);
        };
    }
    .tooltip-text kano-blockly-block {
        line-height: 0px;
        vertical-align: middle;
        display: inline-block;
    }
    </style>
    <template>
        <kano-blockly id="code-editor"
                toolbox="[[toolbox]]"
                on-change="saveCode"
                default-blocks="[[mode.defaultBlocks]]">
        </kano-blockly>
        <iron-signals on-iron-signal-display-tooltip="displayTooltip"></iron-signals>
        <template is="dom-if" if="{{tooltip.text}}">
            <kano-tooltip id$="tooltip-[[index]]"
                        target="[[tooltip.target]]"
                        position="[[tooltip.position]]"
                        z-index="[[tooltip.zIndex]]"
                        tracking="[[tooltip.tracking]]"
                        bounce$="[[tooltip.bounce]]">
                <div class="tooltip-content">
                    <div class="tooltip-text">
                        <marked-element markdown="[[tooltip.text]]">
                            <div class="markdown-html"></div>
                        </marked-element>
                    </div>
                    <button type="button" on-tap="nextStep" hidden$="[[!tooltip.next_button]]">Next</button>
                </div>
            </kano-tooltip>
        </template>
    </template>
</dom-module>
<script type="text/javascript">
    /* globals Polymer, Kano, Blockly */

    Polymer({
        is: 'kano-root-view',
        behaviors: [Kano.Behaviors.AppEditorBehavior, Kano.Behaviors.BlocklyValidatorBehavior],
        properties: {
            parts: {
                type: Array,
                notify: true
            },
            toolbox: {
                type: Array
            },
            tooltips: {
                type: Object,
                notify: true
            },
            defaultCategories: {
                type: Object
            },
            code: {
                type: Object,
                notify: true,
                observer: 'codeChanged'
            },
            mode: {
                type: Object
            }
        },
        observers: [
            'computeToolbox(parts)',
            'computeToolboxDebounced(parts.*)',
            'computeToolboxDebounced(defaultCategories.*)',
            'computeToolboxDebounced(mode)',
            'defaultCategoriesLoaded(defaultCategories.events)'
        ],
        codeChanged () {
            if (!this.code) {
                return;
            }
            this.$['code-editor'].load(this.code.snapshot);
        },
        computeTriggerOptions () {
            let options = [['app starts', 'global.start']];
            this.parts.forEach((part) => {
                part.events.forEach((ev) => {
                    options.push([`${part.name} ${ev.label}`, `${part.id}.${ev.id}`]);
                });
            });
            // Add events of the current mode
            if (this.mode.events) {
                this.mode.events.forEach((ev) => {
                    options.push([`${this.mode.name} ${ev.label}`, `${this.mode.id}.${ev.id}`]);
                });
            }
            return options;
        },
        saveCode (e) {
            this.tooltip = {};
            // Check if a create event follows a close-flyout event. If so, do not notify
            // of the close-flyout event
            if (e.detail.type === 'close-flyout') {
                // Defer the notification
                this.closeFlyoutTimeoutId = setTimeout(() => {
                    this.notifyChange('blockly', { event: e.detail });
                });
            } else {
                // A create event will cancel its previous close-flyout event
                if (e.detail.type === 'create') {
                    clearTimeout(this.closeFlyoutTimeoutId);
                }
                this.notifyChange('blockly', { event: e.detail });
            }
            this.debounce('saveCode', () => {
                let codeEditor = this.$['code-editor'];

                codeEditor.save().then((snapshot) => {
                    snapshot.pseudo = snapshot.pseudo.trim().length ? snapshot.pseudo : '// Edit me to add code';
                    this.set('code.snapshot', snapshot);
                });
            }, 300);
        },
        _processMarkdown (text) {
            let reg = /<kano-blockly-block(.*)type="(.+)"(.*)><\/kano-blockly-block>/g;
            return text.replace(reg, (match, before, type, after) => {
                let pieces = type.split('#');
                if (pieces.length > 1) {
                    pieces[0] = this.stepIds[pieces[0]] || pieces[0];
                }
                type = pieces.join('#');
                return `<kano-blockly-block${before}type="${type}"${after}></kano-blockly-block>`;
            });
        },
        computeTooltips (tooltip) {
            this.debounce('computeTooltip', () => {
                let copy = Object.assign({}, tooltip);
                copy.target = this.editor.getBlocklyWorkspace().getBlockById(tooltip.location.block.id).svgPath_;
                copy.text = this._processMarkdown(tooltip.text);
                copy.tracking = tooltip.tracking !== false ? true : false;
                this.set('tooltip', copy);
            }, 200);
        },
        displayTooltip (e) {
            this.computeTooltips({
                "location": {
                    "block": {
                        "id": atob(e.detail.block_id)
                    }
                },
                "position": "top",
                "text": Kano.MakeApps.Blockly.Defaults.values[e.detail.type].validation.error_message
            });
        },
        ready () {
            this.toolboxReady = false;

            this.editor = this.$['code-editor'];
            this.editor.getBlocklyWorkspace = this.editor.getWorkspace;
        },
        defaultCategoriesLoaded (newVal, oldVal) {
            if (!newVal) {
                return;
            }
            let computeTriggerOptions = this.computeTriggerOptions.bind(this),
                colour = this.defaultCategories.events ? this.defaultCategories.events.colour : '';
            Blockly.Blocks.part_event = {
                init: function () {
                    let json = {
                        id: 'part_event',
                        colour: colour,
                        message0: 'When %1',
                        args0: [{
                            type: "field_dropdown",
                            name: "EVENT",
                            options: computeTriggerOptions
                        }],
                        message1: '%1',
                        args1: [{
                            type: "input_statement",
                            name: "DO"
                        }]
                    };
                    this.jsonInit(json);
                }
            };
            this.$['code-editor'].load(this.code.snapshot);
        },
        computeBlocks () {
            let events = [];
            this.parts
                .forEach((part) => {
                    part.blockIds = [];
                    part.blocks.forEach((definition) => {
                        this._registerBlock(part, definition);
                    });
                    // Also register the legacy blocks to support shares made with previous block API
                    part.legacyBlocks.forEach((definition) => {
                        this._registerBlock(part, definition);
                    });
                    part.events.forEach((ev) => {
                        events.push(ev);
                    });
                });
            if (this.mode.blocks) {
                this.mode.blockIds = [];
                this.mode.blocks.forEach((definition) => {
                    this._registerBlock(this.mode, definition);
                });
            }
        },
        _registerBlock (part, definition) {
            let block = definition.block(part),
                lookups,
                lookupString;

            block.lookup = block.lookup || [];
            lookups = Array.isArray(block.lookup) ? block.lookup : [block.lookup];
            block.colour = part.colour;
            block.id = `${part.id}#${block.id}`;
            lookups.forEach(lookup => {
                lookupString = `${part.id}.${lookup}`;
                part.blockIds.push(block.id);
                Kano.MakeApps.Blockly.setLookupString(block.id, lookupString);
            });
            if (!block.doNotRegister) {
                Blockly.Blocks[block.id] = {
                    init: function () {
                        this.jsonInit(block);
                    }
                };
            }
            Blockly.JavaScript[block.id] = definition.javascript(part);
            Blockly.Pseudo[block.id] = definition.pseudo(part);
            // Hack to register blocks from the normal mode under the dropzone id to support older shares
            if (part.id === 'normal') {
                block.id = block.id.replace('normal', 'dropzone');
                if (!block.doNotRegister) {
                    Blockly.Blocks[block.id] = {
                        init: function () {
                            this.jsonInit(block);
                        }
                    };
                }
                Blockly.JavaScript[block.id] = definition.javascript(part);
                Blockly.Pseudo[block.id] = definition.pseudo(part);
            }
        },
        computeToolbox () {
            let categories,
                toolbox,
                parts = this.parts,
                blocks,
                weight;
            if (!parts || !this.defaultCategories || !this.mode) {
                return;
            }
            this.computeBlocks();
            // Reset events blocks
            weight = {
                'ui': 1,
                'data': 2,
                'hardware': 3
            };
            categories = parts
                .map((ui) => {
                    blocks = ui.blocks.map((definition) => {
                        let block = definition.block(ui);
                        block.colour = ui.colour;
                        block.id = `${ui.id}#${block.id}`;
                        return {
                            id: block.id,
                            colour: block.colour,
                            shadow: block.shadow
                        };
                    });
                    return {
                        name: ui.name,
                        colour: ui.colour,
                        id: ui.id,
                        weight: weight[ui.partType],
                        blocks
                    };
                })
                .sort((a, b) => {
                    return a.weight - b.weight;
                });

            categories = categories || [];
            categories = categories.filter((category) => category.blocks.length);

            Object.keys(this.defaultCategories).forEach((id) => {
                let cat = this.defaultCategories[id];
                cat.blocks.forEach((block) => {
                    block.colour = cat.colour;
                });
            });

            toolbox = Object.keys(this.defaultCategories).map(id => this.defaultCategories[id]);

            toolbox = toolbox
                .concat({ type: 'separator' });
            // Generate the toolbox for the special mode
            if (this.mode.blocks && this.mode.blocks.length) {
                let modeCat = {
                    name: this.mode.name,
                    id: this.mode.id,
                    colour: this.mode.colour
                };
                modeCat.blocks = this.mode.blocks.map((definition) => {
                    let block = definition.block(this.mode);
                    return {
                        id: `${this.mode.id}#${block.id}`,
                        colour: this.mode.colour,
                        shadow: block.shadow
                    };
                });
                toolbox.push(modeCat);
                toolbox.push({ type: 'separator' });
            }
            toolbox = toolbox.concat(categories);
            this.set('toolbox', toolbox);
            if (!this.toolboxReady) {
                this.toolboxReady = true;
                this.$['code-editor'].load(this.code.snapshot);
            }
        },
        computeToolboxDebounced () {
            this.debounce('computeToolbox', () => this.computeToolbox(), 200);
        },
        getBlocklyWorkspace () {
            return this.$['code-editor'].getWorkspace();
        }
    });
</script>
