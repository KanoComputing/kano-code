<link rel="import" href="../kano-blockly/kano-blockly.html">
<link rel="import" href="../kano-style/kano-style.html">
<link rel="import" href="../kano-nav-header/kano-nav-header.html">
<link rel="import" href="../behaviors.html">

<dom-module id="kano-root-view">
    <style>
    :host {
        display: block;
        @apply(--layout-vertical);
        background-color: var(--color-grey-darker, grey);
    }
    :host kano-blockly,
    :host kano-code-editor {
        @apply(--layout-flex);
    }
    </style>
    <template>
        <kano-blockly id="code-editor"
                toolbox="[[toolbox]]"
                on-change="saveCode"></kano-blockly>
    </template>
</dom-module>
<script type="text/javascript">
    /* globals Polymer, KanoBehaviors, Blockly */

    class KanoRootView {

        get behaviors () {
            return [KanoBehaviors.AppEditorBehavior];
        }

        beforeRegister () {
            this.is = 'kano-root-view';
            this.properties = {
                parts: {
                    type: Array,
                    notify: true
                },
                toolbox: {
                    type: Array
                },
                defaultCategories: {
                    type: Object,
                    value: () => {
                        return {};
                    }
                },
                code: {
                    type: Object,
                    notify: true,
                    observer: 'codeChanged'
                }
            };
            this.observers = [
                'computeToolbox(parts.*)',
                'computeBlocks(parts.*)',
                'computeTitle(selectedPage)'
            ];
        }
        ready () {
            this.toolboxReady = false;
        }
        attached () {
            let computeTriggerOptions = this.computeTriggerOptions.bind(this),
                colour = this.defaultCategories.events.colour;

            Blockly.Blocks.part_event = {
                init: function () {
                    let json = {
                        id: 'part_event',
                        colour: colour,
                        message0: 'When %1',
                        args0: [{
                            type: "field_dropdown",
                            name: "EVENT",
                            options: computeTriggerOptions
                        }],
                        message1: '%1',
                        args1: [{
                            type: "input_statement",
                            name: "DO"
                        }]
                    };
                    this.jsonInit(json);
                }
            };
            this.$['code-editor'].resize();
        }
        codeChanged () {
            this.$['code-editor'].load(this.code.snapshot);
        }
        computeTriggerOptions () {
            let options = [['app starts', 'global.start']];
            this.parts.forEach((part) => {
                part.events.forEach((ev) => {
                    options.push([`${part.name} ${ev.label}`, `${part.id}.${ev.id}`]);
                });
            });
            return options;
        }
        saveCode () {
            this.debounce('saveCode', () => {
                let codeEditor = this.$['code-editor'];

                codeEditor.save().then((snapshot) => {
                    snapshot.pseudo = snapshot.pseudo.trim().length ? snapshot.pseudo : '// Edit me to add code';
                    this.set('code.snapshot', snapshot);
                });
            }, 300);
        }
        computeBlocks () {
            let events = [];
            this.parts
                .forEach((part) => {
                    part.blocks.forEach((definition) => {
                        let block = definition.block(part);
                        block.colour = part.colour;
                        block.id = `${part.id}#${block.id}`;
                        Blockly.Blocks[block.id] = {
                            init: function () {
                                this.jsonInit(block);
                            }
                        };
                        Blockly.JavaScript[block.id] = definition.javascript(part);
                        Blockly.Pseudo[block.id] = definition.pseudo(part);
                        return {
                            id: block.id,
                            colour: block.colour,
                            shadow: block.shadow
                        };
                    });
                    part.events.forEach((ev) => {
                        events.push(ev);
                    });
                });
        }
        computeToolbox () {
            this.debounce('computeToolbox', () => {
                let categories,
                    toolbox,
                    parts = this.parts,
                    blocks,
                    weight;
                if (!parts) {
                    return;
                }
                // Reset events blocks
                weight = {
                    'ui': 1,
                    'data': 2,
                    'hardware': 3
                };
                categories = parts
                    .map((ui) => {
                        blocks = ui.blocks.map((definition) => {
                            let block = definition.block(ui);
                            block.colour = ui.colour;
                            block.id = `${ui.id}#${block.id}`;
                            return {
                                id: block.id,
                                colour: block.colour,
                                shadow: block.shadow
                            };
                        });
                        return {
                            name: ui.name,
                            colour: ui.colour,
                            id: ui.type,
                            weight: weight[ui.partType],
                            blocks
                        };
                    })
                    .sort((a, b) => {
                        return a.weight - b.weight;
                    });

                categories = categories || [];
                categories = categories.filter((category) => category.blocks.length);

                Object.keys(this.defaultCategories).forEach((id) => {
                    let cat = this.defaultCategories[id];
                    cat.blocks.forEach((block) => {
                        block.colour = cat.colour;
                    });
                });

                toolbox = Object.keys(this.defaultCategories).filter(id => id !== 'background').map(id => this.defaultCategories[id]);

                toolbox = toolbox
                    .concat({ type: 'separator' });
                if (this.defaultCategories.background) {
                    toolbox.push(this.defaultCategories.background);
                }
                toolbox = toolbox.concat(categories);
                this.set('toolbox', toolbox);
                if (!this.toolboxReady) {
                    // I spent too many hours trying to figure out how to know when the blockly container got its
                    // offsetWidth and offsetHeight set. This migic number seems to work. Please if you have a solution
                    // implement it
                    this.async(() => {
                        this.$['code-editor'].resize();
                    }, 300);
                }
                this.toolboxReady = true;
            }, 200);
        }

        getBlocklyWorkspace () {
            return this.$['code-editor'].getWorkspace();
        }
    }
    Polymer(KanoRootView);
</script>
