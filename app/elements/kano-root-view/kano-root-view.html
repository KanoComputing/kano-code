<link rel="import" href="../behaviors/kano-app-editor-behavior.html">
<link rel="import" href="../behaviors/kano-app-element-registry-behavior.html">
<link rel="import" href="../kano-blockly/kano-blockly.html">

<dom-module id="kano-root-view">
    <style>
    :host {
        display: block;
        position: relative;
        background-color: var(--color-grey-darker, grey);
    }
    :host kano-blockly,
    :host kano-code-editor,
    .shell {
        @apply(--layout-fit);
        transition: opacity 200ms linear;
    }
    .shell {
        background-color: var(--kano-blockly-background, white);
    }
    .shell .toolbox {
        content: ' ';
        position: absolute;
        @apply --kano-blockly-toolbox;
        top: 0px;
        bottom: 0px;
        width: 130px;
    }
    :host([loading]) kano-blockly {
        opacity: 0;
    }
    </style>
    <template>
        <div class="shell">
            <div class="toolbox"></div>
        </div>
        <kano-blockly id="code-editor"
                toolbox="[[toolbox]]"
                on-change="saveCode"
                default-blocks="[[mode.defaultBlocks]]"
                on-blockly-ready="_onBlocklyReady"
                no-trashcan="[[simple]]"
                no-zoom-control="[[simple]]"
                no-toolbox="[[simple]]"></kano-blockly>
    </template>
</dom-module>
<script type="text/javascript">
    /* globals Polymer, Kano, Blockly */

    Polymer({
        is: 'kano-root-view',
        behaviors: [Kano.Behaviors.AppEditorBehavior,
                    Kano.Behaviors.AppElementRegistryBehavior],
        properties: {
            parts: {
                type: Array,
                notify: true
            },
            toolbox: {
                type: Array
            },
            defaultCategories: {
                type: Object
            },
            code: {
                type: Object,
                notify: true,
                observer: 'codeChanged'
            },
            mode: {
                type: Object
            },
            simple: {
                type: Boolean,
                value: false
            }
        },
        observers: [
            'computeToolbox(parts)',
            '_partsChanged(parts.*)',
            'computeToolboxDebounced(defaultCategories.*)',
            'computeToolboxDebounced(mode)',
            'defaultCategoriesLoaded(defaultCategories.events)'
        ],
        _onBlocklyReady () {
            if (!this.simple) {
                this._registerElement('blockly-bin', this.$['code-editor'].workspace.svgGroup_.querySelector('.blocklyTrash'));
                this._registerElement('blockly-toolbox', this.$['code-editor'].getToolbox());
            }
        },
        codeChanged () {
            if (!this.code) {
                return;
            }
            this.$['code-editor'].load(this.code.snapshot);
        },
        computeTriggerOptions () {
            let options = [[Blockly.Msg.APP_STARTS, 'global.start']];
            this.parts.forEach((part) => {
                part.events.forEach((ev) => {
                    options.push([`${part.name} ${ev.label}`, `${part.id}.${ev.id}`]);
                });
            });
            // Add events of the current mode
            if (this.mode.events) {
                this.mode.events.forEach((ev) => {
                    options.push([`${this.mode.name} ${ev.label}`, `${this.mode.id}.${ev.id}`]);
                });
            }
            return options;
        },
        saveCode (e) {
            // Check if a create event follows a close-flyout event. If so, do not notify
            // of the close-flyout event
            if (e.detail.type === 'close-flyout') {
                // Defer the notification
                this.closeFlyoutTimeoutId = setTimeout(() => {
                    this.notifyChange('blockly', { event: e.detail });
                });
            } else {
                // A create event will cancel its previous close-flyout event
                if (e.detail.type === 'create') {
                    clearTimeout(this.closeFlyoutTimeoutId);
                }
                this.notifyChange('blockly', { event: e.detail });
            }
            this.debounce('saveCode', () => {
                let codeEditor = this.$['code-editor'];

                codeEditor.save().then((snapshot) => {
                    snapshot.pseudo = snapshot.pseudo.trim().length ? snapshot.pseudo : '// Edit me to add code';
                    this.set('code.snapshot', snapshot);
                });
            }, 300);
        },
        ready () {
            this.toolboxReady = false;
        },
        defaultCategoriesLoaded (newVal, oldVal) {
            if (!newVal) {
                return;
            }
            let computeTriggerOptions = this.computeTriggerOptions.bind(this),
                colour = this.defaultCategories.events ? this.defaultCategories.events.colour : '';
            Blockly.Blocks.part_event = {
                init: function () {
                    let json = {
                        id: 'part_event',
                        colour: colour,
                        message0: Blockly.Msg.GLOBAL_EVENT,
                        args0: [{
                            type: "field_dropdown",
                            name: "EVENT",
                            options: computeTriggerOptions
                        }],
                        message1: '%1',
                        args1: [{
                            type: "input_statement",
                            name: "DO"
                        }]
                    };
                    this.jsonInit(json);
                }
            };
            this.$['code-editor'].load(this.code.snapshot);
        },
        computeBlocks () {
            let events = [];
            this.parts
                .forEach((part) => {
                    part.blocks.forEach((definition) => {
                        if (typeof definition === 'object') {
                            this._registerBlock(part, definition);
                        }
                    });
                    // Also register the legacy blocks to support shares made with previous block API
                    part.legacyBlocks.forEach((definition) => {
                        if (typeof definition === 'object') {
                            this._registerBlock(part, definition);
                        }
                    });
                    part.events.forEach((ev) => {
                        events.push(ev);
                    });
                });
            if (this.mode.categories) {
                this.mode.categories.forEach(category => {
                    category.blocks.forEach((definition) => {
                        this._registerBlock(this.mode, definition);
                    });
                })
            }
        },
        _registerBlock (part, definition) {
            let block = definition.block(part),
                lookups,
                lookupString;

            block.lookup = block.lookup || [];
            lookups = Array.isArray(block.lookup) ? block.lookup : [block.lookup];
            block.colour = part.colour;
            block.id = `${part.id}#${block.id}`;
            lookups.forEach(lookup => {
                lookupString = `${part.id}.${lookup}`;
                Kano.MakeApps.Blockly.setLookupString(block.id, lookupString);
            });
            if (!block.doNotRegister) {
                Blockly.Blocks[block.id] = {
                    init: function () {
                        this.jsonInit(block);
                    }
                };
            }
            Blockly.JavaScript[block.id] = definition.javascript(part);
            Blockly.Pseudo[block.id] = definition.pseudo(part);
            // Hack to register blocks from the normal mode under the dropzone id to support older shares
            if (part.id === 'normal') {
                block.id = block.id.replace('normal', 'dropzone');
                if (!block.doNotRegister) {
                    Blockly.Blocks[block.id] = {
                        init: function () {
                            this.jsonInit(block);
                        }
                    };
                }
                Blockly.JavaScript[block.id] = definition.javascript(part);
                Blockly.Pseudo[block.id] = definition.pseudo(part);
            }
        },
        computeToolbox () {
            let categories,
                toolbox,
                parts = this.parts,
                blocks,
                weight;
            if (!parts || !this.defaultCategories || !this.mode) {
                return;
            }
            this.computeBlocks();
            // Reset events blocks
            weight = {
                'ui': 1,
                'data': 2,
                'hardware': 3
            };
            categories = parts
                .map((ui) => {
                    blocks = ui.blocks.map((definition) => {
                        if (typeof definition === 'string') {
                            return {
                                id: definition,
                                colour: ui.colour
                            }
                        }
                        let block = definition.block(ui);
                        block.colour = ui.colour;
                        block.id = `${ui.id}#${block.id}`;
                        return {
                            id: block.id,
                            colour: block.colour,
                            shadow: block.shadow
                        };
                    });
                    return {
                        name: ui.name,
                        colour: ui.colour,
                        id: ui.id,
                        weight: weight[ui.partType],
                        blocks
                    };
                })
                .sort((a, b) => {
                    return a.weight - b.weight;
                });

            categories = categories || [];
            categories = categories.filter((category) => category.blocks.length);
            Object.keys(this.defaultCategories).forEach((id) => {
                let cat = this.defaultCategories[id];
                cat.blocks.forEach((block) => {
                    block.colour = cat.colour;
                });
            });

            toolbox = Object.keys(this.defaultCategories).map(id => this.defaultCategories[id]);

            // Generate the toolbox for the special mode
            if (this.mode.categories) {
                this.mode.categories.forEach(category => {
                    let modeCat = {
                        name: category.name,
                        id: category.id,
                        colour: category.colour
                    };
                    modeCat.blocks = category.blocks.map((definition) => {
                        let block = definition.block(this.mode);
                        return {
                            id: `${this.mode.id}#${block.id}`,
                            colour: this.mode.colour,
                            shadow: block.shadow
                        };
                    });
                    toolbox.push(modeCat);
                });
            }
            toolbox = toolbox.concat(categories);
            this.set('toolbox', toolbox);
            if (!this.toolboxReady) {
                this.toolboxReady = true;
                this.$['code-editor'].load(this.code.snapshot);
            }
        },
        _partsChanged (e) {
            let idChanged = e.path.indexOf('id') === e.path.length - 2;
            if (e.path === 'parts' || e.path === 'parts.splices') {
                // Update the id registry when the parts array is changed or if any item is added/removed
                this._updateIdRegistry();
            }
            // Only update if the splices changes (part added or removed) or if the name of the part changes
            if (e.path === 'parts' || e.path === 'parts.splices' || idChanged) {
                this.computeToolboxDebounced();
                if (Blockly.Blocks && Blockly.Blocks.collision_event) {
                    // Update the collision block with the new parts
                    Blockly.Blocks.collision_event.setParts(this.parts);
                }
                // If the id changed, we nee to upgrade the blocks already added
                if (idChanged) {
                    this.debounce('reloadAfterIdChanged', () => {
                        let key = e.path.replace('parts.#', '').split('.').shift(),
                            oldId = this._idRegistry[key],
                            blocks = this.$['code-editor'].getBlocks(),
                            replaceRegexp = new RegExp(`type="${oldId}#`, 'g');

                        blocks = blocks.replace(replaceRegexp, `type="${e.value}#`);
                        // Reflect the id change by updating the id registry
                        this._updateIdRegistry();
                    }, 200);
                }
            }
        },
        _updateIdRegistry () {
            // Keeps a record of all the ids. If one changes, we can get the old value from here
            this._idRegistry = this.parts.map(part => part.id);
        },
        computeToolboxDebounced () {
            this.debounce('computeToolbox', () => this.computeToolbox(), 200);
        },
        getBlocklyWorkspace () {
            return this.$['code-editor'].getWorkspace();
        }
    });
</script>
