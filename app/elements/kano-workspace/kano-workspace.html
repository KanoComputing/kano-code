<link rel="import" href="../ui/kano-ui/kano-ui.html">
<dom-module id="kano-workspace">
    <style>
    :host {
        position: relative;
        @apply(--layout-vertical);
        background-color: var(--color-white, white);
        border: 0px;
        transition: box-shadow linear 100ms;
        box-shadow: 0px 0px 0px 4px transparent inset;
        overflow: hidden;
    }
    :host.pulsing {
        box-shadow: 0px 0px 0px 4px var(--primary-color) inset;
    }
    :host .content {
        position: relative;
        @apply(--layout-flex);
        --kano-ui-viewport: {
            @apply(--kano-shadow);
        };
    }
    :host.running .content {
        --kano-ui-viewport: {
            border: none;
        };
    }
    :host ::content #dropzone {
        width: 100%;
        height: 100%;
    }
    </style>
    <template>
        <kano-ui-viewport mode="scaled"
                    view-width="[[size.width]]"
                    view-height="[[size.height]]"
                    class="content"
                    id="content">
            <div id="dropzone"></div>
        </kano-ui-viewport>
    </template>
</dom-module>

<script type="text/javascript">
    class KanoWorkspace {
        beforeRegister () {
            this.is = 'kano-workspace';
            this.properties = {
                size: {
                    type: Object
                },
                parts: {
                    type: Array,
                    notify: true
                },
                running: {
                    type: Boolean,
                    value: false,
                    observer: 'runningChanged'
                },
                selected: {
                    type: Number,
                    notify: true
                },
                selectedPart: {
                    type: Object,
                    computed: 'computeSelectedPart(selected)'
                }
            };
            this.observers = [
                'selectedPartChanged(selectedPart.*)',
                'partsChanged(parts.*)'
            ];
        }
        ready () {
            this.elements = {};
        }
        partsChanged (e) {
            let path;
            if (!e) {
                return;
            }
            path = e.path;
            if (path === 'parts.splices') {
                let splices = e.value.keySplices;
                splices.forEach((splice) => {
                    splice.added.forEach(this.insertPart.bind(this));
                    splice.removed.forEach(this.removePart.bind(this));
                });
            } else if (path === 'parts') {
                if (this.elements) {
                    // Clean the dropzone
                    Object.keys(this.elements).forEach(this.removePart.bind(this));
                }
                // Insert the elements from the models
                this.parts.forEach((model, index) => {
                    this.insertPart(`#${index}`);
                });
            } else if (path === 'parts.length'){
                return;
            } else {
                let pieces = path.split('.'),
                    key = pieces[1],
                    subPath;
                if (!key) {
                    return;
                }
                subPath = pieces.slice(2, pieces.length);
                subPath.unshift('model');
                subPath = subPath.join('.');
                this.propagateChange(key, subPath, e.value);
            }
        }
        propagateChange (key, path, value) {
            let element = this.elements[key];
            if (!element) {
                return;
            }
            element.set(path, value);
        }
        insertPart (key) {
            let model = this.get(`parts.${key}`),
                element = document.createElement(`kano-ui-${model.type}`);
            element.setAttribute('id', model.id);
            element.addEventListener('model-changed', (e) => {
                let detail = e.detail,
                    path;
                if (!detail.path) {
                    path = `parts.${key}`;
                } else {
                    path = detail.path.replace('model', `parts.${key}`);
                }
                this.set(path, detail.value);
            });
            element.model = model;
            this.elements[key] = element;
            this.$.dropzone.appendChild(element);
        }
        removePart (key) {
            let element = this.elements[key];
            if (!element) {
                return;
            }
            this.$.dropzone.removeChild(element);
            delete this.elements[key];
        }
        computeSelectedPart () {
            return this.parts[this.selected];
        }
        runningChanged () {
            if (this.running) {
                this.classList.add('running');
            } else {
                this.classList.remove('running');
            }
        }
        selectedPartChanged (e) {
            let index,
                path;
            if (!this.selectedPart) {
                return;
            }
            index = this.getPartIndexById(this.selectedPart.id);
            path = e.path.replace('selectedPart', `parts.${index}`);
            this.set(path, e.value);
        }
        getPartIndexById (id) {
            let elements = this.parts;
            for (let i = 0, len = elements.length; i < len; i++) {
                if (elements[i].id === id) {
                    return i;
                }
            }
        }
        getViewport () {
            return this.$.dropzone;
        }
    }
    Polymer(KanoWorkspace);
</script>
