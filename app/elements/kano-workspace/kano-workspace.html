<link rel="import" href="../ui/behaviors.html">
<link rel="import" href="../behaviors/kano-app-editor-behavior.html">
<link rel="import" href="../kano-tooltip/kano-tooltip.html">

<dom-module id="kano-workspace">
    <style>
    :host {
        position: relative;
        @apply(--layout-vertical);
        border: 0px;
        overflow: hidden;
    }
    :host .content {
        position: relative;
        @apply(--layout-flex);
    }
    :host.running .content {
        --kano-ui-viewport: {
            border: none;
        };
    }
    :host ::content #dropzone {
        margin: auto;
        position: relative;
    }
    kano-tooltip {
        --kano-tooltip-background-color: #88c840;
        color: white;
        --kano-tooltip: {
            box-shadow: 0px 0px 0px 0px;
            padding: 10px;
        };
        --kano-tooltip-caret: {
            box-shadow: 0px 0px 0px 0px;
        };
    }
    :host .tooltip-content {
        @apply(--layout-horizontal);
    }
    :host .tooltip-content button {
        background-color: transparent;
        border: 0px;
        color: white;
        cursor: pointer;
    }
    :host .tooltip-content .delete-section {
        @apply(--layout-horizontal);
    }
    :host .tooltip-content .separator {
        border-left: 1px solid white;
        width: 0px;
    }
    :host paper-dialog .buttons button {
        @apply(--kano-button);
        margin-left: 5px;
    }
    :host paper-dialog .buttons .confirm {
        background-color: var(--color-red, red);
    }
    :host .made-with-kano {
        text-align: center;
        color: #B3B3B3;
    }
    </style>
    <template>
        <kano-ui-viewport mode="scaled"
                    view-width="[[mode.workspace.viewport.width]]"
                    view-height="[[mode.workspace.viewport.height]]"
                    class="content"
                    id="content"
                    on-tap="onTap">
            <!-- The variable workspace component will be inserted here -->
            <h3 class="made-with-kano">made with Kano</h3>
        </kano-ui-viewport>
        <kano-tooltip target="[[tooltipTarget]]" position="bottom" id="tooltip">
            <div class="tooltip-content">
                <div class="settings" hidden$="[[!canEdit(tappedElement)]]">
                    <button type="button" on-tap="openSettings">Settings</button>
                </div>
                <div class="separator" hidden$="[[isSeparatorHidden(tappedElement)]]"></div>
                <div class="delete" on-tap="deletePart" hidden$="[[!canDelete(tappedElement)]]">
                    <button type="button">Delete</button>
                </div>
            </div>
        </kano-tooltip>
        <array-selector id="selector" items="{{parts}}" selected="{{selected}}"></array-selector>
        <paper-dialog id="confirm-delete" with-backdrop on-iron-overlay-closed="modalClosed">
            <h2>Delete Part</h2>
            <div class="modal-content">
                <div>You are about to delete '[[aboutToDelete]]'</div>
                <div>Are you sure you want to do this?</div>
            </div>
            <div class="buttons">
                <button dialog-dismiss class="cancel">Cancel</button>
                <button dialog-confirm class="confirm">Confirm</button>
            </div>
        </paper-dialog>
        <paper-dialog id="external-use-warning" with-backdrop>
            <h2>Delete Part</h2>
            <div class="modal-content">
                <div>You can't delete '[[aboutToDelete]]' because it is used in the code</div>
            </div>
            <div class="buttons">
                <button dialog-dismiss class="cancel">Cancel</button>
            </div>
        </paper-dialog>
    </template>
</dom-module>

<script type="text/javascript">
    /* globals Polymer, Kano */
    Polymer({
        is: 'kano-workspace',
        behaviors: [Kano.Behaviors.AppEditorBehavior],
        properties: {
            parts: {
                type: Array,
                notify: true
            },
            running: {
                type: Boolean,
                value: false,
                observer: 'runningChanged'
            },
            selected: {
                type: Object,
                notify: true
            },
            internalSelection: {
                type: Object,
                value: null
            },
            code: {
                type: Object
            },
            mode: {
                type: Object,
                observer: '_modeChanged'
            },
            background: {
                type: String
            }
        },
        observers: [
            'partsChanged(parts.*)',
            'backgroundChanged(background)'
        ],
        listeners: {
            'part-tapped': 'onPartTapped',
            'update-mode': '_updateMode'
        },
        ready () {
            this.elements = {};
            this.tappedElement = null;
            this.dropzone = null;

            this.pixels = {
                0: '#ff0000',
                1: '#00ff00',
                2: '#0000ff'
            };
            this.devices = {};
            this.devices.get = this._getPartById.bind(this);
        },
        _getPartById (id) {
            if (id === 'dropzone') {
                return this.dropzone;
            }
            return this.dropzone.querySelector(`#${id}`);
        },
        backgroundChanged (bg) {
            if (this.dropzone && this.dropzone.setBackgroundColor) {
                this.dropzone.setBackgroundColor(bg);
            }
        },
        _modeChanged (mode) {
            let oldDropzone = this.dropzone,
                viewport = this.$.content,
                vpLabel = this.$$('.made-with-kano'),
                newDropzone;

            if (mode && mode.workspace.component) {
                newDropzone = document.createElement(mode.workspace.component);
            } else {
                newDropzone = document.createElement('kano-workspace-normal');
            }

            newDropzone.setAttribute('id', 'dropzone');
            newDropzone.setAttribute('width', this.mode.workspace.viewport.width);
            newDropzone.setAttribute('height', this.mode.workspace.viewport.height);

            if (newDropzone.setBackgroundColor) {
                newDropzone.setBackgroundColor(this.background);
            }

            /* Remove old dropzone and add new one */
            if (oldDropzone) {
                Polymer.dom(viewport).removeChild(oldDropzone);
            }
            Polymer.dom(viewport).insertBefore(newDropzone, vpLabel);

            /* Update dropzone reference */
            this.dropzone = newDropzone;

            this.parts.forEach((model, index) => {
                this.insertPart(`#${index}`);
            });
        },
        canDelete (el) {
            return el && !!el.model;
        },
        canEdit (el) {
            // No config panel is set for the hardware parts yet, disable the edit menu when the configPanel is set to `hardware`
            return (el && el.id === "dropzone") || (el && el.model && el.model.configPanel !== 'disabled');
        },
        isSeparatorHidden (el) {
            return !this.canDelete(el) || !this.canEdit(el);
        },
        onTap (e) {
            if (this.running) {
                return;
            }

            if (e.target.id === 'content') {
                this.clearSelection();
                this.fire('close-settings');
            } else if (e.target.id === 'dropzone') {
                this.tappedElement = e.target;
                this.tooltipTarget = e.target.getBoundingClientRect();
                this.notifyChange('open-settings-tooltip', { part: this.tappedElement.model });
                this.$.selector.clearSelection();
                if (e.target === this.tappedElement) {
                    this.fire('close-settings');
                }
            }
        },
        clearSelection () {
            this.$.selector.clearSelection();
            this.tappedElement = null;
            this.$.tooltip.close();
            this.set('tooltipTarget', null);
            this.notifyChange('close-settings-tooltip');
        },
        partFromElement () {
            let model = this.tappedElement.model;
            for (let i = 0; i <= this.parts.length; i++) {
                let part = this.parts[i];
                if (model.id === part.id) {
                    return part;
                }
            }
        },
        onPartTapped (e) {
            this.$.selector.clearSelection();
            this.tappedElement = e.detail;
            this.tooltipTarget = this.tappedElement.getBoundingClientRect();
            this.notifyChange('open-settings-tooltip', { part: this.tappedElement.model });
            if (this.tappedElement !== e.detail) {
                this.fire('close-settings');
            }
        },
        openSettings () {
            this.$.tooltip.close();
            this.tooltipTarget = null;
            if (!this.canDelete(this.tappedElement)) {
                this.fire('settings-tapped');
                return;
            }
            let part = this.partFromElement(),
                selector = this.$.selector;
            selector.select(part);
            this.fire('settings-tapped');
        },
        deletePart () {
            let part = this.partFromElement();
            this.aboutToDelete = part.name;
            if (this.checkBlockDependency(part)) {
                return this.$['external-use-warning'].open();
            } else {
                this.$['confirm-delete'].open();
            }
        },
        modalClosed (e) {
            let part = this.partFromElement();
            if (e.detail.confirmed) {
                this.fire('delete-tapped', part);
            }
        },
        checkBlockDependency (part) {
            let xmlString, xml, parser, blocks, block, blockId, pieces;
            // Get the blockly xml and parse it
            xmlString = this.code.snapshot.blocks;
            parser = new DOMParser();
            xml = parser.parseFromString(xmlString, 'text/xml');
            // Get all the 'block' elements
            blocks = xml.getElementsByTagName('block');
            // Check for every one of them...
            for (let k = 0, len = blocks.length; k < len; k++) {
                block = blocks[k];
                blockId = block.getAttribute('type');
                pieces = blockId.split('#');
                // ...if the type of the block is the part we're trying to delete
                if (pieces[0] === part.id) {
                    return true;
                }
            }
            return false;
        },
        partsChanged (e) {
            let path;
            if (this.tooltipTarget) {
                 requestAnimationFrame(() => {
                     // In case it changed before the animation frame
                     if (this.tooltipTarget) {
                         this.tooltipTarget = this.tappedElement.getBoundingClientRect();
                     }
                 });
             }
            if (!e) {
                return;
            }
            path = e.path;
            if (path === 'parts.splices') {
                let keySplices = e.value.keySplices,
                    indexSplices = e.value.indexSplices;
                if (keySplices) {
                    keySplices.forEach((splice) => {
                        splice.added.forEach(this.insertPart.bind(this));
                        splice.removed.forEach(this.removePart.bind(this));
                    });
                } else {
                    if (indexSplices) {
                        indexSplices.forEach((idxSplice)=> {
                            for (let  i = 0; i < idxSplice.addedCount; i++) {
                                this.insertPart.bind(this)(`#${idxSplice.index + i}`);
                            }
                        });
                    }
                }

            } else if (path === 'parts') {
                if (this.elements) {
                    // Clean the dropzone
                    Object.keys(this.elements).forEach(this.removePart.bind(this));
                }
                if (!this.parts) {
                    return;
                }
                // Insert the elements from the models
                this.parts.forEach((model, index) => {
                    this.insertPart(`#${index}`);
                });
            } else if (path === 'parts.length') {
                return;
            } else {
                let pieces = path.split('.'),
                    key = pieces[1],
                    subPath;
                if (!key) {
                    return;
                }
                subPath = pieces.slice(2, pieces.length);
                subPath.unshift('model');
                subPath = subPath.join('.');
                this.propagateChange(key, subPath, e.value);
            }
        },
        propagateChange (key, path, value) {
            let element = this.elements[key];
            if (!element) {
                return;
            }
            element.set(path, value);
        },
        insertPart (key) {
            let model = this.get(`parts.${key}`),
                tagName,
                element;
            tagName = model.tagName;
            element = document.createElement(tagName);
            element.setAttribute('id', model.id);
            element.addEventListener('model-changed', (e) => {
                let detail = e.detail,
                    path;
                if (!detail.path) {
                    path = `parts.${key}`;
                } else {
                    path = detail.path.replace('model', `parts.${key}`);
                }
                this.set(path, detail.value);
            });
            element.model = model;
            this.elements[key] = element;
            this.dropzone.appendChild(element);
        },
        removePart (key) {
            let element = this.elements[key];
            if (!element) {
                return;
            }
            this.dropzone.removeChild(element);
            delete this.elements[key];
        },
        runningChanged () {
            if (this.running) {
                this.classList.add('running');
                this.clearSelection();
                if (this.dropzone && this.dropzone.start) {
                    this.dropzone.start();
                }
            } else {
                if (this.dropzone && this.dropzone.stop) {
                    this.dropzone.stop();
                }
                this.classList.remove('running');
            }
        },
        getPartIndexById (id) {
            let elements = this.parts;
            for (let i = 0, len = elements.length; i < len; i++) {
                if (elements[i].id === id) {
                    return i;
                }
            }
        },
        getViewport () {
            return this.dropzone;
        },
        getViewportScale () {
            return this.$.content.getScale();
        },
        generateCover () {
            let canvas = document.createElement('canvas'),
                ctx = canvas.getContext('2d'),
                rect = this.dropzone.getBoundingClientRect(),
                scaleFactor = rect.width / this.mode.workspace.viewport.width,
                util = {
                    getStyle: this.getStyle,
                    roundRect: this.roundRect
                },
                image,
                promise = Promise.resolve();

            canvas.id = 'screenshot';
            canvas.width  = this.mode.workspace.viewport.width;
            canvas.height = this.mode.workspace.viewport.height;

            //setting background color
            ctx.fillStyle = this.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            this.parts.forEach((part) => {
                let el = this.dropzone.querySelector(`#${part.id}`);
                if (typeof el.renderOnCanvas === 'function') {
                    promise = promise.then(() => {
                        return el.renderOnCanvas(ctx, util, scaleFactor);
                    });
                }
            });
            return promise.then(() => {
                image = new Image();
                image.src = canvas.toDataURL();
                return image;
            });
        },
        /**
         * Helper to get style from element
         * @param  {Object} element  DOM element you want to inspect
         * @param  {String} css_rule CSS rule you want to get
         * @return {String} value of the css_rule for the DOM element
         */
        getStyle (element, css_rule) {
            var strValue = "";
            if (!element) {
                return strValue;
            }
            if (document.defaultView && document.defaultView.getComputedStyle) {
                strValue = document.defaultView.getComputedStyle(element, "").getPropertyValue(css_rule);
            } else if (element.currentStyle) {
                css_rule = css_rule.replace(/\-(\w)/g, function (strMatch, p1) {
                    return p1.toUpperCase();
                });
                strValue = element.currentStyle[css_rule];
            }
            return strValue;
        },
        /**
         * Draws a rounded rectangle using the current state of the canvas.
         * If you omit the last three params, it will draw a rectangle
         * outline with a 5 pixel border radius
         * @param {CanvasRenderingContext2D} ctx
         * @param {Number} x The top left x coordinate
         * @param {Number} y The top left y coordinate
         * @param {Number} width The width of the rectangle
         * @param {Number} height The height of the rectangle
         * @param {Number} [radius = 5] The corner radius; It can also be an object
         *                 to specify different radii for corners
         * @param {Number} [radius.tl = 0] Top left
         * @param {Number} [radius.tr = 0] Top right
         * @param {Number} [radius.br = 0] Bottom right
         * @param {Number} [radius.bl = 0] Bottom left
         * @param {Boolean} [fill = false] Whether to fill the rectangle.
         * @param {Boolean} [stroke = true] Whether to stroke the rectangle.
         */
        roundRect (ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke == 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            if (typeof radius === 'number') {
                radius = {tl: radius, tr: radius, br: radius, bl: radius};
            } else {
                let defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
                for (let side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                }
            }
            ctx.beginPath();
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + width - radius.tr, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
            ctx.lineTo(x + width, y + height - radius.br);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
            ctx.lineTo(x + radius.bl, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }

        },
        _updateMode (e) {
            if (this.modeComponent) {
                this.modeComponent.update(e.detail);
            }
        }
    });
</script>
