<link rel="import" href="../kano-color-wheel/kano-color-wheel.html">
<dom-module id="kano-pixel-canvas">
    <style>
    :host {
        display: block;
    }
    .pixel {
        width: 24px;
        height: 24px;
        margin: 3px;
        background-color: black;
    }
    .canvas {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        box-sizing: border-box;
    }
    .canvas-wrapper {
        padding: 4px;
        background-color: #444;
    }
    .pen {
        width: 26px;
        height: 26px;
        margin-right: 5px;
    }
    .picker {
        @apply(--layout-horizontal);
        @apply(--layout-center);
        margin-top: 16px;
    }
    </style>
    <template>
        <div class="content">
            <div class="canvas-wrapper">
                <div class="canvas" style$="[[_computeCanvasStyle(width, pixelSize, spacing)]]">
                    <template is="dom-repeat" items="[[bitmap]]" as="pixel" id="repeat">
                        <div class="pixel" id$="pixel-[[index]]" style$="[[_computePixelStyle(pixel, pixelSize, spacing)]]" on-mouseover="_pixelOver" on-mouseout="_pixelOut"></div>
                    </template>
                </div>
            </div>
        </div>
    </template>
    <script type="text/javascript">
        Polymer({
            is: 'kano-pixel-canvas',
            properties: {
                bitmap: {
                    type: Array,
                    value: () => {
                        return [['#000000']];
                    },
                    notify: true
                },
                width: {
                    type: Number,
                    value: 1
                },
                height: {
                    type: Number,
                    value: 1
                },
                pixelSize: {
                    type: Number,
                    value: 24
                },
                spacing: {
                    type: Number,
                    value: 3
                },
                penColor: {
                    type: String,
                    value: '#000000'
                },
                penType: {
                    type: String,
                    value: 'draw'
                }
            },
            ready () {
                this._mouseDown = this._mouseDown.bind(this);
                this._mouseUp = this._mouseUp.bind(this);
            },
            attached () {
                document.addEventListener('mousedown', this._mouseDown);
                document.addEventListener('touchstart', this._mouseDown);
                document.addEventListener('mouseup', this._mouseUp);
                document.addEventListener('touchend', this._mouseUp);
            },
            detached () {
                document.removeEventListener('mousedown', this._mouseDown);
                document.removeEventListener('touchstart', this._mouseDown);
                document.removeEventListener('mouseup', this._mouseUp);
                document.removeEventListener('touchend', this._mouseUp);
            },
            _paintPixel (index) {
                this.splice('bitmap', index, 1, this.penColor);
            },
            _paintGroup (indices) {
                indices.forEach(this._paintPixel.bind(this));
            },
            _blurAll () {
                let pixels = Polymer.dom(this.root).querySelectorAll('[data-color]'),
                    prevColor, pixel;
                for (let i = 0; i < pixels.length; i++) {
                    pixel = pixels[i];
                    prevColor = pixel.getAttribute('data-color');
                    if (prevColor) {
                        pixel.style.backgroundColor = prevColor;
                        pixel.removeAttribute('data-color');
                    }
                }
            },
            _hoverPixel (el) {
                el.setAttribute('data-color', el.style.backgroundColor);
                el.style.backgroundColor = this.penColor;
            },
            _hoverGroup (indices) {
                indices.forEach(index => {
                    let el = this.$$(`#pixel-${index}`);
                    el.setAttribute('data-color', el.style.backgroundColor);
                    el.style.backgroundColor = this.penColor;
                });
            },
            _computeCanvasStyle (width, pixelSize, spacing) {
                let w = (width * (pixelSize + (spacing * 2)));
                return `max-width: ${w}px; width: ${w}px;`;
            },
            _computePixelStyle (pixel) {
                return `background-color: ${pixel || '#000000'}; width: ${this.pixelSize}px; height: ${this.pixelSize}px; margin: ${this.spacing}px`;
            },
            _pixelOver (e) {
                let target = e.path ? e.path[0] : e.target,
                    model = e.model || this.$$('#repeat').modelForElement(target),
                    index = model.get('index');
                // The mouse is down, effectively paint on the bitmap, otherwise just apply a hover
                if (this.isMouseDown) {
                    if (this.penType === 'draw') {
                        this._paintPixel(index);
                    } else if (this.penType === 'fill') {
                        this._paintGroup(this.getFillGroup(index));
                    }
                    this._blurAll();
                } else {
                    if (this.penType === 'draw') {
                        this._hoverPixel(target);
                    } else if (this.penType === 'fill') {
                        this._hoverGroup(this.getFillGroup(index));
                    }
                }
            },
            getFillGroup (index) {
                let color = this.bitmap[index],
                    closeIdenticalPixels = this.getCloseIdenticalColors(index, color);
                closeIdenticalPixels.push(index);
                return closeIdenticalPixels;
            },
            getCloseIdenticalColors (index, color, checked) {
                let coord = this.indexToCoord(index),
                    closeGroup = [],
                    closeX, closeY, closeColor, closeIndex;
                checked = checked || [index];

                // Check the upper, lower, left, and right pixels
                [[-1, 0], [0, -1], [1, 0], [0, 1]].forEach(address => {
                    closeX = coord.x + address[0];
                    closeY = coord.y + address[1];
                    // The close pixel is in the frame
                    if (closeX < this.width && closeY < this.height && closeX >= 0 && closeY >= 0) {
                        closeIndex = this.coordToIndex(closeX, closeY);
                        // Stop here if the pixel was already checked
                        if (checked.indexOf(closeIndex) === -1) {
                            checked.push(closeIndex);
                            closeColor = this.bitmap[closeIndex];
                            // The close pixel is the same color and is not already in the group 
                            if (closeColor === color && index !== closeIndex) {
                                closeGroup.push(closeIndex);
                                closeGroup = closeGroup.concat(this.getCloseIdenticalColors(closeIndex, color, checked));
                            }
                         }
                    }
                });
                return closeGroup;
            },
            indexToCoord (index) {
                return {
                    x: index % this.width,
                    y: Math.floor(index / this.width)
                };
            },
            coordToIndex (x, y) {
                return y * this.width + x;
            },
            _pixelOut (e) {
                this._blurAll();
            },
            _mouseDown (e) {
                let target = e.path ? e.path[0] : e.target;
                this.isMouseDown = true;
                if (target.classList.contains('pixel')) {
                    this._pixelOver(e);
                }
            },
            _mouseUp () {
                this.isMouseDown = false;
            }
        });
    </script>
</dom-module>
