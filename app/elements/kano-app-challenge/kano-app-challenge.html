<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/kwc-style/typography.html">
<link rel="import" href="./kano-challenge-ui.html">
<link rel="import" href="../behaviors/kano-app-element-registry-behavior.html">
<link rel="import" href="../../elements/behaviors/kano-i18n-behavior.html">
<link rel="import" href="../../elements/kano-editor-banner/kano-editor-banner.html">
<link rel="import" href="./kano-challenge-behavior.html">
<link rel="import" href="../../bower_components/web-components/kano-sound-player-behavior/kano-sound-player-behavior.html">

<!--

`kano-app-challenge`

Example:
    <kano-app-challenge steps="[[steps]]" step="1"></kano-app-challenge>

 The following custom properties and mixins are also available for styling:

 Custom property | Description | Default
 ----------------|-------------|----------

@group Kano Elements
@hero hero.svg
@demo demo/kano-app-challenge.html
-->
<dom-module id="kano-app-challenge">
    <template>
        <style>
            :host {
                display: flex;
                --kano-value-preview-input-background: rgba(0, 0, 0, 0.2);
            }
            #content {
                flex: 1;
            }
            .banner-container {
                @apply --layout-vertical;
                @apply --layout-stretch;
                @apply --layout-center-justified;
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100%;
                max-height: 220px;
                pointer-events: none;
                padding: 24px;
                box-sizing: border-box;
                z-index: 1;
            }
            kano-editor-banner {
                @apply --shadow-elevation-2dp;
                border-radius: 6px;
                background: white;
                color: black;
                font-family: var(--font-body);
                pointer-events: all;
            }
            [hidden] {
                display: none !important;
            }
        </style>
        <kano-challenge-ui id="ui" step="[[selectedStep]]" on-next-step="nextStep" blocks-panel="{{blocksPanel}}" state="{{state}}" mode-ready="[[modeReady]]" idle="[[idle]]">
            <slot name="editor" id="content"></slot>
        </kano-challenge-ui>
        <div class="banner-container" id="banner-container">
            <kano-editor-banner id="banner"
                head="[[banner.head]]"
                text="[[banner.text]]"
                img-src="[[banner.icon]]"
                img-page="[[banner.imgPage]]"
                button-label="[[banner.buttonLabel]]"
                progress="[[progress]]"
                on-button-tapped="_bannerButtonTapped"
                hidden$="[[_isBannerHidden(banner)]]"></kano-editor-banner>
        </div>
    </template>
</dom-module>

<script type="text/javascript">
    /* globals Polymer, Kano, page */
    const BANNER_ICONS = {
        'default': '/assets/avatar/judoka-face.svg'
    };

    const BANNER_SOUND = '/assets/audio/sounds/card_set.wav';
    
    Polymer({
        is: 'kano-app-challenge',
        behaviors: [
            Kano.Behaviors.BlocklyValidatorBehavior,
            Kano.Behaviors.AppElementRegistryBehavior,
            Kano.Behaviors.SoundPlayerBehavior,
            Kano.Behaviors.I18nBehavior
        ],
        properties: {
            progress: {
                type: Number,
                value: 0
            },
            banner: {
                type: Object,
                value: null
            },
            state: {
                type: Object,
                notify: true
            },
            idle: Boolean,
            modeReady: {
                type: Boolean,
                value: false
            }
        },
        listeners: {
            'change': '_editorChanged',
            'selected-step-changed': '_selectedStepChanged'
        },
        _selectedStepChanged (e) {
            if (!this.selectedStep || !this.modeReady) {
                return;
            }
            this.computeBanner(this.selectedStep);
        },
        _isBannerHidden (banner) {
            return !banner;
        },
        computeBanner (step) {
            let iconId, animation;
            clearTimeout(this.showButtonTimeout);
            this.set('banner', null);
            if (this.state.hints.enabled) {
                if (step.banner) {
                    let label = (step.banner.buttonLabel || this.localize('NEXT', 'Next'));
                    this.banner = this.banner || {};
                    this.set('banner.head', step.banner.head || null);
                    this.set('banner.text', step.banner.text);
                    this.set('banner.buttonLabel', step.banner.next_button ? label : null);

                    if (this.banner.buttonLabel) {
                        if (this.bannerButtonInactive) {
                            this.$.banner.buttonState = 'inactive';
                        } else {
                            this.$.banner.buttonState = 'active';
                        }
                    } else {
                        this.$.banner.buttonState = 'hidden';
                    }
                } else {
                    this.banner = null;
                }
            } else {
                let bannerProps = this.state.hints['disabled-banner'];
                if (bannerProps) {
                    this.banner = this.banner || {};
                    this.set('banner.head', bannerProps.head || null);
                    this.set('banner.text', bannerProps.text);
                    this.set('banner.buttonLabel', this.localize('HINTS', 'Hints'));
                    
                    // Show hint button with delay
                    this.$.banner.buttonState = 'hidden';
                    this.showButtonTimeout = setTimeout(() => {
                        this.$.banner.buttonState = 'active';
                    }, 6000);
                } else {
                    this.banner = null;
                }
            }
            if (this.banner) {
                if (step.banner) {

                    this.editor.set('lockdown', step.banner.lockdown);    //disable click events if true
                    this.$.banner.showSaveButton = step.isLast;

                    if (step.isLast) {
                        this.set('banner.icon', null);
                        this.set('banner.imgPage', 'star');
                        this.set('banner.buttonLabel', Boolean(this.story.next) ?
                                this.localize('NEXT_CHALLENGE', 'Next Challenge') : this.localize('BACK_TO_CHALLENGES', 'Back to Challenges'));
                    } else if (step.banner.animation) {
                        animation = step.banner.animation;
                        this.set('banner.imgPage', animation);
                        this.set('banner.icon', null);
                    } else if (step.banner.icon) {
                        iconId = step.banner.icon;
                        this.set('banner.icon', BANNER_ICONS[iconId]);
                        this.set('banner.imgPage', null);
                    } else {
                        this.set('banner.icon', null);
                        this.set('banner.imgPage', 'judoka');
                    }
                } else {
                    //TODO quickfix for demo. Needs to be removed.
                    this.set('banner.icon', null);
                    this.set('banner.imgPage', 'judoka');
                }
                this.playSound(BANNER_SOUND);
                if ('animate' in HTMLElement.prototype) {
                    this.$.banner.animate({
                        opacity: [0, 1],
                        transform: ['scale(0.5, 0.5)', 'scale(1, 1)']
                    }, {
                        duration: 150,
                        easing: 'cubic-bezier(0.2, 0, 0.13, 1.5)'
                    });
                }
            }
            this.set('banner.progress', this.progress);
            this._fitBanner();
        },
        _bannerButtonTapped () {
            if (this.selectedStep.isLast) {
                Kano.MakeApps.Utils.onLine().then((isOnline) => {
                    if (!this.user || this.user.hasSharedInSession || this._userAlreadyShared(this.story) ||
                            this.scene.autoshareDisabled || !isOnline) {
                        this.goToNextStory();
                    } else {
                        const detail = this.$.editor.compileApp();
                        detail.title = this.story.name;
                        detail.autoshare = true;
                        this.scene.autoshareDisabled = true;
                        this.running = false;
                        this.share({ detail });
                    }
                });
            } else if (this.state.hints && this.state.hints.enabled) {
                this.nextStep();
            } else {
                this.showHints();
            }
        },
        _onLockdownClick () {
            this.$.banner.shakeButton();
        },
        _editorChanged (e) {
            // Store current step object
            let step = this.selectedStep,
                detail = e.detail;

            if (!step || !step.validation) {
                return;
            }
            this._checkEvent(step.validation, detail);
        },
        /**
         * Find the blockly element and listens to the change event
         */
        ready () {
            this._addValidator('add-part', 'matchAddPart');
            this._addValidator('background', 'matchProperty');
            this._addValidator('select-part', 'matchPartTarget');
            this._addValidator('selected-part-change', 'matchPartChange');
            this._addValidator('trigger', 'matchTrigger');
            this._addValidator('running', 'matchValue');
            this._addValidator('select-new-part', 'matchPartType');
            this._addValidator('enable-refresh', 'matchPartTarget');
            this._addValidator('disable-refresh', 'matchPartTarget');
            this._addValidator('manual-refresh', 'matchPartTarget');
            this._addValidator('open-settings-tooltip', 'matchPartTarget');
            this._addValidator('open-part-settings', 'matchPartTarget');
            this._addValidator('settings-interaction', 'matchSettingsInteraction');
            this._addValidator('light-animation-tool-changed', 'matchValue');
            this._addValidator('light-animation-paint', 'matchTool');
            this._addValidator('light-animation-preview-changed', 'matchValue');

            this._addOppositeAction('add-part', 'close-parts', '_partsClosed');
            this.changeCounts = {};
            this._onFlyoutStateChanged = this._onFlyoutStateChanged.bind(this);
            this._onLockdownClick = this._onLockdownClick.bind(this);
            this.editor = Polymer.dom(this.$.content).getDistributedNodes()[0];
            this.editor.addEventListener('lockdown-clicked', this._onLockdownClick);
            this.editor.addEventListener('blockly-ready', (e) => {
                const target = e.path ? e.path[0] : e.target;
                const workspace = target.getWorkspace();
                this.setWorkspace(workspace);
                this.blocksPanel = this._getElement('blocks-panel');
                workspace.addChangeListener(this._onFlyoutStateChanged);
            });
        },
        attached () {
            this.addEventListener('mousewheel', this.updateTooltips, true);
            window.addEventListener('resize', this.updateTooltips);
            this.loadSound(BANNER_SOUND);
        },
        detached () {
            this.removeEventListener('mousewheel', this.updateTooltips);
            window.removeEventListener('resize', this.updateTooltips);
        },
        _onFlyoutStateChanged (e) {
            if ([Blockly.Events.OPEN_FLYOUT, Blockly.Events.CLOSE_FLYOUT].indexOf(e.type) === -1) {
                return;
            }
            this.async(() => {
                this._fitBanner();
            });
        },
        _fitBanner () {
            const workspace = this._blocklyWorkspace;
            const metrics = workspace.getMetrics();
            const flyout = workspace.getFlyout_();
            const width = workspace.toolbox_ && workspace.toolbox_.opened ? flyout.getWidth() + 44 : metrics.toolboxWidth;
            this.$['banner-container'].style.left = `${width}px`;
            this.$['banner-container'].style.top = `0px`;
            this.$['banner-container'].style.width = `${metrics.viewWidth + metrics.toolboxWidth - width}px`;
        },
        _partsClosed () {
            return this._prevStep();
        },
        isNextHidden () {
            let currentStep;
            if (!this.steps) {
                return true;
            }
            currentStep = this.steps[this.step];
            if (!currentStep) {
                return true;
            }
            return !currentStep.next_button;
        },
        matchTrigger (validation, event) {
            let emitter = validation.emitter;
            if (emitter.part) {
                emitter = this.stepIds[emitter.part];
            }
            return emitter === event.trigger.emitter &&
                    validation.event === event.trigger.event;
        },
        matchPartChange (validation, event) {
            return this.matchProperty(validation, event);
        },
        matchPartTarget (validation, event) {
            let target = this.stepIds[validation.target];
            if (!event.part && validation.target) {
                return false;
            } else {
                return target === event.part.id;
            }
        },
        /**
         * Will tell if a property defined in a validation and an event matches
         * Example:
         * The validation says: 'userStyle.background' and the event says
         * 'userStyle.background', the properties match
         * The story creator can define a step that just wait for a vague action
         * to be made:
         * validation: 'position.*' will match things like 'position.x' and
         * 'position.y'
         */
        matchProperty (validation, event) {
            // Split the properties paths
            let validationParts = validation.property.split('.'),
                eventParts = event.property.split('.'),
                count = this.changeCounts[this.step];
            // Loop through the smallest part
            for (let i = 0, len = validationParts.length; i < len; i++) {
                // If the validation used the joker, the remaining parts are accepted
                if (validationParts[i] === '*') {
                    break;
                }
                // If the part doesn't match, stop
                if (validationParts[i] !== eventParts[i]) {
                    return false;
                }
            }
            if (validation.count) {
                if (count < validation.count) {
                    return false;
                }
            }
            if (typeof validation.value !== 'undefined') {
                return this.matchValue(validation, event);
            }

            return true;
        },
        matchValue (validation, event) {
            return validation.value === event.value;
        },
        matchTool (validation, event) {
            return validation.tool === event.tool;
        },
        matchAddPart (validation, event) {
            // Check the type of the added part
            if (!this.matchPartType(validation, event)) {
                return false;
            }
            // If an id is provided, save the id of the added part
            if (validation.id) {
                this.stepIds[validation.id] = event.part.id;
            }
            return true;
        },
        matchPartType (validation, event) {
            return validation.type === event.part.type;
        },
        matchSettingsInteraction (validation, event) {
            return validation.setting === event.setting;
        },
        isStepTarget (validation, id) {
            let target = this.stepIds[validation.target];
            return target === id;
        },
        isStepEvent (step, type, event) {
            return step[type] && event.type === type;
        },
        nextStep () {
            //tell UI and validator separately that step has finished
            this.$.ui.finishStep();
            Kano.Behaviors.ChallengeBehavior.nextStep.call(this);
        }
    });
</script>
