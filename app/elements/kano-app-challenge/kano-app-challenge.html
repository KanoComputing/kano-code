<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/web-components/kano-style/typography.html">
<link rel="import" href="./kano-challenge-ui.html">
<link rel="import" href="../behaviors/kano-app-element-registry-behavior.html">
<link rel="import" href="./kano-challenge-behavior.html">

<!--

`kano-app-challenge`

Example:
    <kano-app-challenge steps="[[steps]]" step="1"></kano-app-challenge>

 The following custom properties and mixins are also available for styling:

 Custom property | Description | Default
 ----------------|-------------|----------

@group Kano Elements
@hero hero.svg
@demo ./demo/kano-app-challenge.html
-->
<dom-module id="kano-app-challenge">
    <style>
        :host {
            display: flex;
        }
        #content {
            flex: 1;
        }
    </style>
    <template>
        <kano-challenge-ui id="ui" step="[[selectedStep]]" on-next-step="nextStep" blocks-panel="{{blocksPanel}}" state="{{state}}">
            <slot name="editor" id="content"></slot>
        </kano-challenge-ui>
    </template>
</dom-module>

<script type="text/javascript">
    Polymer({
        is: 'kano-app-challenge',
        behaviors: [
            Kano.Behaviors.BlocklyValidatorBehavior,
            Kano.Behaviors.AppElementRegistryBehavior
        ],
        properties: {
            state: {
                type: Object,
                notify: true
            }
        },
        observers: [
            'doneChanged(done)'
        ],
        listeners: {
            'change': '_editorChanged'
        },
        doneChanged (done) {
            if (done) {
                // Set to an out of bound index to get an undefined step
                this.step = -1;
                if (this.editor.running) {
                    this.editor.toggleRunning();
                }
            }
        },
        _editorChanged (e) {
            // Store current step object
            let step = this.selectedStep,
                detail = e.detail;

            if (!step || !step.validation) {
                return;
            }
            this._checkEvent(step.validation, detail);
        },
        /**
         * Find the blockly element and listens to the change event
         */
        ready () {
            this._addValidator('add-part', 'matchAddPart');
            this._addValidator('background', 'matchProperty');
            this._addValidator('select-part', 'matchPartTarget');
            this._addValidator('selected-part-change', 'matchPartChange');
            this._addValidator('trigger', 'matchTrigger');
            this._addValidator('running', 'matchValue');
            this._addValidator('select-new-part', 'matchPartType');
            this._addValidator('enable-refresh', 'matchPartTarget');
            this._addValidator('disable-refresh', 'matchPartTarget');
            this._addValidator('manual-refresh', 'matchPartTarget');
            this._addValidator('open-settings-tooltip', 'matchPartTarget');
            this._addValidator('open-part-settings', 'matchPartTarget');
            this._addValidator('settings-interaction', 'matchSettingsInteraction');
            this._addValidator('light-animation-tool-changed', 'matchValue');
            this._addValidator('light-animation-paint', 'matchTool');
            this._addValidator('light-animation-preview-changed', 'matchValue');

            this._addOppositeAction('add-part', 'close-parts', '_partsClosed');
            this.changeCounts = {};
            this.editor = Polymer.dom(this.$.content).getDistributedNodes()[0];
            this.editor.addEventListener('blockly-ready', (e) => {
                let target = e.path ? e.path[0] : e.target;
                this.setWorkspace(target.getWorkspace());
                this.blocksPanel = this._getElement('blocks-panel');
            });
        },
        attached () {
            this.addEventListener('mousewheel', this.updateTooltips, true);
            window.addEventListener('resize', this.updateTooltips);
        },
        detached () {
            this.removeEventListener('mousewheel', this.updateTooltips);
            window.removeEventListener('resize', this.updateTooltips);
        },
        _partsClosed () {
            return this._prevStep();
        },
        isNextHidden () {
            let currentStep;
            if (!this.steps) {
                return true;
            }
            currentStep = this.steps[this.step];
            if (!currentStep) {
                return true;
            }
            return !currentStep.next_button;
        },
        matchTrigger (validation, event) {
            let emitter = validation.emitter;
            if (emitter.part) {
                emitter = this.stepIds[emitter.part];
            }
            return emitter === event.trigger.emitter &&
                    validation.event === event.trigger.event;
        },
        matchPartChange (validation, event) {
            return this.matchProperty(validation, event);
        },
        matchPartTarget (validation, event) {
            let target = this.stepIds[validation.target];
            if (!event.part && validation.target) {
                return false;
            } else {
                return target === event.part.id;
            }
        },
        /**
         * Will tell if a property defined in a validation and an event matches
         * Example:
         * The validation says: 'userStyle.background' and the event says
         * 'userStyle.background', the properties match
         * The story creator can define a step that just wait for a vague action
         * to be made:
         * validation: 'position.*' will match things like 'position.x' and
         * 'position.y'
         */
        matchProperty (validation, event) {
            // Split the properties paths
            let validationParts = validation.property.split('.'),
                eventParts = event.property.split('.'),
                count = this.changeCounts[this.step];
            // Loop through the smallest part
            for (let i = 0, len = validationParts.length; i < len; i++) {
                // If the validation used the joker, the remaining parts are accepted
                if (validationParts[i] === '*') {
                    break;
                }
                // If the part doesn't match, stop
                if (validationParts[i] !== eventParts[i]) {
                    return false;
                }
            }
            if (validation.count) {
                if (count < validation.count) {
                    return false;
                }
            }
            return true;
        },
        matchValue (validation, event) {
            return validation.value === event.value;
        },
        matchTool (validation, event) {
            return validation.tool === event.tool;
        },
        matchAddPart (validation, event) {
            // Check the type of the added part
            if (!this.matchPartType(validation, event)) {
                return false;
            }
            // If an id is provided, save the id of the added part
            if (validation.id) {
                this.stepIds[validation.id] = event.part.id;
            }
            return true;
        },
        matchPartType (validation, event) {
            return validation.type === event.part.type;
        },
        matchSettingsInteraction (validation, event) {
            return validation.setting === event.setting;
        },
        isStepTarget (validation, id) {
            let target = this.stepIds[validation.target];
            return target === id;
        },
        isStepEvent (step, type, event) {
            return step[type] && event.type === type;
        },
        nextStep () {
            //tell UI and validator separately that step has finished
            this.$.ui.finishStep();
            Kano.Behaviors.ChallengeBehavior.nextStep.call(this);
        },
        hintUsed () {
            this.set('hints.used', this.hints.used + 1);
        }
    });
</script>
