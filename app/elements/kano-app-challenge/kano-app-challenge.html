<link rel="import" href="../../bower_components/marked-element/marked-element.html">
<link rel="import" href="../kano-focus-on/kano-focus-on.html">
<link rel="import" href="../kano-tooltip/kano-tooltip.html">
<link rel="import" href="../kano-arrow/kano-arrow.html">
<link rel="import" href="../kano-blockly-block/kano-blockly-block.html">
<link rel="import" href="../behaviors/kano-validator-behavior.html">
<link rel="import" href="../behaviors/kano-blockly-validator-behavior.html">
<dom-module id="kano-app-challenge">
    <style>
    :host {
        display: block;
        @apply(--layout-vertical);
        --tooltip-color: #21596F;
    }
    :host .instruction-overlay {
        @apply(--layout-horizontal);
        @apply(--layout-center);
        @apply(--layout-center-justified);
        padding: 5px;
    }
    :host button {
        @apply(--kano-button);
        background-color: var(--color-green, green);
        margin-left: 10px;
    }
    :host content {
        @apply(--layout-flex);
    }
    :host #modal {
        border-radius: 4px;
    }
    :host .modal-content {
        @apply(--layout-vertical);
        @apply(--layout-center);
        @apply(--layout-center-justified);
        font-family: var(--font-body, Arial);
        font-weight: 500;
        font-size: 1.4em;
        color: black;
    }
    :host .modal-content button {
        @apply(--kano-button);
        margin-top: 15px;
        color: #435055;
    }
    :host .tooltip-content {
        @apply(--layout-vertical);
        @apply(--layout-center);
    }
    :host .tooltip-content button {
        margin-top: 10px;
        background-color: white;
        color: #435055;
        text-shadow: none;
    }
    kano-tooltip {
        z-index: 101;
        --kano-tooltip-background-color: var(--tooltip-color);
        --kano-tooltip-border-color: white;
        --kano-tooltip-border-width: 1px;
        color: white;
        --kano-tooltip: {
            box-shadow: 0px 2px 0px 0px rgba(0, 0, 0, 0.25);
            padding: 18px 26px 20px;
            font-size: 20px;
            line-height: 25px;
        };
        --kano-tooltip-caret: {
            box-shadow: 0px 0px 0px 0px;
        };
    }
    kano-tooltip[position="top"] {
        --kano-tooltip-caret: {
            box-shadow: 0px 0px 0px 2px rgba(0, 0, 0, 0.25);
        };
    }
    kano-tooltip[position="left"] {
        --kano-tooltip-caret: {
            box-shadow: 2px 0px 0px 0px rgba(0, 0, 0, 0.25);
        };
    }
    kano-tooltip[position="right"] {
        --kano-tooltip-caret: {
            box-shadow: 0px 2px 0px 0px rgba(0, 0, 0, 0.25);
        };
    }
    .tooltip-text kano-blockly-block {
        line-height: 0px;
        vertical-align: middle;
        display: inline-block;
    }
    </style>
    <template>
        <content select=".editor" id="content"></content>
        <kano-focus-on id="focus" breathe></kano-focus-on>
        <kano-arrow source="[[arrow.source]]" target="[[arrow.target]]" id="arrow">
            <iron-image class="arrow-image" src="/assets/icons/blue-arrow.svg" width="[[arrow.size]]" height="[[arrow.size]]" sizing="contain"></iron-image>
        </kano-arrow>
        <template is="dom-repeat" items="{{tooltips}}" as="tooltip">
            <kano-tooltip target="[[tooltip.target]]" position="[[tooltip.position]]">
                <div class="tooltip-content">
                    <div class="tooltip-text">
                        <marked-element markdown="[[tooltip.text]]">
                            <div class="markdown-html"></div>
                        </marked-element>
                    </div>
                    <button type="button" on-tap="nextStep" hidden$="[[!tooltip.next_button]]">Next</button>
                </div>
            </kano-tooltip>
        </template>
        <paper-dialog id="modal"
                      modal>
            <div class="modal-content">
                <div class="text">
                    <marked-element markdown="[[selectedStep.modal.text]]">
                        <div class="markdown-html"></div>
                    </marked-element>
                </div>
                <button type="button" on-tap="nextStep">Next</button>
            </div>
        </paper-dialog>
    </template>
</dom-module>

<script type="text/javascript">
    /* globals Polymer, Kano */

    Polymer({
        is: 'kano-app-challenge',
        behaviors: [Kano.Behaviors.ValidatorBehavior, Kano.Behaviors.BlocklyValidatorBehavior],
        properties: {
            tooltips: {
                type: Array
            },
            selectedStep: {
                type: Object,
                computed: 'computeSelectedStep(steps, step)'
            },
            arrow: {
                type: Object
            },
            currentStep: {
                type: Number,
                notify: true,
                value: 0
            },
            started: {
                type: Boolean,
                value: false
            }
        },
        observers: [
            'stepChanged(steps, step, started)',
            'doneChanged(done)'
        ],
        listeners: {
            'change': 'editorChanged'
        },
        doneChanged (done) {
            // Reset everything when the challenge is done
            if (done) {
                this.set('tooltips', []);
                this.$.arrow.hide();
                this.set('arrow', {});
                this.focus.hide();
                this.modal.close();

                if (this.editor.running) {
                    this.editor.toggleRunning();
                }
            }
        },
        computeSelectedStep () {
            return this.steps[this.step];
        },
        /**
         * Find the blockly element and listens to the change event
         */
        ready () {
            this.validators = {
                "background": this.matchProperty.bind(this),
                "add-part": this.matchAddPart.bind(this),
                "select-part": this.matchPartTarget.bind(this),
                "selected-part-change": this.matchPartChange.bind(this),
                "trigger": this.matchTrigger.bind(this),
                "running": this.matchValue.bind(this),
                "select-new-part": this.matchPartType.bind(this),
                "open-part-config": this.matchPartTarget.bind(this),
                "enable-refresh": this.matchPartTarget.bind(this),
                "disable-refresh": this.matchPartTarget.bind(this),
                "manual-refresh": this.matchPartTarget.bind(this),
                "open-settings-tooltip": this.matchPartTarget.bind(this),
                "open-part-settings": this.matchPartTarget.bind(this)
            };
            this.changeCounts = {};
            this.editor = Polymer.dom(this.$.content).getDistributedNodes()[0];
            this.focus = this.$.focus;
            this.modal = this.$.modal;
        },
        attached () {
            this.isAttached = true;
            this.step_number = 0;
            this.progress = 0;
            this.fire('attached');
        },
        computeTooltips (step) {
            this.set('tooltips', []);
            this.debounce('computeTooltips', () => {
                let tooltips = step.tooltips || [];
                tooltips = tooltips.map((tooltip) => {
                    let target = this.getDeepElement(tooltip.location),
                        rect = target.getBoundingClientRect();
                    tooltip.target = rect;
                    tooltip.text = this._processMarkdown(tooltip.text);
                    return tooltip;
                });
                this.set('tooltips', tooltips);
            }, 200);
        },
        _processMarkdown (text) {
            let reg = /<kano-blockly-block(.*)type="(.+)"(.*)><\/kano-blockly-block>/g;
            return text.replace(reg, (match, before, type, after) => {
                let pieces = type.split('#');
                if (pieces.length > 1) {
                    pieces[0] = this.stepIds[pieces[0]] || pieces[0];
                }
                type = pieces.join('#');
                return `<kano-blockly-block${before}type="${type}"${after}></kano-blockly-block>`;
            });
        },
        computeArrow (step) {
            let source, target;
            if (!step.arrow) {
                this.$.arrow.hide();
                this.set('arrow', {});
                return;
            }
            source = this.getDeepElement(step.arrow.source);
            target = this.getDeepElement(step.arrow.target);
            source = source.getBoundingClientRect();
            target = target.getBoundingClientRect();
            this.set('arrow', {
                source,
                target,
                size: step.arrow.size || 70
            });
        },
        stepChanged () {
            let step,
                focusString;
            // Prevent the loading of the saved app before the store is initialized
            if (!this.isAttached) {
                this.addEventListener('attached', this.stepChanged.bind(this));
                return;
            }
            if (!this.started) {
                return;
            }
            this.debounce('stepChanged', () => {
                if (!this.steps) {
                    return;
                }
                step = this.steps[this.step];
                if (!step) {
                    return;
                }
                if (step.load_app) {
                    this.fire('load', step.load_app);
                }
                if (step.save_app) {
                    this.fire('save', {
                        id: step.save_app,
                        stepIds: this.stepIds,
                        blockIds: this.blockIds
                    });
                }
                if (step.save_to_storage) {
                    this.fire('save-to-storage');
                }
                if (step.focus) {
                    focusString = JSON.stringify(step.focus);
                    if (focusString !== this.previousFocus) {
                        this.focus.hide();
                        this.deepFocus(step.focus);
                        this.previousFocus = JSON.stringify(step.focus);
                    }
                } else {
                    this.focus.hide();
                }
                this.modal.close();
                if (step.modal) {
                    step.modal.text = this._processMarkdown(step.modal.text);
                    this.modal.open();
                }
                this.set('currentStep', this.currentStep + 1);
                this.computeTooltips(step);
                this.computeArrow(step);
            }, 10);
        },
        getDeepElement (selector) {
            let pieces,
                element = this.editor,
                partId,
                piece,
                found,
                block;
            if (typeof selector == 'object') {
                if (selector.block) {
                    block = this.getTargetBlock(selector.block);
                    return block.getSvgRoot();
                } else if (selector.category) {
                    let cat = selector.category;
                    if (cat.part) {
                        cat = this.stepIds[cat.part];
                    }
                    return this.editor.getBlocklyWorkspace().getCategoryElementById(cat);
                } else if (selector.flyout_block) {
                    let type = selector.flyout_block;
                    if (type.part) {
                        type = `${this.stepIds[type.part]}#${type.type}`;
                    }
                    return this.editor.getBlocklyWorkspace().getFlyoutBlockByType(type).svgPath_;
                }
                partId = this.stepIds[selector.part];
                selector = `${selector.path}.part-${partId},${partId}`;
            }
            pieces = selector.split('.');
            for (let i = 0, len = pieces.length; i < len; i++) {
                piece = pieces[i].split(',').join(',#');
                if (element.root) {
                    found = element.root.querySelector(`#${piece}`);
                }
                if (!found) {
                    found = element.querySelector(`#${piece}`);
                }
                element = found;
            }
            return element;
        },
        deepFocus (selector) {
            let targets;
            targets = Array.isArray(selector) ? selector : [selector];
            targets = targets.map(this.getDeepElement.bind(this));
            this.focus.show(targets);
        },
        isNextHidden () {
            let currentStep;
            if (!this.steps) {
                return true;
            }
            currentStep = this.steps[this.step];
            if (!currentStep) {
                return true;
            }
            return !currentStep.next_button;
        },
        matchTrigger (validation, event) {
            let emitter = validation.emitter;
            if (emitter.part) {
                emitter = this.stepIds[emitter.part];
            }
            return emitter === event.trigger.emitter &&
                    validation.event === event.trigger.event;
        },
        matchPartChange (validation, event) {
            return this.matchProperty(validation, event);
        },
        matchPartTarget (validation, event) {
            let target = this.stepIds[validation.target];
            if (!event.part && validation.target) {
                return false;
            } else {
                return target === event.part.id;
            }
        },
        /**
         * Will tell if a property defined in a validation and an event matches
         * Example:
         * The validation says: 'userStyle.background' and the event says
         * 'userStyle.background', the properties match
         * The story creator can define a step that just wait for a vague action
         * to be made:
         * validation: 'position.*' will match things like 'position.x' and
         * 'position.y'
         */
        matchProperty (validation, event) {
            // Split the properties paths
            let validationParts = validation.property.split('.'),
                eventParts = event.property.split('.'),
                count = this.changeCounts[this.step];
            // Loop through the smallest part
            for (let i = 0, len = validationParts.length; i < len; i++) {
                // If the validation used the joker, the remaining parts are accepted
                if (validationParts[i] === '*') {
                    break;
                }
                // If the part doesn't match, stop
                if (validationParts[i] !== eventParts[i]) {
                    return false;
                }
            }
            if (validation.count) {
                if (count < validation.count) {
                    return false;
                }
            }
            return true;
        },
        matchValue (validation, event) {
            return validation.value === event.value;
        },
        matchAddPart (validation, event) {
            // Check the type of the added part
            if (!this.matchPartType(validation, event)) {
                return false;
            }
            // If an id is provided, save the id of the added part
            if (validation.id) {
                this.stepIds[validation.id] = event.part.id;
            }
            return true;
        },
        matchPartType (validation, event) {
            return validation.type === event.part.type;
        },
        isStepTarget (validation, id) {
            let target = this.stepIds[validation.target];
            return target === id;
        },
        isStepEvent (step, type, event) {
            return step[type] && event.type === type;
        },
        /**
         * Try to match the blockly event to the current step
         * @param  {Event} e  A blockyl change event
         */
        editorChanged (e) {
            // Store current step object
            let step = this.steps[this.step],
                detail = e.detail;

            if (!step || !step.validation || this.done) {
                return;
            }
            Object.keys(step.validation).forEach((type) => {
                let validation;
                if (type !== detail.type) {
                    return;
                }
                validation = step.validation[type];
                if (validation === true) {
                    return this.nextStep();
                }
                this.changeCounts[this.step] = this.changeCounts[this.step] + 1 || 1;
                if (type === 'blockly') {
                    return this.handleBlocklyChange(validation, detail.event);
                }
                if (typeof this.validators[type] === 'function' &&
                        this.validators[type](validation, detail)) {
                    this.nextStep();
                }
            });
        }
    });
</script>
