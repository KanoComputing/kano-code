<script type="text/javascript">

    window.Kano = window.Kano || {};

    window.Kano.Behaviors = window.Kano.Behaviors || {};
    
    window.Kano.Behaviors.ChallengeBehavior = {
        properties: {
            steps: {
                type: Object
            },
            step: {
                type: Number,
                value: 0,
                notify: true
            },
            selectedStep: {
                type: Object,
                computed: 'computeSelectedStep(steps, step, started)',
                notify: true
            },
            started: {
                type: Boolean,
                value: false
            },
            hintStats: {
                type: Object,
                value: {
                    total: 0,
                    used: 0
                },
                notify: true
            }
        },
        computeSelectedStep () {
            let selectedStep;
            if (!this.started) {
                return null;
            }

            selectedStep = this.steps[this.step];

            if (!selectedStep) {
                return null;
            }

            // Deep clone the step to not change the original step when updating the ids
            selectedStep = JSON.parse(JSON.stringify(selectedStep));

            // update stats if step includes optional hint
            if (selectedStep['set-state'] && selectedStep['set-state'].hints && selectedStep['set-state'].hints.enabled === false) {
                this.set('hintStats.total', this.hintStats.total + 1);
            }

            if (selectedStep.tooltips) {
                selectedStep.tooltips = selectedStep.tooltips.map(tooltip => {
                    tooltip.location = this.processLocation(tooltip.location);
                    tooltip.text = this._processMarkdown(tooltip.text || '');
                    return tooltip;
                });
            }
            if (selectedStep.arrow) {
                selectedStep.arrow.source = this.processLocation(selectedStep.arrow.source);
                selectedStep.arrow.target = this.processLocation(selectedStep.arrow.target);
            }
            selectedStep.highlight = this.processLocation(selectedStep.highlight);
            if (selectedStep.phantom_block) {
                selectedStep.phantom_block.location = this.processLocation(selectedStep.phantom_block.location);
            }
            if (selectedStep.modal) {
                selectedStep.modal.text = this._processMarkdown(selectedStep.modal.text);
            }
            if (selectedStep.reward) {
                selectedStep.play_on_end = "puzzle_success";
            }
            return selectedStep;
        },
        /**
         * Changes the location to adapt to the current context 
         */
        processLocation (location) {
            if (typeof location === 'object') {
                if (location.category) {
                    let cat = location.category;
                    if (cat.part) {
                        location.category = this.stepIds[cat.part];
                    } else if (cat.rawPart) {
                        location.category = cat.rawPart;
                    }
                } else if (location.flyout_block) {
                    let type = location.flyout_block,
                        partId;
                    if (type.part) {
                        partId = this.stepIds[type.part];
                    } else if (type.rawPart) {
                        partId = type.rawPart;
                    }
                    if (partId) {
                        location.flyout_block = `${partId}#${type.type}`;
                    }
                } else if (location.path && (location.part || location.rawPart)) {
                    let partId = location.part ? this.stepIds[location.part] : location.rawPart;
                    location = `${location.path}-part-${partId}`;
                } else if (location.part || location.rawPart) {
                    location.part = location.part ? this.stepIds[location.part] : location.rawPart;
                } else if (location.block) {
                    if (typeof location.block === 'string') {
                        location.block = {
                            id: this.blockIds[location.block]
                        };
                    } else if (location.block.id) {
                        location.block.id = this.blockIds[location.block.id];
                    } else if (location.block.rawId) {
                        location.block.id = location.block.rawId;
                    }
                }
            }
            return location;
        },
        _processMarkdown (text) {
            let reg = /<kano-blockly-block(.*)type="(.+)"(.*)><\/kano-blockly-block>/g;
            return text.replace(reg, (match, before, type, after) => {
                let pieces = type.split('#');
                if (pieces.length > 1) {
                    pieces[0] = this.stepIds[pieces[0]] || pieces[0];
                }
                type = pieces.join('#');
                return `<kano-blockly-block${before}type="${type}"${after}></kano-blockly-block>`;
            });
        },
        /**
         * Move to the next step or set the challenge as done
         */
        nextStep () {
            // The current step was injected, we remove it form the array
            if (this.selectedStep.injected) {
                this.splice('steps', this.step, 1);
                // Use `_goToStep` to force a refresh of the current step 
                this._goToStep(this.step);
            } else {
                if (this.step < this.steps.length - 1) {
                    this.step++;
                } else {
                    this.set('done', true);
                    this.fire('scene-done');
                }
            }
        },
        stepChanged () {
            this.selectedStep = this.computeSelectedStep();
        },
        _prevStep () {
            if (this.step > 0) {
                this.step--;
            }
        },
        _goToStep (index) {
            // Force a change notification
            if (this.step === index) {
                this.set('step', index - 1);
            }
            this.set('step', index);
        },
        _injectStep (step, offset) {
            let index = this.step + (typeof offset === 'undefined' ? 1 : offset);
            step.injected = true;
            // Insert the new step just after that
            this.splice('steps', index, 0, step);
            // jump to the new step
            this._goToStep(index);
        },
        _updateStep (step) {
            step.injected = true;
            this.set(`steps.${this.step}`, step);
            this.stepChanged();
        }
    };
</script>
