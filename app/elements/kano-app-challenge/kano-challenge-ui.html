<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/iron-image/iron-image.html">
<link rel="import" href="../../bower_components/marked-element/marked-element.html">
<link rel="import" href="../../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../kano-tooltip/kano-tooltip.html">
<link rel="import" href="../kano-arrow/kano-arrow.html">
<link rel="import" href="../kano-blockly-block/kano-blockly-block.html">
<link rel="import" href="../kano-highlight/kano-highlight.html">
<link rel="import" href="../kano-value-preview/kano-value-preview.html">
<link rel="import" href="../behaviors/kano-app-element-registry-behavior.html">
<link rel="import" href="../behaviors/kano-blockly-validator-behavior.html">
<link rel="import" href="../behaviors/kano-i18n-behavior.html">
<link rel="import" href="../../bower_components/web-components/kano-sound-player-behavior/kano-sound-player-behavior.html">

<link rel="import" href="../../bower_components/kwc-style/typography.html">


<!--

`kano-challenge-ui`

Example:
    <kano-challenge-ui step="[[currentStep]]"></kano-challenge-ui>

 The following custom properties and mixins are also available for styling:

 Custom property | Description | Default
 ----------------|-------------|----------

@group Kano Elements
@hero hero.svg
@demo ./demo/kano-challenge-ui.html
-->
<dom-module id="kano-challenge-ui">
    <template>
        <style>
            @keyframes pulse {
                0% {
                    transform: scale(1, 1);
                }
                10% {
                    transform: scale(1.3, 1.3);
                }
                100% {
                    transform: scale(1, 1);
                }
            }
            @keyframes ripple {
                0% {
                    transform: scale(0, 0);
                    opacity: 1;
                }
                75% {
                    transform: scale(0, 0);
                    opacity: 1;
                }
                85% {
                    opacity: 0;
                }
                100% {
                    transform: scale(1.5, 1.5);
                    opacity: 0;
                }
            }
            :host {
                @apply --layout-vertical;
                flex: 1;
                --tooltip-color: white;
            }
            :host .instruction-overlay {
                @apply --layout-horizontal;
                @apply --layout-center;
                @apply --layout-center-justified;
                padding: 5px;
            }
            :host button {
                @apply --kano-button;
                background-color: var(--color-grassland);
                color: #fff;
                text-shadow: none;
                font-size: 14px;
                font-weight: bold;
                line-height: 18px;
                border-radius: 3px;
                padding: 7px 24px;
                margin-left: 12px;
            }
            :host #modal {
                border-radius: 4px;
            }
            :host .modal-content {
                @apply --layout-vertical;
                @apply --layout-center;
                @apply --layout-center-justified;
                font-family: var(--font-body, Arial);
                font-size: 16px;
                color: black;
            }
            :host .modal-content button {
                @apply --kano-button;
                margin: 15px 0 0;
                color: #435055;
            }
            :host .tooltip-content {
                @apply --layout-vertical;
                @apply --layout-center;
            }
            :host .tooltip-content button {
                margin: 12px 0 0 0;
            }
            kano-tooltip {
                z-index: 201;
                --kano-tooltip-background-color: var(--tooltip-color);
                --kano-tooltip-border-color: white;
                --kano-tooltip-border-width: 1px;
                color: black;
                font-family: var(--font-body);
                --kano-tooltip: {
                    padding: 16px 26px 16px;
                };
            }
            kano-arrow {
                z-index: 201;
            }
            [slot="markdown-html"] p {
                line-height: 18px;
            }
            [slot="markdown-html"] img {
                max-height: 50px;
            }
            [slot="markdown-html"] img:not(:first-child) {
                margin-top: 12px;
            }
            .markdown-html kano-blockly-block {
                line-height: 0px;
                vertical-align: middle;
                display: inline-block;
            }
            .beacon-wrapper {
                position: relative;
                @apply --layout-vertical;
                @apply --layout-center;
                @apply --layout-center-justified;
            }
            .beacon {
                width: 30px;
                height: 30px;
                border-radius: 50%;
                background-color: rgba(254, 192, 45, 0.40);
                @apply --layout-vertical;
                @apply --layout-center;
                @apply --layout-center-justified;
            }
            .beacon.animate {
                animation: 1s ease-out infinite pulse;
            }
            .beacon .core {
                width: 12px;
                height: 12px;
                background: #fec02d;
                border-radius: 50%;
                border: 2px solid white;
            }
            .beacon-wrapper .ring {
                position: absolute;
                width: 800px;
                height: 800px;
                border-radius: 50%;
                background-color: rgba(254, 192, 45, 0.20);
                transform: scale(0, 0);
            }
            .beacon-wrapper .ring.animate {
                animation: 5s ease-out ripple;
                animation-delay: 400ms;
                animation-iteration-count: infinite;
            }
            .markdown-html p {
                margin: 0px;
            }
            .tooltip-content .emoji, .modal-content .emoji {
                max-width: 18px;
                max-height: 18px;
                transform: translateY(4px);
            }
            [hidden] {
                visibility: hidden !important;
                opacity: 0 !important;
            }
        </style>
        <slot name="editor" id="content"></slot>
        <kano-highlight id="highlight" x="[[highlight.x]]" y="[[highlight.y]]" width="[[highlight.width]]" height="[[highlight.height]]" hidden$="[[idle]]"></kano-highlight>
        <kano-arrow source="[[arrow.source]]" target="[[arrow.target]]" angle="[[arrow.angle]]" id="arrow" hidden$="[[idle]]">
            <iron-image slot="arrow-image" src="/assets/icons/white_arrow.svg" width="[[arrow.size]]" height="[[arrow.size]]" sizing="contain"></iron-image>
        </kano-arrow>
        <kano-arrow target="[[beacon.target]]" bounce="0" angle="[[beacon.angle]]" offset="[[beacon.offset]]" hidden$="[[idle]]">
            <div class="beacon-wrapper" slot="arrow-image">
                <div class="ring" id="ring" on-animationiteration="_ringAnimationIterated" on-animationstart="_ringAnimationIterated"></div>
                <div class="beacon" id="beacon">
                    <div class="core"></div>
                </div>
            </div>
        </kano-arrow>
        <template is="dom-repeat" items="{{tooltips}}" as="tooltip" on-dom-change="_tooltipDomChanged">
            <kano-tooltip id$="tooltip-[[index]]"
                          target="[[tooltip.target]]"
                          position="[[tooltip.position]]"
                          z-index="[[tooltip.zIndex]]"
                          tracking="[[tooltip.tracking]]"
                          bounce$="[[tooltip.bounce]]"
                          on-tap="_stopPropagation"
                          hidden$="[[idle]]">
                <div class="tooltip-content">
                    <div class="tooltip-text">
                        <marked-element markdown="[[tooltip.text]]">
                            <div class="markdown-html" slot="markdown-html"></div>
                        </marked-element>
                    </div>
                    <button type="button" on-tap="_nextStep" hidden$="[[!tooltip.next_button]]">[[localize('NEXT', 'Next')]]</button>
                </div>
            </kano-tooltip>
        </template>
        <paper-dialog id="modal" modal>
            <div class="modal-content">
                <div class="text">
                    <marked-element markdown="[[selectedStep.modal.text]]">
                        <div class="markdown-html" slot="markdown-html"></div>
                    </marked-element>
                </div>
                <button type="button" on-tap="_nextStep">[[localize('NEXT', 'Next')]]</button>
            </div>
        </paper-dialog>
    </template>
</dom-module>

<script type="text/javascript">
    Polymer({
        is: 'kano-challenge-ui',
        behaviors: [
            Kano.Behaviors.AppElementRegistryBehavior,
            Kano.Behaviors.SoundPlayerBehavior,
            Kano.Behaviors.I18nBehavior,
            Polymer.IronResizableBehavior
        ],
        properties: {
            tooltips: {
                type: Array
            },
            step: {
                type: Object
            },
            arrow: {
                type: Object
            },
            state: {
                type: Object,
                value: () => {
                    return {
                        hints: {
                            enabled: true
                        }
                    };
                },
                notify: true
            },
            idle: {
                type: Boolean,
                observer: '_onIdleChanged'
            },
            modeReady: {
                type: Boolean,
                value: false,
                observer: '_onModeReadyChanged'
            }
        },
        observers: [
            '_setupWithDelay(step, state.*)'
        ],
        listeners: {
            'change': '_editorChanged'
        },
        _stopPropagation (e) {
            e.preventDefault();
            e.stopPropagation();
        },
        _editorChanged (e) {
            // Store current step object
            let step = this.selectedStep,
                detail = e.detail;

            if (!step || this.done) {
                return;
            }
            if (this.tooltips && detail.type === 'blockly' && detail.event.type === 'move') {
                this.updateTooltips();
            }
        },
        computeSelectedStep () {
            return this.steps[this.step];
        },
        /**
         * Find the blockly element and listens to the change event
         */
        ready () {
            this.modal = this.$.modal;
            this.highlight = {};
            this.loadSound('/assets/audio/sounds/ding.mp3');
            this._onRefit = this._onRefit.bind(this);
            this.eventsCausingRefit = {
                'toolbox-scroll': ['flyout_block'],
                'workspace-scroll': ['block'],
                'block-move': ['block'],
                'iron-resize': 'all'
            };
        },
        attached () {
            this.editor = Polymer.dom(this.$.content).getDistributedNodes()[0];
            this.updateTooltips = this.updateTooltips.bind(this);
            this.addEventListener('mousewheel', this.updateTooltips, true);
            window.addEventListener('resize', this.updateTooltips);
            Object.keys(this.eventsCausingRefit).forEach(eventName => {
                this.addEventListener(eventName, this._onRefit);
            });
        },
        detached () {
            this.removeEventListener('mousewheel', this.updateTooltips);
            window.removeEventListener('resize', this.updateTooltips);
            Object.keys(this.eventsCausingRefit).forEach(eventName => {
                this.removeEventListener(eventName, this._onRefit);
            });
        },
        getToolbox () {
            return this.editor.getBlocklyWorkspace().toolbox;
        },
        _nextStep () {
            this.fire('next-step');
        },
        _onResize () {
            let step = this.step;
            if (!step) {
                return;
            }

            if (step.beacon) {
                this._fitBeacon(step);
            }

            if (step.arrow) {
                this._fitArrow(step);
            }

            this._fitTooltips(step);
        },
        _onRefit (e) {
            const targetConcerned = this.eventsCausingRefit[e.type];
            this._refitUiElements(targetConcerned);
        },
        _refitUiElements (targetConcerned) {
            const step = this.step;

            if (!step) {
                return;
            }

            if (step.beacon && this._targetIsConcerned(step.beacon.target, targetConcerned)) {
                this._fitBeacon(step);
            }

            if (step.arrow && this._targetIsConcerned(step.arrow.target, targetConcerned)) {
                this._fitArrow(step);
            }
            this._fitTooltips(step);
        },
        /**
         * Checks if the target of the beacon matches the type of targets concerned by the refit event received
         */
        _targetIsConcerned (target, targetTypes) {
            if (targetTypes === 'all') {
                return true;
            }
            return typeof target === 'object' && Object.keys(target).some(key => targetTypes.indexOf(key) !== -1);
        },
        computeTooltips (step) {
            this.set('tooltips', []);
            this.debounce('computeTooltips', () => {
                this._fitTooltips(step, true);
            }, 200);
        },
        _fitTooltips (step, scroll) {
            /* With hints disabled, only show tooltips for injected steps */
            if (!this.state.hints.enabled && !step.injected) {
                this.tooltips = [];
                return;
            }

            let tooltips = step.tooltips || [];
            tooltips = tooltips.map(tooltip => {
                let copy = Object.assign({}, tooltip);
                copy.target = this._getTargetElement(tooltip.location);

                if (!copy.target) {
                    return;
                }

                if ('getBoundingClientRect' in copy.target) {
                    copy.target = copy.target.getBoundingClientRect();
                }

                if (scroll) {
                    this._scrollWorkspaceOnTargetIfNeeded(copy.target, tooltip.location);
                }

                copy.text = tooltip.text;
                copy.tracking = !!tooltip.tracking;

                return copy;
            });
            // Forces a recompute on the dom-repeat to make sure all tooltips are updated
            this.set('tooltips', []);
            this.async(() => {
                this.set('tooltips', tooltips);
            });
        },
        _tooltipDomChanged (e) {
            let tooltips = Polymer.dom(this.root).querySelectorAll('kano-tooltip[bounce]'),
                offset,
                transform,
                tooltip;
            for (let i = 0; i < tooltips.length; i++) {
                tooltip = tooltips[i];
                offset = 70;
                if (tooltip.position === 'top' || tooltip.position === 'bottom') {
                    transform = 'translateY';
                } else {
                    transform = 'translateX';
                }
                if (tooltip.position === 'top' || tooltip.position === 'left') {
                    offset *= -1;
                }
                tooltips[i].animate([{
                    transform: `${transform}(${offset}px)`
                },{
                    transform: `${transform}(0px)`
                },{
                    transform: `${transform}(${offset}px)`
                }], {
                    duration: 40 * 25,
                    easing: 'ease-in-out',
                    iterations: Infinity
                });
            }
        },
        computeArrow (step) {
            if (!step || !step.arrow || (!this.state.hints.enabled && !step.injected)) {
                this.$.arrow.hide();
                this.arrow = {};
                return;
            }
            this.async(() => {
                this._fitArrow(step, true);
            }, 300);
        },
        _fitArrow (step, scroll) {
            let source, target;

            if (step.arrow.source) {
                source = this._getTargetElement(step.arrow.source);
                if ('getBoundingClientRect' in source) {
                    source = source.getBoundingClientRect();
                }
            }
            target = this._getTargetElement(step.arrow.target);

            if ('getBoundingClientRect' in target) {
                target = target.getBoundingClientRect();
            }
            if (scroll) {
                this._scrollWorkspaceOnTargetIfNeeded(target, step.arrow.target);
            }
            this.set('arrow', {
                source,
                target,
                size: (step.arrow.size || 70) * 0.6,
                angle: step.arrow.angle || 0
            });
        },
        computeBeacon (step) {
            this.$.beacon.animate({
                opacity: [1, 0]
            }, {
                duration: 200,
                fill: 'forwards'
            });

            clearTimeout(this._ringSoundTimeout);
            this._ringAnimationCount = 0;

            this.toggleClass('animate', false, this.$.beacon);
            this.toggleClass('animate', false, this.$.ring);

            if (!step || !step.beacon || (!this.state.hints.enabled && !step.injected)) {
                return;
            }

            this.async(() => {
                this._fitBeacon(step, true);
            }, 300);
        },
        _scrollWorkspaceOnTargetIfNeeded (target, location) {
            if (location && location.block) {
                let workspace = this.editor.getBlocklyWorkspace(),
                    workspaceRect = workspace.svgBackground_.getBoundingClientRect(),
                    viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                    viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
                    block;
                if (target &&
                        (target.top + target.height > workspaceRect.top + workspaceRect.height) ||
                        (target.left + target.width > workspaceRect.left + workspaceRect.width) ||
                        (target.top < 0) ||
                        (target.left < 0)) {
                    block = this.getTargetBlock(location.block);
                    workspace.scrollBlockIntoView(block, true);
                }
            }
        },
        _fitBeacon (step, scroll) {
            let target = this._getTargetElement(step.beacon.target),
                angle = step.beacon.angle || 0,
                offset = step.beacon.offset || 10,
                viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                viewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

            if (target && ('getBoundingClientRect' in target)) {
                target = target.getBoundingClientRect();
            }

            if (scroll) {
                this._scrollWorkspaceOnTargetIfNeeded(target, step.beacon.target);
            }

            // Check if the target is out of the viewport (vertically)
            if (target && target.top + target.height > viewportHeight) {
                if (step.beacon.target.flyout_block) {
                    let toolbox = this._getElement('blockly-toolbox');
                    // Force a scroll of the toolbox to move the target in the viewport. Add 50 to make sure it's not just at the border of the screen
                    toolbox.scrollTop = toolbox.scrollTop + (target.top + target.height - viewportHeight) + 300;
                }
            }
            this.set('beacon', {
                target,
                angle,
                offset
            });
            this.$.beacon.animate({
                opacity: [0, 1]
            }, {
                duration: 200,
                delay: 10,
                fill: 'forwards'
            });
            this.toggleClass('animate', true, this.$.beacon);
            this.toggleClass('animate', true, this.$.ring);
        },
        _ringAnimationIterated (e) {
            if (this._ringAnimationCount > 4 || this.idle) {
                return;
            }
            this._ringSoundTimeout = setTimeout(() => {
                this.playSound('/assets/audio/sounds/ding.mp3');
                this._ringAnimationCount++;
            }, 4600 * 0.75);
        },
        _onIdleChanged (idle) {
            if (idle) {
                clearTimeout(this._ringSoundTimeout);
                this._ringAnimationCount = 0;
            }
        },
        _computeElements () {
            if (!this.modeReady) {
                return;
            }

            const step = this.step;

            this.debounce('stepChanged', () => {

                if (!step) {
                    this.tooltips = [];
                    this.arrow = {};
                    this.modal.close();
                    this.$.highlight.hide();
                    return;
                }

                if (step.load_app) {
                    this.fire('load', step.load_app);
                }

                if (step.save_app) {
                    this.fire('save', {
                        id: step.save_app,
                        stepIds: this.stepIds,
                        blockIds: this.blockIds
                    });
                }

                if (step.save_to_storage) {
                    this.fire('save-to-storage');
                }
                this.modal.close();

                if (step.modal) {
                    step.modal.text = step.modal.text;
                    this.modal.open();
                }

                if (step['set-state']) {
                    this.set('state', Object.assign(this.state, step['set-state']));
                    this._nextStep();
                    return;
                }

                this.computeTooltips(step);
                this.computeArrow(step);
                this.computeBeacon(step);
                this.computeHighlight(step);
                this.computePhantomBlock(step);
                this.computeSounds(step);
            }, 10);
        },
        computeSounds (step) {
            if (this.step.play_on_end) {
                this.loadSound(`/assets/audio/sounds/${this.step.play_on_end}.wav`);
            }
        },
        computePhantomBlock (step) {
            let phantom_block = step.phantom_block,
                connection,
                target,
                host;

            if (!phantom_block ||
                !phantom_block.location ||
                !Blockly.selected) {
                Blockly.removePhantomBlock();
                return;
            }
            host = this.getTargetBlock(phantom_block.location.block);

            if (!phantom_block.target) {
                connection = host.nextConnection;
            } else {
                for (let i = 0; i < host.inputList.length; i++) {
                    if (host.inputList[i].name === phantom_block.target) {
                        connection = host.inputList[i].connection;
                        break;
                    }
                }
            }
            target = Blockly.selected;

            if (!connection) {
                return;
            }
            this.async(() => {
                Blockly.setPhantomBlock(connection, target);
            });
        },
        computeHighlight (step) {
            if (step.highlight) {
                let highlightString = JSON.stringify(step.highlight);
                if (highlightString !== this.previousHighlight) {
                    this.$.highlight.hide();
                    this.debounce('highlight', () => {
                        this.focusOn(step.highlight);
                        this.$.highlight.show();
                    }, 200);
                    this.previousHighlight = JSON.stringify(step.highlight);
                }
            } else {
                this.$.highlight.hide();
            }
        },
        focusOn (selector) {
            let target = this._getTargetElement(selector);
            target = target.getBoundingClientRect();
            this.set('highlight.x', target.left);
            this.set('highlight.y', target.top);
            this.set('highlight.width', target.width);
            this.set('highlight.height', target.height);
            this.$.highlight.show();
        },
        _getTargetElement (selector) {
            let element = this.editor,
                partId,
                block,
                el;

            if (typeof selector == 'object') {
                if (selector.block) {
                    block = this.getTargetBlock(selector.block);

                    if (selector.block.inputName) {
                        let el = this.getTargetBlockInput(selector.block);
                        if (!el) {
                            this._notifyError('Could not find input', selector.block);
                        }
                        return el;
                    }

                    if (!block || !block.svgPath_) {
                        this._notifyError('Could not find block', selector.block);
                    }
                    return block && block.svgPath_;
                } else if (selector.category) {
                    let toolbox = this._getElement('blockly-toolbox'),
                        el = toolbox.getCategoryElement(selector.category);

                    if (!el) {
                        this._notifyError('Could not find category', selector.category);
                    }
                    return el;
                } else if (selector.flyout_block) {
                    let toolbox = this._getElement('blockly-toolbox'),
                        block = toolbox.getFlyoutBlock(selector.flyout_block);

                    if (!block) {
                        this._notifyError('Could not find block in flyout', selector.flyout_block);
                    }
                    return block.getSvgRoot();
                } else if (selector.root) {
                    element = document.querySelector(selector.root);
                    selector = selector.path;
                }
            }
            el = this._getElement(selector);

            if (!el) {
                this._notifyError('Could not find element', selector);
            }

            return el;
        },
        _notifyError (message, detail) {
            this.fire('challenge-ui-error', { message, detail });
        },
        updateTooltips () {
            this.debounce('updateTooltips', () => {
                if (this.tooltips) {
                    for (let i = 0; i < this.tooltips.length; i++) {
                        if (this.$$(`#tooltip-${i}`).tracking) {
                            this.$$(`#tooltip-${i}`).updatePosition();
                        }
                    }
                }
                this.computeArrow(this.step);
                this.$$('kano-arrow').updatePosition();
            }, 100);
        },
        getTargetBlock (selector) {
            let block = this.editor.getBlocklyWorkspace().getBlockById(selector.id);

            if (selector.shadow) {
                block = block.getInput(selector.shadow).connection.targetBlock();
            }
            return block;
        },
        getTargetBlockInput (selector) {
            let block = this.getTargetBlock(selector),
                connection,
                blockRect,
                blockPos,
                inputRelPos,
                pos;

            if (selector.inputName) {
                // The input targeted might be a field. If a field exists with this name, return the rect matching
                let field = block.getField(selector.inputName),
                    input;

                if (field) {
                    return field.fieldGroup_.getBoundingClientRect();
                }

                input = block.getInput(selector.inputName);
                if (!input) {
                    return block.getSvgRoot();
                }

                connection = input.connection;
                if (!connection) {
                    return block.getSvgRoot();
                }
            } else {
                connection = block.nextConnection;
            }
            blockRect = block.svgPath_.getBoundingClientRect();
            blockPos = block.getRelativeToSurfaceXY();
            inputRelPos = {
                x: connection.x_ - blockPos.x,
                y: connection.y_ - blockPos.y
            };
            pos = {};

            pos.left = blockRect.left + inputRelPos.x;
            pos.top = blockRect.top + inputRelPos.y;

            pos.right = blockRect.right + blockRect.width - inputRelPos.x;
            pos.bottom = blockRect.bottom + blockRect.height - inputRelPos.y;

            pos.width = 1;
            pos.height = 1;

            return pos;

        },
        finishStep () {
            if (this.step.play_on_end) {
                this.playSound(`/assets/audio/sounds/${this.step.play_on_end}.wav`);
            }
        },
        _getLongestDelay () {
            let step = this.step,
                delayingElements = [],
                currentDelay,
                longestDelay;

                if (!step) {
                    return 0;
                }

                if (step.tooltips) {
                    step.tooltips.forEach(tooltip => delayingElements.push(this._getTargetElement(tooltip.location)));
                }

                if (step.beacon) {
                    delayingElements.push(this._getTargetElement(step.beacon.target));
                }

                if (step.arrow) {
                    delayingElements.push(this._getTargetElement(step.arrow.source));
                }

                delayingElements.forEach(el => {
                    if (el instanceof HTMLElement) {
                        currentDelay = parseInt(el.getAttribute('data-animate'));
                    }
                    if (currentDelay > (longestDelay || 0)) {
                        longestDelay = currentDelay;
                    }
                });
                return (longestDelay || 0);
        },
        _setupWithDelay () {
            /* Toggle idle state to show elements with a little delay when the step loads in.
            This also allows to read the current data-animate values of target elements */
            this._computeElements();
            this.idle = true;
            this.async(this._turnOnVisibility, 250);
        },
        _turnOnVisibility () {
            const delay = this._getLongestDelay();

            if (delay) {
                this.async(() => this._refitUiElements('all'), delay);
                this.async(() => this.idle = false, delay + 50);
            } else {
                this.idle = false;
            }
        },
        _onModeReadyChanged (value) {
            if (value) {
                this._computeElements();
            }
        }
    });
</script>